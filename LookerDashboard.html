<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Talent Intelligence Dashboard</title>
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Orbitron:wght@400;500;700;900&display=swap" rel="stylesheet">
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Socket.IO Client -->
    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
    <!-- Leaflet for Map -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <!-- html2pdf.js for PDF Export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>

    <style>
        :root {
            /* Default Theme (Clean/Google-ish) */
            --primary: #1a73e8;
            --bg-body: #f8f9fa;
            --bg-card: #ffffff;
            --text-main: #202124;
            --text-sub: #5f6368;
            --border: #dadce0;
            --hover: #f1f3f4;
            --shadow: 0 1px 2px 0 rgba(60,64,67,0.3), 0 1px 3px 1px rgba(60,64,67,0.15);
            
            /* App.js Specific Vars for consistent design */
            --azure-dragon: #073679;
            --cool-blue: #4c82b8;
            --muted: #222529;
            --danger: #ea4335;
            --danger-border: #d93025;
            --desired-dawn: #d8d8d8;
            --black-beauty: #222529;

            /* Org Chart Vars */
            --oc-line: #cbd5e1;
            --oc-card-bg: #fff;
            --oc-card-border: #e2e8f0;
            --oc-gap: 34px;
            --oc-thick: 2px;
        }

        /* Cyberpunk Theme Overrides */
        body.theme-cyberpunk {
            --primary: #0ea5e9; /* Cyan */
            --bg-body: #0f172a; /* Slate 900 */
            --bg-card: #1e293b; /* Slate 800 */
            --text-main: #e2e8f0; /* Slate 200 */
            --text-sub: #94a3b8; /* Slate 400 */
            --border: #334155; /* Slate 700 */
            --hover: #334155;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
            --oc-line: #475569;
            --oc-card-bg: #1e293b;
            --oc-card-border: #475569;
            --azure-dragon: #38bdf8; /* Adjust for dark mode visibility */
            --cool-blue: #0ea5e9;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-body);
            color: var(--text-main);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            transition: background-color 0.3s, color 0.3s;
        }

        /* Typography - Cyberpunk Style when active */
        body.theme-cyberpunk, 
        body.theme-cyberpunk h1, 
        body.theme-cyberpunk h2, 
        body.theme-cyberpunk h3, 
        body.theme-cyberpunk .nav-brand, 
        body.theme-cyberpunk .metric-value, 
        body.theme-cyberpunk .filter-btn,
        body.theme-cyberpunk .app-btn,
        body.theme-cyberpunk input {
            font-family: 'Orbitron', sans-serif;
        }

        /* === APP.JS COMPATIBILITY STYLES === */
        
        /* Buttons matching App.js design */
        button {
            cursor: pointer;
            border-radius: 10px;
            font-family: "Orbitron", sans-serif;
            font-weight: 700;
            letter-spacing: 0.2px;
            transition: all 0.12s ease;
        }
        
        .btn-primary {
            background: var(--azure-dragon);
            border: 1px solid var(--cool-blue);
            color: #fff;
            box-shadow: 0 8px 30px rgba(7,54,121,0.16), 0 0 18px rgba(109,234,249,0.06);
            padding: 10px;
        }
        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 12px 40px rgba(7,54,121,0.22), 0 0 26px rgba(109,234,249,0.12);
        }

        .btn-danger {
            background: var(--danger);
            border: 1px solid var(--danger-border);
            color: #fff;
            padding: 8px 16px;
        }

        .app-card-style {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            box-shadow: var(--shadow);
        }

        /* Login Screen */
        #loginContainer {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: #f1f5f9;
            position: fixed;
            top: 0; left: 0; width: 100%;
            z-index: 9999;
        }

        .login-card {
            padding: 32px;
            width: 360px;
            background: #ffffff;
            border-radius: 12px;
            box-shadow: 0 6px 18px rgba(34,34,34,0.08);
            border: 1px solid #e0e0e0;
        }

        .login-input {
            width: 100%;
            padding: 8px 12px;
            box-sizing: border-box;
            font-family: "Orbitron", sans-serif;
            border-radius: 6px;
            border: 1px solid var(--desired-dawn);
            margin-bottom: 16px;
        }
        .login-input:focus {
            outline: none;
            border-color: var(--cool-blue);
            box-shadow: 0 0 0 3px rgba(76,130,184,0.15);
        }

        .login-label {
            display: block;
            margin-bottom: 6px;
            font-weight: 700;
            font-size: 13px;
            color: var(--muted);
        }

        /* Session Banner (Replacing Top Nav when logged in) */
        .session-banner {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 18px;
            border-bottom: 1px solid var(--border);
            background: var(--bg-card);
            box-shadow: var(--shadow);
            margin-bottom: 0;
            /* Ensure it stays at top */
            position: relative; 
            z-index: 10;
        }

        /* NEW: Action Toolbar below banner */
        .action-toolbar {
            background-color: var(--bg-card);
            border-bottom: 1px solid var(--border);
            padding: 12px 24px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 12px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            flex-shrink: 0;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 14px;
        }

        .user-avatar {
            width: 52px; height: 52px;
            border-radius: 14px;
            background: var(--azure-dragon);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 17px;
            font-weight: 700;
            box-shadow: 0 4px 10px -4px rgba(7,54,121,.35);
            letter-spacing: .5px;
            font-family: "Orbitron", sans-serif;
        }

        .user-details {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .user-name {
            font-weight: 700;
            font-size: 16px;
            color: var(--black-beauty);
            font-family: 'Inter', sans-serif;
        }
        
        .user-handle {
            font-size: 12.5px;
            color: var(--cool-blue);
            font-family: 'Orbitron', sans-serif;
        }

        /* === END APP.JS COMPATIBILITY === */

        /* Top Navigation Bar */
        .top-nav {
            background-color: var(--bg-card);
            border-bottom: 1px solid var(--border);
            padding: 0 24px;
            height: 64px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            flex-shrink: 0;
        }

        .nav-brand {
            font-size: 22px;
            font-weight: 700;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 10px;
            letter-spacing: 1px;
        }

        .nav-actions {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .nav-actions button, .nav-actions select {
            background: var(--bg-body);
            color: var(--text-main);
            border: 1px solid var(--border);
            padding: 8px 12px;
            border-radius: 4px;
            font-family: inherit;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        .nav-actions button.primary {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        /* Warning/Reset button style */
        .nav-actions button.warning {
            background: transparent;
            color: var(--text-sub);
            border-color: var(--border);
        }
        .nav-actions button.warning:hover {
            border-color: #d93025;
            color: #d93025;
        }

        .nav-actions button:hover { opacity: 0.9; }

        /* Main Filter Bar */
        .filter-bar {
            background-color: var(--bg-card);
            border-bottom: 1px solid var(--border);
            padding: 16px 24px;
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
            flex-shrink: 0;
        }

        .filter-item { position: relative; display: inline-block; }

        .filter-btn {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 4px; 
            padding: 6px 14px;
            font-size: 12px;
            color: var(--text-main);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
            text-transform: uppercase;
            font-weight: 600;
        }

        .filter-btn:hover { background-color: var(--hover); }
        .filter-btn.active { 
            background-color: rgba(26, 115, 232, 0.1); 
            color: var(--primary); 
            border-color: var(--primary);
        }

        .filter-dropdown {
            display: none;
            position: absolute;
            top: 110%;
            left: 0;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 4px;
            box-shadow: var(--shadow);
            width: 250px;
            z-index: 1000;
            padding: 10px;
        }
        .filter-dropdown.show { display: block; }
        .filter-search {
            width: 100%; padding: 8px; border: 1px solid var(--border);
            border-radius: 4px; margin-bottom: 8px; box-sizing: border-box;
            background: var(--bg-body); color: var(--text-main);
            font-family: inherit;
        }
        .filter-options { max-height: 200px; overflow-y: auto; }
        .filter-option {
            padding: 6px 8px; cursor: pointer; font-size: 13px; border-radius: 4px; color: var(--text-main);
        }
        .filter-option:hover { background-color: var(--hover); }

        /* Dashboard Content */
        .dashboard-container {
            flex: 1;
            padding: 24px;
            overflow-y: auto;
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            gap: 24px;
            grid-auto-rows: auto;
            /* NEW: allow packing gaps created by resizes/reorders */
            grid-auto-flow: dense;
        }

        /* Generic Card Style */
        .card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            box-shadow: var(--shadow);
            overflow: hidden;
            position: relative; /* for tile controls */
        }
        
        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .card-header-controls {
            display: flex;
            gap: 8px;
        }

        .card h3 {
            margin: 0;
            font-size: 14px;
            color: var(--text-sub);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        /* NEW: Editable styles */
        .card h3[contenteditable="true"]:hover, 
        .metric-value[contenteditable="true"]:hover,
        .metric-label[contenteditable="true"]:hover {
            background-color: rgba(26, 115, 232, 0.05);
            outline: 1px dashed var(--primary);
            cursor: text;
        }

        .chart-type-select {
            padding: 4px 8px;
            border: 1px solid var(--border);
            border-radius: 4px;
            font-size: 11px;
            color: var(--text-sub);
            background: var(--bg-body);
            cursor: pointer;
            font-family: inherit;
        }

        /* Metric Cards */
        .metric-card { 
            grid-column: span 3; 
            min-height: 120px;
            justify-content: center;
        }
        .metric-value { font-size: 42px; font-weight: 700; color: var(--text-main); margin: 8px 0; }
        .metric-label { font-size: 13px; color: var(--text-sub); }

        /* Chart Cards */
        .chart-card { 
            grid-column: span 6; 
            height: 450px; 
            position: relative;
        }
        .chart-card.full-width { grid-column: span 12; }
        .chart-container { position: relative; flex: 1; width: 100%; height: 100%; min-height: 0; }

        /* Map Card */
        /* Updated: Ensuring Map and Org Chart share identical height sizing */
        .map-card { grid-column: span 12; height: 500px; }
        #mapContainer { width: 100%; height: 100%; border-radius: 4px; z-index: 1; background: #aadaff; }
        
        /* Updated Map Label Style */
        .map-count-label {
            background: transparent !important;
            border: none !important;
            box-shadow: none !important;
            color: #fff !important; /* High contrast text */
            font-weight: 900;
            font-size: 13px;
            text-shadow: 0 1px 3px rgba(0,0,0,0.8); /* Shadow for readability against map colors */
            text-align: center;
        }
        /* Override leaflet default tooltip pane positioning if needed */
        .leaflet-tooltip-pane .map-count-label {
            margin-top: -1px; 
        }

        /* Org Chart Section - Horizontal Tree CSS */
        .org-chart-card {
            grid-column: span 12;
            height: 500px; /* Aligned with map-card */
            overflow: hidden;
            background: var(--bg-body); 
        }
        .org-chart-scroll {
            overflow: auto;
            padding: 40px;
            height: 100%;
            text-align: center;
            /* Enable zoom-like scaling on the content */
            transform-origin: top center;
            transition: transform 0.3s ease;
        }
        /* Inner wrapper to hold content for scaling */
        #orgChartContent {
             display: inline-block;
             white-space: nowrap;
        }

        /* Horizontal Tree CSS Structure */
        .org-tree ul {
            padding-top: 20px; 
            position: relative;
            transition: all 0.5s;
            display: flex;
            justify-content: center;
        }

        .org-tree li {
            float: left; text-align: center;
            list-style-type: none;
            position: relative;
            padding: 20px 5px 0 5px;
            transition: all 0.5s;
        }

        /* Connectors */
        .org-tree li::before, .org-tree li::after {
            content: ''; position: absolute; top: 0; right: 50%;
            border-top: 2px solid var(--oc-line);
            width: 50%; height: 20px;
        }
        .org-tree li::after {
            right: auto; left: 50%;
            border-left: 2px solid var(--oc-line);
        }

        .org-tree li:only-child::after, .org-tree li:only-child::before {
            display: none;
        }
        .org-tree li:only-child { padding-top: 0; }

        .org-tree li:first-child::before, .org-tree li:last-child::after {
            border: 0 none;
        }
        .org-tree li:last-child::before{
            border-right: 2px solid var(--oc-line);
            border-radius: 0 5px 0 0;
        }
        .org-tree li:first-child::after{
            border-radius: 5px 0 0 0;
        }

        .org-tree ul::before{
            content: ''; position: absolute; top: 0; left: 50%;
            border-left: 2px solid var(--oc-line);
            width: 0; height: 20px;
        }

        /* Node Box */
        .org-node {
            display: inline-block;
            background: var(--oc-card-bg);
            border: 1px solid var(--oc-card-border);
            padding: 10px;
            border-radius: 8px;
            text-decoration: none;
            color: var(--text-main);
            font-family: inherit;
            font-size: 12px;
            min-width: 150px;
            max-width: 260px; /* a bit wider to contain long department names */
            position: relative;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            transition: all 0.3s;
            z-index: 2;
            overflow-wrap: anywhere; /* keep long text inside */
            word-break: break-word;
        }
        .org-node:hover {
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
            transform: translateY(-3px);
            border-color: var(--primary);
        }

        .org-node-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            border-bottom: 1px solid var(--border);
            padding-bottom: 6px;
        }
        .org-name { font-weight: 700; color: var(--text-main); font-size: 13px; }
        .org-badge {
            font-size: 10px; padding: 2px 6px; border-radius: 10px;
            font-weight: 700; text-transform: uppercase;
        }
        /* Badge Colors */
        .badge-manager { background: #e0f2fe; color: #0369a1; }
        .badge-senior { background: #dcfce7; color: #15803d; }
        .badge-mid { background: #fef9c3; color: #a16207; }
        .badge-junior { background: #f3f4f6; color: #475569; }
        .badge-expert { background: #fae8ff; color: #86198f; }
        .badge-lead { background: #ffedd5; color: #9a3412; }
        .badge-director { background: #fce7f3; color: #831843; }
        .badge-executive { background: #fee2e2; color: #991b1b; }

        .org-title { display: block; font-weight: 500; color: var(--text-sub); margin-bottom: 4px; white-space: normal; }
        .org-meta { display: block; font-size: 10px; color: var(--text-sub); opacity: 0.8; }

        /* Group Headers */
        .org-group-container {
            margin-bottom: 40px;
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            background: var(--bg-card);
            display: inline-block;
            margin-right: 40px;
            vertical-align: top;
            /* Allow container to fit content properly */
            max-width: 100%;
        }
        .org-group-title {
            text-align: center;
            font-weight: 700;
            color: var(--text-main);
            margin-bottom: 20px;
            font-size: 16px;
            border-bottom: 2px solid var(--primary);
            display: inline-block;
            padding-bottom: 4px;
        }

        /* Data Grid */
        .data-grid-card { 
            grid-column: span 12; 
            height: auto; 
            min-height: 400px; 
            max-height: 800px;
            overflow: hidden; 
        }
        .table-wrapper { overflow: auto; width: 100%; height: 100%; }
        table { width: 100%; border-collapse: collapse; font-size: 13px; }
        th { text-align: left; padding: 12px; border-bottom: 2px solid var(--border); color: var(--text-sub); position: sticky; top: 0; background: var(--bg-card); z-index: 2; font-family: inherit; font-size: 12px; }
        td { padding: 12px; border-bottom: 1px solid var(--border); color: var(--text-main); }
        tr:hover td { background-color: var(--hover); }

        /* Media Queries */
        @media (max-width: 1200px) {
            .metric-card { grid-column: span 6; }
            .chart-card { grid-column: span 12; }
        }
        @media (max-width: 768px) {
            .metric-card { grid-column: span 12; }
        }

        /* Loader */
        .loader-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); z-index: 2000;
            display: flex; justify-content: center; align-items: center;
            opacity: 0; pointer-events: none; transition: opacity 0.3s;
        }
        .loader-overlay.active { opacity: 1; pointer-events: all; }
        .spinner {
            border: 4px solid rgba(255,255,255,0.1); border-top: 4px solid var(--primary);
            border-radius: 50%; width: 40px; height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* ============ NEW: Resizable + Draggable tiles ============ */
        /* Map number-of-columns to data-span */
        .card[data-span="12"] { grid-column: span 12; }
        .card[data-span="10"] { grid-column: span 10; }
        .card[data-span="8"]  { grid-column: span 8; }
        .card[data-span="6"]  { grid-column: span 6; }
        .card[data-span="5"]  { grid-column: span 5; }
        .card[data-span="4"]  { grid-column: span 4; }
        .card[data-span="3"]  { grid-column: span 3; }
        .card[data-span="2"]  { grid-column: span 2; }
        .card[data-span="1"]  { grid-column: span 1; }

        .tile-controls {
            position: absolute;
            top: 8px;
            right: 8px;
            display: flex;
            gap: 6px;
            opacity: 0;
            transition: opacity .2s ease;
            z-index: 5;
        }
        .card:hover .tile-controls { opacity: 1; }
        .tile-controls button {
            background: var(--bg-body);
            border: 1px solid var(--border);
            color: var(--text-sub);
            font-size: 11px;
            padding: 4px 6px;
            border-radius: 6px;
            cursor: pointer;
            min-width: 24px;
        }
        .tile-controls button.active {
            border-color: var(--primary);
            color: var(--primary);
            font-weight: 700;
        }

        .card.dragging { opacity: .5; }
        .card-placeholder {
            border: 2px dashed var(--border);
            background: var(--hover);
            border-radius: 8px;
            min-height: 60px;
        }

        /* NEW: Empty Tile Style */
        .empty-tile-content {
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100%; 
            color: var(--text-sub); 
            border: 2px dashed var(--border); 
            border-radius: 4px;
            margin-top: 10px;
        }
        /* Highlight when filter dragged over */
        .empty-tile.drag-over {
            border-color: var(--primary);
            background-color: var(--hover);
        }
        /* Dropped tags indicators in metric card */
        .active-tags {
            position: absolute;
            bottom: 8px;
            left: 8px;
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
        }
        .active-tag {
            font-size: 10px;
            background: var(--hover);
            color: var(--text-sub);
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid var(--border);
        }
        
        /* Updated Legend Style for Cyberpunk */
        .skill-legend {
            display:none; 
            position:absolute; 
            bottom:20px; 
            left:20px; 
            background:white; 
            padding:10px; 
            border-radius:8px; 
            box-shadow:0 2px 6px rgba(0,0,0,0.2); 
            font-size:11px; 
            z-index:1000; 
            border:1px solid var(--border);
        }
        
        body.theme-cyberpunk .skill-legend {
            background: rgba(15, 23, 42, 0.95); /* Darker background */
            border: 1px solid var(--cool-blue); /* Neon border */
            box-shadow: 0 0 15px rgba(14, 165, 233, 0.4); /* Glow effect */
            color: var(--text-main);
        }
        body.theme-cyberpunk .skill-legend strong {
            color: var(--primary);
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: none; /* REMOVED LINE */
            padding-bottom: 4px;
            margin-bottom: 8px;
            display: block;
        }
        
        /* UPDATED: Flex alignment for legend items (ensures icon & text align like Image 3) */
        .skill-legend .legend-item {
            display: flex;
            align-items: center; /* Correct vertical alignment */
            margin-bottom: 6px;
            gap: 8px;
        }
        /* Legend swatch styling - first span is treated as swatch */
        .skill-legend .legend-item span:first-child {
            display:inline-block;
            width:12px;
            height:12px;
            border-radius:3px;
            flex:0 0 12px;
            box-shadow: 0 0 2px rgba(0,0,0,0.25);
        }

        /* === REPORT TEMPLATE TAB STYLES === */
        /* NEW: Container for Tabs below banner */
        .nav-tabs-container {
            background: var(--bg-card);
            border-bottom: 1px solid var(--border);
            padding: 0 24px;
            display: flex;
            gap: 24px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.02);
        }

        .tab-btn {
            background: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            color: var(--text-sub);
            font-size: 14px;
            font-weight: 600;
            padding: 12px 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .tab-btn:hover { color: var(--primary); }
        .tab-btn.active { 
            color: var(--primary); 
            border-bottom-color: var(--primary);
        }

        /* Hide tabs by default */
        .tab-content { display: none; width: 100%; height: 100%; flex-direction: column; }
        .tab-content.active { display: flex; }

        /* Template Grid */
        .template-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 24px;
            padding: 24px;
            overflow-y: auto;
        }
        .template-box {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            height: 380px; /* Increased from 300px to avoid image cropping */
            display: flex;
            flex-direction: column;
            cursor: pointer;
            transition: all 0.2s;
            overflow: hidden;
            position: relative;
        }
        .template-box:hover {
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
            transform: translateY(-2px);
            border-color: var(--primary);
        }
        .template-header {
            padding: 12px;
            font-weight: 700;
            border-bottom: 1px solid var(--border);
            background: var(--hover);
            color: var(--text-main);
            text-align: center;
        }
        .template-preview {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #eef2f6;
            color: var(--text-sub);
            font-size: 13px;
        }
        .template-preview img {
            width: 100%;
            height: 100%;
            object-fit: contain; /* Changed from cover to contain so the full image shows */
            object-position: center;
        }
    </style>
</head>
<body class="theme-default">

<div class="loader-overlay" id="globalLoader"><div class="spinner"></div></div>

<!-- === LOGIN SCREEN === -->
<div id="loginContainer">
    <div class="login-card">
        <h2 style="margin-top: 0; margin-bottom: 24px; text-align: center; color: var(--azure-dragon); font-family: 'Orbitron', sans-serif;">Login</h2>
        <form id="loginForm" onsubmit="handleLoginSubmit(event)">
            <div style="margin-bottom: 16px;">
                <label class="login-label">Username</label>
                <input type="text" id="usernameInput" class="login-input" required />
            </div>
            <div style="margin-bottom: 24px;">
                <label class="login-label">Password</label>
                <input type="password" id="passwordInput" class="login-input" required />
            </div>
            <div id="loginError" style="color: var(--danger); margin-bottom: 16px; font-size: 13px; text-align: center; font-weight: bold; display: none;"></div>
            <button type="submit" class="btn-primary" style="width: 100%;">Login</button>
        </form>
    </div>
</div>

<!-- === AUTHENTICATED CONTENT === -->
<div id="appContent" style="display: none; width: 100%; height: 100vh; flex-direction: column;">

    <!-- Navigation (Replaces Standard Nav when logged in to match App.js) -->
    <div class="session-banner">
        <div class="user-info">
            <div class="user-avatar" id="userInitials">U</div>
            <div class="user-details">
                <div class="user-name" id="userFullName">Welcome</div>
                <div class="user-handle" id="userHandle">@username</div>
            </div>
        </div>
        
        <!-- Moved Logout Button Here -->
        <button
            onclick="handleLogout()"
            style="background:var(--bg-body); color:var(--azure-dragon); border:1px solid var(--cool-blue); border-radius:10px; padding:8px 18px; fontWeight:700; fontSize:13px; cursor:pointer; boxShadow:0 2px 6px -4px rgba(11,98,192,.25)"
        >Logout</button>
    </div>
    
    <!-- NEW: Tab Controls Below Banner -->
    <div class="nav-tabs-container">
        <button class="tab-btn active" onclick="switchTab('dashboard')">Dashboard</button>
        <button class="tab-btn" onclick="switchTab('templates')">Report Template</button>
    </div>
    
    <!-- DASHBOARD TAB CONTENT -->
    <div id="tab-dashboard" class="tab-content active">
        <!-- Toolbar (New Location below banner) -->
        <div class="action-toolbar">
            <div class="nav-actions">
                <select id="themeSelector" onchange="changeTheme(this.value)">
                    <option value="default">Clean Theme</option>
                    <option value="cyberpunk">Cyberpunk Theme</option>
                </select>
                <button onclick="addEmptyTile()" title="Insert a new empty tile">Add Tile</button>
                <button class="warning" onclick="resetDashboardLayout()" title="Restore default layout">Reset Layout</button>
                <button class="primary" onclick="loadDashboardState()" title="Load last saved state">Load State</button>
                <button class="primary" onclick="saveDashboardState()">Save State</button>
                <button class="primary" onclick="refreshDashboard()">Refresh Data</button>
                <!-- NEW: Export PDF Button -->
                <button class="primary" onclick="exportToPDF()" title="Export Dashboard to PDF">Export PDF</button>
                <!-- PORT BUTTON: Triggers Google OAuth and Export to Looker Studio -->
                <button class="primary" onclick="handlePortToLooker()" title="Port data to Looker Studio via Google Sheets">Port</button>
            </div>
        </div>

        <!-- Filter Bar -->
        <div class="filter-bar" id="filterContainer">
            <!-- Filters generated by JS -->
        </div>

        <!-- Dashboard Grid -->
        <div class="dashboard-container" id="dashboardGrid">
            
            <!-- KPI Row -->
            <div class="card metric-card">
                <h3>Total Candidates</h3>
                <div class="metric-value" id="kpiTotal">0</div>
                <div class="metric-label">Across all records</div>
            </div>
            <div class="card metric-card">
                <h3>Senior Profiles</h3>
                <div class="metric-value" id="kpiSenior">0</div>
                <div class="metric-label">Seniority &gt; Mid</div>
            </div>
            <!-- Replaced Mapped Skills with Skills Gap -->
            <div class="card metric-card">
                <h3>Skills Gap</h3>
                <div class="metric-value" id="kpiGap">0</div>
                <div class="metric-label">Unique missing skills</div>
            </div>
            <div class="card metric-card">
                <h3>Avg Rating</h3>
                <div class="metric-value" id="kpiRating">0%</div>
                <div class="metric-label">Assessment score</div>
            </div>

            <!-- Charts Row 1 -->
            <div class="card chart-card">
                <div class="card-header">
                    <h3>Geography Distribution</h3>
                    <select id="chartType-geoChart" class="chart-type-select" onchange="updateChartType('geoChart', 'country', this.value)">
                        <option value="bar">Bar Chart</option>
                        <option value="pie">Pie Chart</option>
                        <option value="line">Line Chart</option>
                        <option value="polarArea">Polar Area</option>
                        <option value="radar">Radar Chart</option>
                    </select>
                </div>
                <div class="chart-container">
                    <canvas id="geoChart"></canvas>
                </div>
            </div>
            <div class="card chart-card">
                <div class="card-header">
                    <h3>Job Family Breakdown</h3>
                    <select id="chartType-familyChart" class="chart-type-select" onchange="updateChartType('familyChart', 'jobfamily', this.value)">
                        <option value="doughnut">Doughnut Chart</option>
                        <option value="bar">Bar Chart</option>
                        <option value="pie">Pie Chart</option>
                        <option value="polarArea">Polar Area</option>
                        <option value="radar">Radar Chart</option>
                    </select>
                </div>
                <div class="chart-container">
                    <canvas id="familyChart"></canvas>
                </div>
            </div>

            <!-- Charts Row 2 -->
            <div class="card chart-card">
                <div class="card-header">
                    <h3>Seniority Levels</h3>
                    <select id="chartType-seniorityChart" class="chart-type-select" onchange="updateChartType('seniorityChart', 'seniority', this.value)">
                        <option value="polarArea" selected>Polar Area</option>
                        <option value="bar">Bar Chart</option>
                        <option value="pie">Pie Chart</option>
                        <option value="doughnut">Doughnut Chart</option>
                        <option value="radar">Radar Chart</option>
                    </select>
                </div>
                <div class="chart-container">
                    <canvas id="seniorityChart"></canvas>
                </div>
            </div>
            <div class="card chart-card">
                <div class="card-header">
                    <h3>Skillset Frequency (Top 10)</h3>
                    <!-- RESTORED: Chart Type Select for Skillset -->
                    <select id="chartType-skillChart" class="chart-type-select" onchange="updateChartType('skillChart', 'skillset', this.value)">
                        <option value="map" selected>Map</option> <!-- Default Map -->
                        <option value="bar">Bar Chart</option>
                        <option value="pie">Pie Chart</option>
                        <option value="doughnut">Doughnut Chart</option>
                        <option value="line">Line Chart</option>
                        <option value="polarArea">Polar Area</option>
                        <option value="radar">Radar Chart</option>
                    </select>
                </div>
                <div class="chart-container">
                    <!-- Wrapper to toggle between Canvas and Map -->
                    <div id="skillContentWrapper" style="position:relative; width:100%; height:100%;">
                        <canvas id="skillChart"></canvas>
                        <div id="skillMapContainer" style="position:absolute; top:0; left:0; width:100%; height:100%; border-radius:4px; z-index:1; background:#aadaff; display:none;"></div>
                        <!-- Legend Container -->
                        <div id="skillMapLegend" class="skill-legend">
                            <strong style="display:block; margin-bottom:6px;">Top Skills</strong>
                            <div id="skillMapLegendItems"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- NEW: Skills Gap Chart sharing row with Product Chart -->
            <div class="card chart-card">
                <div class="card-header">
                    <h3>Skills Gap Analysis</h3>
                    <select id="chartType-gapChart" class="chart-type-select" onchange="updateChartType('gapChart', 'lskillset', this.value)">
                        <option value="radar" selected>Radar Chart</option>
                        <option value="bar">Bar Chart</option>
                        <option value="line">Line Chart</option>
                        <option value="polarArea">Polar Area</option>
                    </select>
                </div>
                <div class="chart-container">
                    <canvas id="gapChart"></canvas>
                </div>
            </div>

            <!-- Product Chart (Resized to share row) -->
            <div class="card chart-card">
                <div class="card-header">
                    <h3>Product & Sector Distribution</h3>
                    <select id="chartType-productChart" class="chart-type-select" onchange="updateChartType('productChart', 'product', this.value)">
                        <option value="line">Line Chart</option>
                        <option value="bar">Bar Chart</option>
                        <option value="polarArea">Polar Area</option>
                        <option value="radar">Radar Chart</option>
                    </select>
                </div>
                <div class="chart-container">
                    <canvas id="productChart"></canvas>
                </div>
            </div>

            <!-- Map Section -->
            <div class="card map-card">
                <div class="card-header">
                    <h3>Candidate Locations</h3>
                    <!-- UPDATED: Chart Type Select for Locations -->
                    <select id="chartType-locationChart" class="chart-type-select" onchange="updateChartType('locationChart', 'country', this.value)">
                        <option value="map" selected>Map</option>
                        <option value="bar">Bar Chart</option>
                        <option value="pie">Pie Chart</option>
                        <option value="doughnut">Doughnut Chart</option>
                        <option value="line">Line Chart</option>
                        <option value="polarArea">Polar Area</option>
                    </select>
                </div>
                <div style="position:relative; height:100%; width:100%;">
                    <!-- Wrapper for toggling -->
                    <div id="locationContentWrapper" style="position:relative; width:100%; height:100%;">
                        <div id="mapContainer" style="width: 100%; height: 100%; border-radius: 4px; z-index: 1;"></div>
                        <canvas id="locationChart" style="display:none;"></canvas>
                    </div>
                    <!-- Legend for Map -->
                    <div id="geoMapLegend" class="skill-legend" style="display:none;">
                        <strong style="display:block; margin-bottom:6px;">Top Locations</strong>
                        <div id="geoMapLegendItems"></div>
                    </div>
                </div>
            </div>

            <!-- Org Chart Section -->
            <div class="card org-chart-card">
                <div class="card-header">
                    <h3>Organizational Hierarchy</h3>
                    <div class="card-header-controls">
                        <select id="orgChartCompanyFilter" class="chart-type-select" onchange="buildOrgChart()">
                            <option value="">All Companies</option>
                        </select>
                    </div>
                </div>
                <div class="org-chart-scroll" id="orgChartContainer">
                    <!-- Wrap in content div for scaling -->
                    <div id="orgChartContent">
                        <!-- Org trees populated by JS -->
                        <div style="padding:20px; color:var(--text-sub);">Loading hierarchy...</div>
                    </div>
                </div>
            </div>

            <!-- Data Table -->
            <div class="card data-grid-card">
                <div class="card-header">
                    <h3>Candidate Details</h3>
                    <!-- Updated Button triggers limited CSV export -->
                    <button class="chart-type-select" onclick="exportCandidateDetailsCSV()">Export CSV</button>
                </div>
                <div class="table-wrapper">
                    <table id="dataTable">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Job Title</th>
                                <th>Company</th>
                                <th>Country</th>
                                <th>Job Family</th>
                                <th>Score</th>
                                <th>Status</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Rows populated by JS -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
    
    <!-- REPORT TEMPLATE TAB CONTENT -->
    <div id="tab-templates" class="tab-content">
        <div class="template-grid">
            <div class="template-box" onclick="selectTemplate('868ad68d-649e-4ccd-8dfc-d1d1b387790e', 'https://lookerstudio.google.com/reporting/868ad68d-649e-4ccd-8dfc-d1d1b387790e/page/vJYmF')">
                <div class="template-header">Fio Sourcing Intelligence</div>
                <div class="template-preview">
                    <!-- Updated Image Path to handle spaces in file name -->
                    <img src="http://localhost:4000/image/Fio%20Sourcing%20Intelligence.jpg" alt="Fio Sourcing Intelligence" />
                </div>
            </div>
            <div class="template-box"><div class="template-header">Empty Slot</div><div class="template-preview">Coming Soon</div></div>
            <div class="template-box"><div class="template-header">Empty Slot</div><div class="template-preview">Coming Soon</div></div>
            <div class="template-box"><div class="template-header">Empty Slot</div><div class="template-preview">Coming Soon</div></div>
            <div class="template-box"><div class="template-header">Empty Slot</div><div class="template-preview">Coming Soon</div></div>
            <div class="template-box"><div class="template-header">Empty Slot</div><div class="template-preview">Coming Soon</div></div>
        </div>
    </div>

</div>

<script>
    // ================= CONFIGURATION =================
    const API_BASE = 'http://localhost:4000'; // Match server.js port
    let currentUser = null;
    let socket = null;
    let isPorting = false; // Flag to track porting process
    
    // Updated: replaced 'jskill' with 'jskillset'
    const FILTER_FIELDS = [
        'name', 'company', 'jobtitle', 'country', 'linkedinurl', 
        'product', 'sector', 'jobfamily', 'geographic', 'seniority', 
        'skillset', 'sourcingstatus', 'email', 'mobile', 'office', 
        'role_tag', 'jskillset', 'rating', 'lskill'
    ];

    const FIELD_MAPPING = {
        'lskill': 'lskillset' 
    };
    
    // State
    let globalData = [];
    const activeFilters = {}; 
    const charts = {}; // Store Chart.js instances
    let mapInstance = null; 
    let mapMarkers = []; 
    // New: Skill Map Instance
    let skillMapInstance = null;
    let skillMapMarkers = [];
    let skillMapDataCache = null; // Cache for zoom handling

    const COUNTRY_COORDS = {
        'Singapore': [1.3521, 103.8198], 'United States': [37.0902, -95.7129], 'USA': [37.0902, -95.7129],
        'US': [37.0902, -95.7129], 'China': [35.8617, 104.1954], 'India': [20.5937, 78.9629],
        'United Kingdom': [55.3781, -3.4360], 'UK': [55.3781, -3.4360], 'Germany': [51.1657, 10.4515],
        'Japan': [36.2048, 138.2529], 'France': [46.2276, 2.2137], 'Canada': [56.1304, -106.3468],
        'Australia': [-25.2744, 133.7751], 'Brazil': [-14.2350, -51.9253], 'South Korea': [35.9078, 127.7669],
        'Korea': [35.9078, 127.7669], 'Russia': [61.5240, 105.3188], 'Spain': [40.4637, -3.7492],
        'Italy': [41.8719, 12.5674], 'Netherlands': [52.1326, 5.2913], 'Sweden': [60.1282, 18.6435],
        'Poland': [51.9194, 19.1451], 'Taiwan': [23.6978, 120.9605], 'Vietnam': [14.0583, 108.2772],
        'Thailand': [15.8700, 100.9925], 'Malaysia': [4.2105, 101.9758], 'Indonesia': [-0.7893, 113.9213],
        'Philippines': [12.8797, 121.7740]
    };

    // ================= AUTHENTICATION LOGIC =================
    async function checkAuthOnLoad() {
        try {
            const res = await fetch(`${API_BASE}/user/resolve`, { credentials: 'include' });
            const data = await res.json();
            if (data.ok) {
                currentUser = data;
                showApp();
            } else {
                showLogin();
            }
        } catch (e) {
            console.warn("Auth check failed, showing login", e);
            showLogin();
        }
    }

    function showLogin() {
        document.getElementById('loginContainer').style.display = 'flex';
        document.getElementById('appContent').style.display = 'none';
    }

    function showApp() {
        document.getElementById('loginContainer').style.display = 'none';
        document.getElementById('appContent').style.display = 'flex';
        
        // Update Banner
        const name = currentUser.full_name || currentUser.username || "User";
        document.getElementById('userFullName').innerText = name;
        document.getElementById('userHandle').innerText = '@' + currentUser.username;
        const initials = name.split(/\s+/).slice(0,2).map(p=>p[0].toUpperCase()).join('');
        document.getElementById('userInitials').innerText = initials;

        // Initialize Dashboard functionality
        initDashboard();
        
        // Connect Socket
        initSocket();
    }

    async function handleLoginSubmit(e) {
        e.preventDefault();
        const user = document.getElementById('usernameInput').value;
        const pass = document.getElementById('passwordInput').value;
        const errorDiv = document.getElementById('loginError');
        const loader = document.getElementById('globalLoader');

        if(!user || !pass) return;

        loader.classList.add('active');
        errorDiv.style.display = 'none';

        try {
            const res = await fetch(`${API_BASE}/login`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ username: user, password: pass }),
                credentials: 'include'
            });
            const data = await res.json();
            
            if (res.ok && data.ok) {
                currentUser = data;
                showApp();
            } else {
                errorDiv.innerText = data.error || 'Login failed';
                errorDiv.style.display = 'block';
            }
        } catch (err) {
            errorDiv.innerText = 'Connection error';
            errorDiv.style.display = 'block';
        } finally {
            loader.classList.remove('active');
        }
    }

    async function handleLogout() {
        await fetch(`${API_BASE}/logout`, { method: 'POST', credentials: 'include' });
        currentUser = null;
        if(socket) socket.disconnect();
        showLogin();
    }

    function initSocket() {
        if(typeof io !== 'undefined') {
            socket = io(API_BASE);
            socket.on('connect', () => console.log('Connected to realtime updates'));
            socket.on('candidates_changed', () => refreshDashboard());
            socket.on('candidate_updated', () => refreshDashboard()); 
        }
    }

    // ================= INITIALIZATION =================
    document.addEventListener('DOMContentLoaded', async () => {
        // Start with Auth Check
        checkAuthOnLoad();
    });

    async function initDashboard() {
        initFilters();
        
        // Restore filters from save state before fetching/filtering data
        restoreFilters(); 
        
        // Init map (using saved position if present)
        initMap();

        await refreshDashboard();
        
        // Layout restore
        enableTileInteractivity();
        restoreSavedLayout();
        
        // Restore Theme and Charts Config
        loadDashboardState(true); // true = auto load
    }

    // ================= THEME LOGIC =================
    function changeTheme(theme) {
        document.body.className = `theme-${theme}`;
        document.getElementById('themeSelector').value = theme;
        updateAllVisuals();
    }
    
    // ================= TAB LOGIC =================
    function switchTab(tabId) {
        // Update buttons
        document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
        const btn = Array.from(document.querySelectorAll('.tab-btn')).find(b => b.textContent.toLowerCase().includes(tabId === 'dashboard' ? 'dashboard' : 'template'));
        if(btn) btn.classList.add('active');

        // Update content
        document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
        document.getElementById(`tab-${tabId}`).classList.add('active');
        
        // If switching to dashboard, ensure map/charts resize correctly
        if(tabId === 'dashboard') {
            setTimeout(() => {
                if(mapInstance) mapInstance.invalidateSize();
                Object.values(charts).forEach(c => c.resize());
            }, 100);
        }
    }
    
    // ================= TEMPLATE SELECTION LOGIC =================
    async function selectTemplate(reportId, reportUrl) {
        if (!confirm('Set this as your active report template?')) return;
        
        // Removed window.open to prevent new tab opening
        
        try {
            const res = await fetch(`${API_BASE}/save-report-template`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ reportId: reportId }),
                credentials: 'include'
            });
            
            if (res.ok) {
                // If porting was requested, continue the process
                if (isPorting) {
                    if(confirm('Template saved. Continue to authenticate and port data to Looker Studio?')) {
                        window.open(`${API_BASE}/port-to-looker`, '_blank', 'width=600,height=700');
                    }
                    isPorting = false; // Reset flag
                } else {
                    alert('Template selected successfully!');
                }
            } else {
                alert('Failed to save template selection.');
            }
        } catch (e) {
            console.error('Template select error:', e);
            alert('Error selecting template.');
        }
    }

    // ================= PDF EXPORT LOGIC =================
    function exportToPDF() {
        const element = document.getElementById('dashboardGrid');
        const opt = {
            margin: 1,
            filename: 'dashboard_export.pdf',
            image: { type: 'jpeg', quality: 0.98 },
            html2canvas: { scale: 2, useCORS: true },
            jsPDF: { unit: 'in', format: 'letter', orientation: 'landscape' }
        };
        
        // Hide scrollbars for cleaner PDF
        const originalOverflow = element.style.overflow;
        element.style.overflow = 'visible';
        
        // Temporarily adjust grid to ensure everything fits or flows
        html2pdf().set(opt).from(element).save().then(() => {
            element.style.overflow = originalOverflow;
        });
    }

    // ================= FILTERS LOGIC =================
    function initFilters() {
        const container = document.getElementById('filterContainer');
        container.innerHTML = '';
        
        FILTER_FIELDS.forEach(field => {
            const wrapper = document.createElement('div');
            wrapper.className = 'filter-item';
            
            const btn = document.createElement('div');
            btn.className = 'filter-btn';
            btn.dataset.field = field; // Identifier
            btn.innerHTML = `<span>${formatLabel(field)}</span> <span></span>`;
            
            // NEW: Make filter draggable
            btn.setAttribute('draggable', 'true');
            btn.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('application/x-filter-field', field);
                e.dataTransfer.effectAllowed = 'copy';
            });

            btn.onclick = (e) => toggleDropdown(e, field, wrapper);
            
            const dropdown = document.createElement('div');
            dropdown.className = 'filter-dropdown';
            dropdown.innerHTML = `
                <input type="text" class="filter-search" placeholder="Search..." onclick="event.stopPropagation()">
                <div class="filter-options" id="options-${field}">Loading...</div>
            `;

            const searchInput = dropdown.querySelector('input');
            searchInput.addEventListener('input', (e) => filterOptionsList(field, e.target.value));

            wrapper.appendChild(btn);
            wrapper.appendChild(dropdown);
            container.appendChild(wrapper);
        });
    }

    async function toggleDropdown(e, field, wrapper) {
        e.stopPropagation();
        const dropdown = wrapper.querySelector('.filter-dropdown');
        const isVisible = dropdown.classList.contains('show');
        document.querySelectorAll('.filter-dropdown').forEach(d => d.classList.remove('show'));
        if (!isVisible) {
            dropdown.classList.add('show');
            loadFilterOptions(field);
        }
    }

    document.addEventListener('click', () => {
        document.querySelectorAll('.filter-dropdown').forEach(d => d.classList.remove('show'));
    });

    function loadFilterOptions(field) {
        const listContainer = document.getElementById(`options-${field}`);
        const uniqueValues = new Set();
        const dataKey = FIELD_MAPPING[field] || field;

        globalData.forEach(row => {
            const val = row[dataKey];
            if (val) {
                // Updated: use jskillset and strip brackets/quotes
                if (['skillset', 'product', 'lskillset', 'jskillset'].includes(dataKey)) {
                    // Remove [, ], " before splitting
                    String(val).replace(/[\[\]"]/g, '').split(/[,;]/).forEach(v => {
                        const trimmed = v.trim();
                        if (trimmed) uniqueValues.add(trimmed);
                    });
                } else {
                    uniqueValues.add(String(val).trim());
                }
            }
        });

        const sortedOptions = Array.from(uniqueValues).sort();
        renderOptionsList(field, sortedOptions);
    }

    function renderOptionsList(field, options) {
        const listContainer = document.getElementById(`options-${field}`);
        listContainer.innerHTML = '';
        
        const allOpt = document.createElement('div');
        allOpt.className = 'filter-option';
        allOpt.textContent = 'All';
        allOpt.onclick = () => applyFilter(field, null);
        listContainer.appendChild(allOpt);

        options.forEach(opt => {
            const div = document.createElement('div');
            div.className = 'filter-option';
            
            // Format Rating for Display
            let displayLabel = opt;
            if (field === 'rating') {
                const match = String(opt).match(/Level\s*(\d+).*?(\d+%)/i);
                if (match) {
                    displayLabel = `Level ${match[1]} Assessment: ${match[2]}`;
                }
            }

            div.textContent = displayLabel;
            div.onclick = () => applyFilter(field, opt);
            listContainer.appendChild(div);
        });
        
        listContainer.dataset.allOptions = JSON.stringify(options);
    }

    function filterOptionsList(field, text) {
        const listContainer = document.getElementById(`options-${field}`);
        const allOptions = JSON.parse(listContainer.dataset.allOptions || '[]');
        const filtered = allOptions.filter(o => o.toLowerCase().includes(text.toLowerCase()));
        
        listContainer.innerHTML = ''; 
        const allOpt = document.createElement('div');
        allOpt.className = 'filter-option';
        allOpt.textContent = 'All';
        allOpt.onclick = () => applyFilter(field, null);
        listContainer.appendChild(allOpt);

        filtered.forEach(opt => {
            const div = document.createElement('div');
            div.className = 'filter-option';
            
            // Format Rating for Display in Search Results
            let displayLabel = opt;
            if (field === 'rating') {
                const match = String(opt).match(/Level\s*(\d+).*?(\d+%)/i);
                if (match) {
                    displayLabel = `Level ${match[1]} Assessment: ${match[2]}`;
                }
            }
            
            div.textContent = displayLabel;
            div.onclick = () => applyFilter(field, opt);
            listContainer.appendChild(div);
        });
    }

    function applyFilter(field, value) {
        if (value) {
            activeFilters[field] = value;
        } else {
            delete activeFilters[field];
        }
        updateFilterButtonState(field, value);
        updateAllVisuals();
    }

    function updateFilterButtonState(field, value) {
        const btn = document.querySelector(`.filter-btn[data-field="${field}"]`);
        if (!btn) return;
        
        if (value) {
            let displayValue = value;
            // Format Rating for Display in Button
            if (field === 'rating') {
                const match = String(value).match(/Level\s*(\d+).*?(\d+%)/i);
                if (match) {
                    displayValue = `Level ${match[1]} Assessment: ${match[2]}`;
                }
            }

            btn.classList.add('active');
            btn.innerHTML = `<span>${formatLabel(field)}: <b>${displayValue}</b></span> <span></span>`;
        } else {
            btn.classList.remove('active');
            btn.innerHTML = `<span>${formatLabel(field)}</span> <span></span>`;
        }
    }

    // ================= MAP LOGIC =================
    function initMap() {
        // Check for saved state
        let center = [20, 0];
        let zoom = 2;
        
        try {
            const saved = localStorage.getItem('dashboard:map');
            if (saved) {
                const p = JSON.parse(saved);
                if (p.center && p.zoom) {
                    center = p.center;
                    zoom = p.zoom;
                }
            }
        } catch(e){}

        if(mapInstance) {
            mapInstance.remove(); // Clean up if re-initializing
        }

        mapInstance = L.map('mapContainer', {
            dragging: true,
            scrollWheelZoom: true
        }).setView(center, zoom);

        const mapContainer = document.getElementById('mapContainer');
        const mapCard = mapContainer.closest('.card');
        
        // ROBUST DRAG PREVENTION
        // When mouse enters map area, strictly disable dragging on the parent card
        mapContainer.addEventListener('mouseenter', () => {
            if(mapCard) mapCard.setAttribute('draggable', 'false');
        });
        // When mouse leaves map area, re-enable dragging on the parent card
        mapContainer.addEventListener('mouseleave', () => {
            if(mapCard) mapCard.setAttribute('draggable', 'true');
        });
        
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
            maxZoom: 18,
            minZoom: 2,
            noWrap: true,
            bounds: [[-90, -180], [90, 180]]
        }).addTo(mapInstance);
    }

    // NEW: Reset Map Function
    function resetMap() {
        if(mapInstance) {
            mapInstance.setView([20, 0], 2);
        }
    }

    function updateMap() {
        if (!mapInstance) return;
        mapMarkers.forEach(m => mapInstance.removeLayer(m));
        mapMarkers = [];

        const filtered = getFilteredData();
        const countryCounts = {};

        // 1. Count
        filtered.forEach(row => {
            let country = row.country;
            if (!country) return;
            country = country.trim();
            if (country.toLowerCase() === 'usa') country = 'United States';
            if (country.toLowerCase() === 'uk') country = 'United Kingdom';
            countryCounts[country] = (countryCounts[country] || 0) + 1;
        });

        // 2. Top 10 Logic & Colors
        const sortedCountries = Object.entries(countryCounts).sort((a,b) => b[1]-a[1]);
        const top10 = sortedCountries.slice(0, 10).map(x => x[0]);
        
        const chartColors = [
            '#1a73e8', '#e37400', '#1e8e3e', '#d93025', '#9334e6', '#00acc1', '#f09300', '#188038',
            '#3c4043', '#7b1fa2', '#129eaf', '#c2185b'
        ];
        
        const colorMap = {};
        top10.forEach((c, i) => {
            colorMap[c] = chartColors[i % chartColors.length];
        });

        // 3. Legend Update
        const legend = document.getElementById('geoMapLegend');
        const legendItems = document.getElementById('geoMapLegendItems');
        
        if (legend && legendItems) {
            legendItems.innerHTML = '';
            top10.forEach(c => {
                const item = document.createElement('div');
                item.className = 'legend-item'; // Add class for flex alignment
                item.innerHTML = `<span style="display:inline-block; width:10px; height:10px; background:${colorMap[c]}; margin-right:6px; border-radius:2px; box-shadow:0 0 2px rgba(0,0,0,0.3);"></span><strong>${c}</strong>`;
                legendItems.appendChild(item);
            });
            legend.style.display = top10.length > 0 ? 'block' : 'none';
        }

        // 4. Render Markers
        Object.entries(countryCounts).forEach(([country, count]) => {
            const coords = COUNTRY_COORDS[country] || COUNTRY_COORDS[Object.keys(COUNTRY_COORDS).find(k => country.includes(k))];
            if (coords) {
                const isTop = top10.includes(country);
                const color = isTop ? colorMap[country] : '#64748b'; // Default grey for non-top
                const radius = 5 + Math.log(count) * 5; 
                
                const marker = L.circleMarker(coords, {
                    color: '#fff', // White border like skillset
                    weight: 1,     // Thin border
                    fillColor: color, 
                    fillOpacity: 0.7, // Higher opacity
                    radius: radius
                }).addTo(mapInstance);
                
                // Add permanent tooltip for exact count
                // Updated: use custom class to remove white background/overlay
                marker.bindTooltip(`${count}`, { 
                    permanent: true, 
                    direction: 'center',
                    className: 'map-count-label' 
                });

                marker.bindPopup(`<b>${country}</b><br>Candidates: ${count}`);
                mapMarkers.push(marker);
            }
        });
    }

    // ================= SKILL MAP LOGIC =================
    function updateSkillMap() {
        const containerId = 'skillMapContainer';
        if (!document.getElementById(containerId)) return;

        // Init Skill Map Instance if missing
        if (!skillMapInstance) {
            skillMapInstance = L.map(containerId, {
                dragging: true,
                scrollWheelZoom: true,
                zoomControl: false // Minimal UI
            }).setView([20, 0], 1);
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '',
                maxZoom: 18,
                minZoom: 1,
                noWrap: true
            }).addTo(skillMapInstance);

            const container = document.getElementById(containerId);
            const card = container.closest('.card');
            container.addEventListener('mouseenter', () => { if(card) card.setAttribute('draggable', 'false'); });
            container.addEventListener('mouseleave', () => { if(card) card.setAttribute('draggable', 'true'); });
            
            // Add zoom handler to toggle clutter reduction
            skillMapInstance.on('zoomend', () => {
                renderSkillMapMarkers();
            });
        }

        // Cache calculations for render function
        calculateSkillMapData();
        renderSkillMapMarkers();
    }

    function calculateSkillMapData() {
        const filtered = getFilteredData();
        const countrySkills = {}; 
        
        // Aggregate data: Country -> Skills -> Count
        filtered.forEach(r => {
            let c = r.country;
            if(!c) return;
            c = c.trim();
            if (c.toLowerCase() === 'usa') c = 'United States';
            if (c.toLowerCase() === 'uk') c = 'United Kingdom';

            const val = r.skillset;
            if(!val) return;
            
            if(!countrySkills[c]) countrySkills[c] = {};
            
            String(val).replace(/[\[\]"]/g, '').split(/[,;]/).forEach(s => {
                const clean = s.trim();
                if(clean) countrySkills[c][clean] = (countrySkills[c][clean] || 0) + 1;
            });
        });

        // Global stats for scaling and colors
        let globalMaxCount = 0;
        const globalSkillCounts = {};
        Object.keys(countrySkills).forEach(c => {
            Object.values(countrySkills[c]).forEach(cnt => {
                if(cnt > globalMaxCount) globalMaxCount = cnt;
            });
            Object.keys(countrySkills[c]).forEach(s => {
                globalSkillCounts[s] = (globalSkillCounts[s] || 0) + countrySkills[c][s];
            });
        });

        const top10Skills = Object.entries(globalSkillCounts)
            .sort((a,b) => b[1]-a[1])
            .slice(0, 10)
            .map(e => e[0]);

        const chartColors = [
            '#1a73e8', '#e37400', '#1e8e3e', '#d93025', '#9334e6', '#00acc1', '#f09300', '#188038',
            '#3c4043', '#7b1fa2', '#129eaf', '#c2185b'
        ];
        
        const skillColorMap = {};
        top10Skills.forEach((s, i) => {
            skillColorMap[s] = chartColors[i % chartColors.length];
        });

        // Prepare structured data for caching
        const countriesData = [];
        Object.keys(countrySkills).forEach(country => {
            const skillsInCountry = countrySkills[country];
            const coords = COUNTRY_COORDS[country] || COUNTRY_COORDS[Object.keys(COUNTRY_COORDS).find(k => country.includes(k))];
            
            if(coords) {
                // Identify top local skill for aggregated view
                const sortedLocal = Object.entries(skillsInCountry).sort((a,b) => b[1]-a[1]);
                const topLocal = sortedLocal.length > 0 ? sortedLocal[0] : null;
                const totalLocal = Object.values(skillsInCountry).reduce((a,b)=>a+b, 0);

                // Filter skills to only include global Top 10 present here
                const relevantSkills = [];
                top10Skills.forEach(skill => {
                    if(skillsInCountry[skill]) {
                        relevantSkills.push({
                            skill: skill,
                            count: skillsInCountry[skill],
                            color: skillColorMap[skill],
                            intensity: globalMaxCount > 0 ? (0.4 + (skillsInCountry[skill] / globalMaxCount) * 0.6) : 1
                        });
                    }
                });

                if(relevantSkills.length > 0) {
                    countriesData.push({
                        name: country,
                        coords: coords,
                        topSkillName: topLocal ? topLocal[0] : '',
                        topSkillColor: topLocal && skillColorMap[topLocal[0]] ? skillColorMap[topLocal[0]] : '#666',
                        totalCount: totalLocal,
                        skills: relevantSkills
                    });
                }
            }
        });

        skillMapDataCache = {
            countries: countriesData,
            top10: top10Skills,
            colorMap: skillColorMap,
            globalMax: globalMaxCount
        };

        // Update Legend
        const legendContainer = document.getElementById('skillMapLegend');
        const legendItems = document.getElementById('skillMapLegendItems');
        if (legendContainer && legendItems) {
            legendItems.innerHTML = '';
            top10Skills.forEach(s => {
                const item = document.createElement('div');
                item.className = 'legend-item'; // Add class for flex alignment
                item.innerHTML = `<span style="background:${skillColorMap[s]};"></span><strong>${s}</strong>`;
                legendItems.appendChild(item);
            });
            legendContainer.style.display = top10Skills.length > 0 ? 'block' : 'none';
        }
    }

    function renderSkillMapMarkers() {
        if(!skillMapInstance || !skillMapDataCache) return;
        
        // Clear existing markers
        skillMapMarkers.forEach(m => skillMapInstance.removeLayer(m));
        skillMapMarkers = [];

        const zoom = skillMapInstance.getZoom();
        const thresholdZoom = 4; // Zoom level to switch between aggregate and detailed view

        skillMapDataCache.countries.forEach(c => {
            // Zoomed OUT: Show Single Aggregated Marker
            if (zoom < thresholdZoom) {
                const marker = L.circleMarker(c.coords, {
                    radius: 6 + Math.log(c.totalCount || 1) * 3,
                    fillColor: c.topSkillColor, // Color of dominant skill
                    color: '#fff',
                    weight: 1,
                    opacity: 1,
                    fillOpacity: 0.8
                }).addTo(skillMapInstance);

                marker.bindPopup(`
                    <div style="text-align:center;">
                        <b>${c.name}</b><br>
                        Top Skill: <span style="color:${c.topSkillColor}; font-weight:bold;">${c.topSkillName}</span><br>
                        <i style="font-size:11px">Zoom in to see breakdown</i>
                    </div>
                `);
                skillMapMarkers.push(marker);
            } 
            // Zoomed IN: Show All Individual Skills (Jittered with Constraints)
            else {
                // Ensure randomness keeps dots somewhat within region context (simplified via jitter constraint)
                const isSmallState = c.name === 'Singapore'; // Explicit check for known small states
                const jitterRange = isSmallState ? 0.08 : 1.5; 

                c.skills.forEach((s, idx) => {
                    // Seeded random-like distribution so it stays consistent per render
                    const angle = (idx / c.skills.length) * 2 * Math.PI; 
                    const radius = (Math.random() * 0.5 + 0.5) * jitterRange; // Push out from center slightly
                    
                    const latOffset = Math.cos(angle) * radius * 0.5; // Flatten slightly for map projection
                    const lngOffset = Math.sin(angle) * radius;

                    const markerCoords = [c.coords[0] + latOffset, c.coords[1] + lngOffset];

                    const marker = L.circleMarker(markerCoords, {
                        radius: 6 + (s.count/skillMapDataCache.globalMax)*10, 
                        fillColor: s.color,
                        color: '#fff',
                        weight: 1,
                        opacity: 1,
                        fillOpacity: s.intensity
                    }).addTo(skillMapInstance);
                    
                    marker.bindPopup(`
                        <div style="text-align:center;">
                            <b>${c.name}</b><br>
                            Skill: <span style="color:${s.color}; font-weight:bold;">${s.skill}</span><br>
                            Frequency: ${s.count}
                        </div>
                    `);
                    skillMapMarkers.push(marker);
                });
            }
        });
    }

    // ================= DASHBOARD DATA LOGIC =================
    async function refreshDashboard() {
        const loader = document.getElementById('globalLoader');
        loader.classList.add('active');
        try {
            await fetchGlobalData();
            updateAllVisuals();
        } catch (e) {
            console.error("Dashboard Refresh Error", e);
        } finally {
            loader.classList.remove('active');
        }
    }

    async function fetchGlobalData() {
        const res = await fetch(`${API_BASE}/candidates`, {
            method: 'GET',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include' 
        });
        if (res.ok) {
            const data = await res.json();
            if (Array.isArray(data)) {
                globalData = data;
            }
        }
    }

    function updateAllVisuals() {
        // Only reset charts to defaults if they weren't restored by load state
        // The charts state restoration is handled by direct calls or localstorage checks
        // But here we need to be careful not to overwrite user selections if they are active
        
        // This function re-renders based on current select values
        // So we just trigger updates based on DOM state
        
        // Geo Chart
        const geoSelect = document.querySelector('select[onchange^="updateChartType(\'geoChart\'"]');
        if(geoSelect) updateChartType('geoChart', 'country', geoSelect.value);
        
        // Family Chart
        const familySelect = document.querySelector('select[onchange^="updateChartType(\'familyChart\'"]');
        if(familySelect) updateChartType('familyChart', 'jobfamily', familySelect.value);
        
        // Seniority Chart
        const senioritySelect = document.querySelector('select[onchange^="updateChartType(\'seniorityChart\'"]');
        if(senioritySelect) updateChartType('seniorityChart', 'seniority', senioritySelect.value);
        
        // Skill Chart
        const skillSelect = document.querySelector('select[onchange^="updateChartType(\'skillChart\'"]');
        if(skillSelect) {
             updateChartType('skillChart', 'skillset', skillSelect.value);
        } else {
             updateChartType('skillChart', 'skillset', 'map'); 
        }
        
        // Gap Chart
        const gapSelect = document.querySelector('select[onchange^="updateChartType(\'gapChart\'"]');
        if(gapSelect) updateChartType('gapChart', 'lskillset', gapSelect.value);
        
        // Product Chart
        const prodSelect = document.querySelector('select[onchange^="updateChartType(\'productChart\'"]');
        if(prodSelect) updateChartType('productChart', 'product', prodSelect.value);
        
        // Location Chart
        const locSelect = document.querySelector('select[onchange^="updateChartType(\'locationChart\'"]');
        if(locSelect) {
             updateChartType('locationChart', 'country', locSelect.value);
        } else {
             updateChartType('locationChart', 'country', 'map'); 
        }

        updateKPIS();
        updateTable();
        updateMap();
        buildOrgChart(); // Refresh org chart
    }

    function getFilteredData() {
        return globalData.filter(row => {
            return Object.entries(activeFilters).every(([field, filterVal]) => {
                const dataKey = FIELD_MAPPING[field] || field;
                const rowVal = String(row[dataKey] || '').toLowerCase();
                return rowVal.includes(filterVal.toLowerCase());
            });
        });
    }

    function aggregateData(dimension) {
        const data = getFilteredData();
        const counts = {};
        const dataKey = FIELD_MAPPING[dimension] || dimension;
        
        data.forEach(row => {
            let val = row[dataKey];
            // Updated: use jskillset
            if (['skillset', 'product', 'lskillset', 'jskillset'].includes(dataKey)) {
                if (val) {
                    // Remove [, ], " before splitting
                    String(val).replace(/[\[\]"]/g, '').split(/[,;]/).forEach(v => {
                        const t = v.trim();
                        if(t) counts[t] = (counts[t]||0) + 1;
                    });
                }
            } else {
                if (!val) val = 'Unknown';
                counts[val] = (counts[val]||0) + 1;
            }
        });

        const sorted = Object.entries(counts).sort((a,b) => b[1]-a[1]);
        return {
            labels: sorted.map(x => x[0]),
            values: sorted.map(x => x[1])
        };
    }

    // Interactive Chart Type Selector
    window.updateChartType = function(canvasId, dimension, newType) {
        // Special Handling for Map vs Chart in Skillset Section
        if(canvasId === 'skillChart') {
            const mapContainer = document.getElementById('skillMapContainer');
            const canvas = document.getElementById('skillChart');
            const legend = document.getElementById('skillMapLegend');
            
            if(newType === 'map') {
                if(canvas) canvas.style.display = 'none';
                if(mapContainer) {
                    mapContainer.style.display = 'block';
                    updateSkillMap(); // Refresh map data
                }
                if(legend) legend.style.display = 'block'; // Show legend
                return; 
            } else {
                if(mapContainer) mapContainer.style.display = 'none';
                if(legend) legend.style.display = 'none'; // Hide legend
                if(canvas) canvas.style.display = 'block';
                // Fall through to standard chart logic below
            }
        }
        
        // NEW: Special Handling for Map vs Chart in Location Section
        if (canvasId === 'locationChart') {
             const mapContainer = document.getElementById('mapContainer');
             const canvas = document.getElementById('locationChart');
             const legend = document.getElementById('geoMapLegend');
             
             if (newType === 'map') {
                 if (canvas) canvas.style.display = 'none';
                 if (mapContainer) {
                     mapContainer.style.display = 'block';
                     if(mapInstance) mapInstance.invalidateSize(); // Ensure map renders correctly after hiding
                 }
                 if (legend) legend.style.display = 'block';
                 return;
             } else {
                 if (mapContainer) mapContainer.style.display = 'none';
                 if (legend) legend.style.display = 'none';
                 if (canvas) canvas.style.display = 'block';
                 // Fall through to standard chart logic
             }
        }
        
        updateChart(canvasId, dimension, newType);
    }

    function updateChart(canvasId, dimension, type) {
        const agg = aggregateData(dimension);
        const labels = agg.labels.slice(0, 15);
        const values = agg.values.slice(0, 15);
        const ctx = document.getElementById(canvasId).getContext('2d');

        if (charts[canvasId]) charts[canvasId].destroy();

        // Theme-aware colors?
        const isCyber = document.body.classList.contains('theme-cyberpunk');
        const colors = [
            '#1a73e8', '#e37400', '#1e8e3e', '#d93025', '#9334e6', '#00acc1', '#f09300', '#188038',
            '#3c4043', '#7b1fa2', '#129eaf', '#c2185b'
        ];
        const gridColor = isCyber ? '#334155' : '#e5e7eb';
        const textColor = isCyber ? '#94a3b8' : '#64748b';

        // NEW: Radar and Polar Area Config
        const isRadial = type === 'radar' || type === 'polarArea' || type === 'pie' || type === 'doughnut';
        
        // Use MultiColor logic for diverse visuals
        const useMultiColor = isRadial || (dimension === 'skillset' && type !== 'line');
        
        const config = {
            type: type,
            data: {
                labels: labels,
                datasets: [{
                    label: 'Count',
                    data: values,
                    backgroundColor: useMultiColor ? colors : (isCyber ? '#0ea5e9' : '#1a73e8'),
                    borderColor: (useMultiColor && type !== 'line') ? colors : (isCyber ? '#0ea5e9' : '#1a73e8'),
                    borderWidth: type === 'line' ? 2 : 0,
                    fill: type === 'line' || type === 'radar' ? true : true, // fill radar
                    tension: 0.1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                indexAxis: dimension === 'skillset' && type === 'bar' ? 'y' : 'x', 
                plugins: {
                    legend: { 
                        display: isRadial, 
                        position: 'right',
                        labels: { boxWidth: 12, font: { family: isCyber?'Orbitron':'Inter' }, color: textColor }
                    }
                },
                layout: { padding: 10 },
                scales: {
                    // Scales not needed for pie/doughnut/polar, but might be for radar
                }
            }
        };

        // Adjust scales visibility
        if(type === 'pie' || type === 'doughnut' || type === 'polarArea') {
            delete config.options.scales;
            if(type === 'doughnut') config.options.cutout = '50%';
        } else if (type === 'radar') {
            config.options.scales = {
                r: {
                    grid: { color: gridColor },
                    pointLabels: { color: textColor },
                    ticks: { display: false }
                }
            };
            // Transparency for radar fill
            config.data.datasets[0].backgroundColor = isCyber ? 'rgba(14, 165, 233, 0.2)' : 'rgba(26, 115, 232, 0.2)';
        } else {
            // Bar/Line
            config.options.scales = {
                x: { ticks: { color: textColor }, grid: { color: gridColor } },
                y: { ticks: { color: textColor }, grid: { color: gridColor } }
            };
        }

        charts[canvasId] = new Chart(ctx, config);
    }

    function updateKPIS() {
        const filtered = getFilteredData();
        animateValue('kpiTotal', filtered.length);

        const seniorKeywords = ['Senior', 'Lead', 'Manager', 'Director', 'Head', 'VP', 'Chief', 'Expert', 'Executive'];
        const seniorCount = filtered.filter(r => {
            const s = String(r.seniority || '');
            return seniorKeywords.some(k => s.includes(k));
        }).length;
        animateValue('kpiSenior', seniorCount);

        // --- NEW: Skills Gap Logic ---
        // Counts unique missing skillsets based on lskill/lskillset
        const gapSet = new Set();
        filtered.forEach(r => {
            // Use lskill (missing skills) - mapped to lskillset in FIELD_MAPPING
            // We check both keys for robustness
            const val = r.lskill || r.lskillset; 
            if(val) {
                // Strip special chars before splitting
                String(val).replace(/[\[\]"]/g, '').split(/[,;]/).forEach(s => {
                    const clean = s.trim();
                    if(clean) gapSet.add(clean);
                });
            }
        });
        animateValue('kpiGap', gapSet.size);
        // -----------------------------

        let totalScore = 0;
        let ratedCount = 0;
        filtered.forEach(r => {
            if (r.rating) {
                const match = String(r.rating).match(/(\d+)%/);
                if (match) {
                    totalScore += parseInt(match[1]);
                    ratedCount++;
                }
            }
        });
        const avg = ratedCount > 0 ? Math.round(totalScore / ratedCount) : 0;
        document.getElementById('kpiRating').innerText = avg + '%';
    }

    function updateTable() {
        const filtered = getFilteredData();
        const tbody = document.querySelector('#dataTable tbody');
        tbody.innerHTML = '';

        filtered.slice(0, 50).forEach(row => {
            const tr = document.createElement('tr');
            let score = '-';
            if (row.rating) {
                const m = String(row.rating).match(/(\d+)%/);
                if(m) score = m[1] + '%';
            }
            const nameHtml = row.linkedinurl 
                ? `<a href="${row.linkedinurl}" target="_blank" style="text-decoration:none; color:var(--primary); font-weight:600;">${row.name || 'Profile'}</a>`
                : `<b>${row.name || '-'}</b>`;

            tr.innerHTML = `
                <td>${nameHtml}</td>
                <td>${row.jobtitle || '-'}</td>
                <td>${row.company || '-'}</td>
                <td>${row.country || '-'}</td>
                <td>${row.jobfamily || '-'}</td>
                <td><span style="color:${parseInt(score)>70?'green':'inherit'}">${score}</span></td>
                <td><span style="padding:2px 6px; border-radius:4px; background:var(--hover); color:var(--text-sub); font-size:11px;">${row.sourcingstatus || 'New'}</span></td>
            `;
            tbody.appendChild(tr);
        });
    }

    // NEW: Function for Port Button (Full Export with Username Key)
    function exportFullDataCSV() {
        // Use full current filtered data
        const data = getFilteredData();
        if (!data || !data.length) {
            alert("No data to export");
            return;
        }

        // Determine all unique keys from data for CSV header
        const allKeys = new Set();
        data.forEach(obj => Object.keys(obj).forEach(k => allKeys.add(k)));
        
        // Ensure username (or id) is first if present, otherwise sort
        const headers = Array.from(allKeys).sort();
        // Move username to front if exists
        const uIndex = headers.indexOf('username');
        if (uIndex > -1) {
            headers.splice(uIndex, 1);
            headers.unshift('username');
        }

        // CSV Construction
        const csvRows = [];
        // Header Row
        csvRows.push(headers.join(','));

        // Data Rows
        data.forEach(row => {
            const values = headers.map(header => {
                const val = row[header];
                let text = val === null || val === undefined ? '' : String(val);
                // Escape quotes and wrap in quotes to handle commas/newlines
                text = text.replace(/"/g, '""'); 
                return `"${text}"`;
            });
            csvRows.push(values.join(','));
        });

        const csvContent = csvRows.join("\n");
        const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", `process_export_${new Date().toISOString().slice(0,10)}.csv`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    // NEW: Function for Candidate Details Card (Scoped Export)
    function exportCandidateDetailsCSV() {
        const data = getFilteredData();
        if (!data || !data.length) {
            alert("No data to export");
            return;
        }

        // Specific fields + linkedinurl + email
        const headers = ['Name', 'Job Title', 'Company', 'Country', 'Job Family', 'Score', 'Status', 'LinkedIn URL', 'Email'];
        const keys = ['name', 'jobtitle', 'company', 'country', 'jobfamily', 'rating', 'sourcingstatus', 'linkedinurl', 'email'];

        const csvRows = [];
        csvRows.push(headers.join(','));

        data.forEach(row => {
            const values = keys.map(key => {
                let val = row[key];
                
                // UPDATED: Extract only percentage for score column
                if (key === 'rating' && val) {
                    const match = String(val).match(/(\d+%)/);
                    if (match) val = match[1];
                }

                let text = val === null || val === undefined ? '' : String(val);
                text = text.replace(/"/g, '""');
                return `"${text}"`;
            });
            csvRows.push(values.join(','));
        });

        const csvContent = csvRows.join("\n");
        const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", `candidate_details_${new Date().toISOString().slice(0,10)}.csv`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    // ================= NEW: Port to Looker Studio Function =================
    function handlePortToLooker() {
        // Direct to template tab first
        switchTab('templates');
        alert("Please select a Report Template to proceed with porting.");
        isPorting = true; // Set flag to indicate porting is in progress
    }

    // ================= ORG CHART LOGIC (Advanced Hierarchy) =================
    const LAYERS = ['Executive', 'Sr Director', 'Director', 'Sr Manager', 'Manager', 'Lead', 'Expert', 'Senior', 'Mid', 'Junior'];
    const ALLOWED_PARENTS = {
        'Junior': ['Lead','Manager','Sr Manager','Director','Sr Director'],
        'Mid': ['Lead','Manager','Sr Manager','Director','Sr Director'],
        'Senior': ['Lead','Manager','Sr Manager','Director','Sr Director'],
        'Expert': ['Lead','Manager','Sr Manager','Director','Sr Director'],
        'Lead': ['Manager','Sr Manager','Director','Sr Director','Lead'],
        'Manager': ['Director','Sr Director'],
        'Sr Manager': ['Director','Sr Director'],
        'Director': ['Sr Director','Executive'],
        'Sr Director': ['Executive'],
        'Executive': []
    };

    function normalizeTier(s) {
        if (!s) return 'Junior'; // Default fallback
        const v = String(s).trim().toLowerCase().replace(/\./g, '').replace(/\s+/g, ' ');
        if (/junior|jr/.test(v)) return 'Junior';
        if (/mid|middle|intermediate/.test(v)) return 'Mid';
        if (/senior|sr/.test(v)) return 'Senior';
        if (/lead/.test(v)) return 'Lead';
        if (/manager|mgr/.test(v)) return 'Manager';
        if (/expert|principal|staff/.test(v)) return 'Expert';
        if (/director|dir/.test(v)) return 'Director';
        if (/executive|exec|vp|chief/.test(v)) return 'Executive';
        return 'Junior'; // Fallback
    }

    function getRank(tier) {
        const t = normalizeTier(tier);
        const i = LAYERS.indexOf(t);
        return i === -1 ? LAYERS.length : i; // Lower index = higher rank
    }

    function buildOrgChart() {
        const container = document.getElementById('orgChartContent'); // Updated target
        const companyFilter = document.getElementById('orgChartCompanyFilter');
        
        let data = getFilteredData();
        
        // Populate Company Filter if it's the first run or data updated
        if (companyFilter.options.length <= 1) {
            const companies = new Set(data.map(d => d.company).filter(c => c));
            // Keep "All Companies"
            companyFilter.innerHTML = '<option value="">All Companies</option>';
            Array.from(companies).sort().forEach(c => {
                const opt = document.createElement('option');
                opt.value = c;
                opt.textContent = c;
                companyFilter.appendChild(opt);
            });
            
            // Restore saved filter strictly after population
            const savedFilter = localStorage.getItem('dashboard:orgFilter');
            if (savedFilter && Array.from(companyFilter.options).some(o => o.value === savedFilter)) {
                companyFilter.value = savedFilter;
            }
        }

        // Apply Specific Org Chart Filter
        const selectedCompany = companyFilter.value;
        if (selectedCompany) {
            data = data.filter(d => d.company === selectedCompany);
        }
        
        if (!data.length) {
            container.innerHTML = '<div style="padding:20px; color:var(--text-sub);">No data to display hierarchy.</div>';
            return;
        }

        // 1. Group by Organization -> Job Family
        const grouped = {};
        data.forEach(p => {
            const org = p.company || 'Unknown Org';
            const fam = p.jobfamily || 'General';
            if (!grouped[org]) grouped[org] = {};
            if (!grouped[org][fam]) grouped[org][fam] = [];
            
            // Enrich with rank/tier
            const tier = normalizeTier(p.seniority || '');
            grouped[org][fam].push({ 
                ...p, 
                normalizedTier: tier,
                rank: getRank(tier)
            });
        });

        let fullHtml = '';

        // 2. Build Trees for each group
        Object.keys(grouped).sort().forEach(org => {
            Object.keys(grouped[org]).sort().forEach(fam => {
                const nodes = grouped[org][fam];
                // Sort by Rank ASC (Executive 0 -> Junior 9)
                nodes.sort((a,b) => a.rank - b.rank || (a.name||'').localeCompare(b.name||''));

                // Tree Building Algorithm (Heuristic)  preserves your prior reporting logic
                const byId = new Map(nodes.map(n => [n.id, n]));
                const childrenMap = new Map(nodes.map(n => [n.id, []]));
                const roots = [];

                nodes.forEach(child => {
                    const allowed = ALLOWED_PARENTS[child.normalizedTier] || [];
                    let bestParent = null;

                    const candidates = nodes.filter(p => 
                        p.id !== child.id && 
                        p.rank < child.rank &&
                        allowed.includes(p.normalizedTier)
                    );

                    if (candidates.length > 0) {
                        candidates.sort((a,b) => {
                            if (a.rank !== b.rank) return b.rank - a.rank; // closer rank preferred
                            const aLoc = (a.country === child.country);
                            const bLoc = (b.country === child.country);
                            if (aLoc && !bLoc) return -1;
                            if (!aLoc && bLoc) return 1;
                            return 0;
                        });
                        bestParent = candidates[0];
                    }

                    if (bestParent) {
                        childrenMap.get(bestParent.id).push(child);
                    } else {
                        roots.push(child);
                    }
                });

                function renderNode(node) {
                    const kids = childrenMap.get(node.id) || [];
                    const badgeClass = `badge-${node.normalizedTier.toLowerCase().split(' ')[0]}`;
                    let html = `
                        <li>
                            <div class="org-node">
                                <div class="org-node-header">
                                    <div class="org-name">${node.name || 'Unknown'}</div>
                                    <span class="org-badge ${badgeClass}">${node.seniority || ''}</span>
                                </div>
                                <div class="org-title">${node.jobtitle || 'Role'}</div>
                                <div class="org-meta">${node.country || ''}</div>
                            </div>
                    `;
                    if (kids.length > 0) {
                        html += `<ul>${kids.map(k => renderNode(k)).join('')}</ul>`;
                    }
                    html += `</li>`;
                    return html;
                }

                const nodesHtml = roots.map(r => renderNode(r)).join('');

                fullHtml += `
                    <div class="org-group-container">
                        <div class="org-group-title">${org} - ${fam}</div>
                        <div class="org-tree">
                            <ul>
                                <li>
                                    <div class="org-node" style="border:2px solid var(--text-main); background:var(--hover);">
                                        <!-- Removed "Department" word as requested -->
                                        <div class="org-name" style="font-size:14px;">${fam}</div>
                                    </div>
                                    <ul>
                                        ${nodesHtml}
                                    </ul>
                                </li>
                            </ul>
                        </div>
                    </div>
                `;
            });
        });

        container.innerHTML = fullHtml;
    }

    // ================= NEW: Resizable + Draggable tiles ============
    const DASHBOARD_ORDER_KEY = 'dashboard:order';
    const DASHBOARD_SIZE_KEY  = 'dashboard:sizes';

    // Helper: derive a stable deterministic id for standard cards
    function deriveStableTileId(card) {
        // 1) Canvas-based charts (canvas id exists and is unique)
        const canvas = card.querySelector('canvas[id]');
        if (canvas && canvas.id) return canvas.id;

        // 2) Map or special containers by id
        if (card.querySelector('#mapContainer')) return 'map-card';
        if (card.querySelector('#skillMapContainer')) return 'skill-map-card';
        if (card.querySelector('#orgChartContent')) return 'org-chart-card';
        if (card.querySelector('#dataTable')) return 'data-grid-card';

        // 3) Known KPI elements (metrics)
        if (card.querySelector('#kpiTotal')) return 'kpi-total';
        if (card.querySelector('#kpiSenior')) return 'kpi-senior';
        if (card.querySelector('#kpiGap')) return 'kpi-gap';
        if (card.querySelector('#kpiRating')) return 'kpi-rating';

        // 4) Fallback: use header title (normalize)
        const h = card.querySelector('h3, h2, h1');
        if (h && h.innerText) {
            const normalized = h.innerText.trim().toLowerCase()
                .replace(/\s+/g, '-')
                .replace(/[^a-z0-9\-]/g, '')
                .slice(0, 40);
            if (normalized) return `card-${normalized}`;
        }

        // 5) Last resort: unique custom id (only for truly dynamic/new tiles)
        return `tile-custom-${Date.now()}-${Math.floor(Math.random() * 100000)}`;
    }

    // Utility: try multiple strategies to find an element matching a saved id
    function findElementForSavedId(savedId, grid) {
        if (!savedId) return null;
        // 1) Direct dataset match
        let el = grid.querySelector(`[data-tile-id="${savedId}"]`);
        if (el) return el;
        // 2) Element with that id (common for canvases)
        el = document.getElementById(savedId);
        if (el) return el.closest('.card') || el;
        // 3) Match by canvas id inside card
        const canvas = grid.querySelector(`canvas#${savedId}`);
        if (canvas) return canvas.closest('.card');
        // 4) Try to find by derived stable id: compare deriveStableTileId for each card
        const cards = grid.querySelectorAll('.card');
        for (const c of cards) {
            try {
                const derived = deriveStableTileId(c);
                if (derived === savedId) return c;
            } catch (e) { /* ignore */ }
        }
        // 5) As last fallback, try to match by header normalized key
        for (const c of cards) {
            const h = c.querySelector('h3, h2, h1');
            if (h && h.innerText) {
                const normalized = h.innerText.trim().toLowerCase()
                    .replace(/\s+/g, '-')
                    .replace(/[^a-z0-9\-]/g, '')
                    .slice(0, 40);
                if (`card-${normalized}` === savedId) return c;
            }
        }
        return null;
    }

    function enableTileInteractivity(specificCard = null) {
        const grid = document.getElementById('dashboardGrid');
        let cards = [];
        if (specificCard) {
            cards = [specificCard];
        } else {
            cards = grid.querySelectorAll('.card');
        }

        let idx = document.querySelectorAll('.card').length + 1;
        cards.forEach(card => {
            if (card.dataset.interactive === '1') return;
            card.dataset.interactive = '1';

            // assign a stable id - prefer existing DOM ids (canvas, map, table, KPIs), fallback to persistent id
            const stableId = deriveStableTileId(card);
            // keep existing id if already set (user-created/previously-assigned)
            if (!card.dataset.tileId) {
                card.dataset.tileId = stableId;
            }

            // base span by class
            let baseSpan = 12;
            if (card.classList.contains('metric-card')) baseSpan = 3;
            else if (card.classList.contains('chart-card')) baseSpan = card.classList.contains('full-width') ? 12 : 6;
            else if (card.classList.contains('map-card')) baseSpan = 12;
            else if (card.classList.contains('org-chart-card')) baseSpan = 12;
            else if (card.classList.contains('data-grid-card')) baseSpan = 12;
            else if (card.classList.contains('empty-tile') || card.classList.contains('custom-metric-tile')) baseSpan = 12; 

            card.dataset.baseSpan = String(baseSpan);
            if (!card.dataset.span) card.dataset.span = String(baseSpan);

            // base height (approximate)
            let baseHeight = card.offsetHeight || 150;
            if (card.classList.contains('chart-card')) baseHeight = 450;
            if (card.classList.contains('map-card')) baseHeight = 500;
            if (card.classList.contains('org-chart-card')) baseHeight = 500;
            if (card.classList.contains('empty-tile')) baseHeight = 200;
            if (card.classList.contains('custom-metric-tile')) baseHeight = 200;
            card.dataset.baseHeight = String(baseHeight);

            // controls
            const controls = document.createElement('div');
            controls.className = 'tile-controls';
            controls.innerHTML = `
                <button data-scale="1" title="1x (Original Size)">1x</button>
                <button data-scale="2" title="2x (Half Size)">2x</button>
                <button data-scale="4" title="4x (Quarter Size)">4x</button>
                <button data-scale="8" title="8x (Compact Size)">8x</button>
                <button onclick="this.closest('.card').remove(); persistOrder(); persistSizes();" style="color:red;" title="Remove Tile">X</button>
            `;

            controls.querySelectorAll('button[data-scale]').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const scale = parseFloat(btn.dataset.scale);
                    resizeCard(card, scale);
                    persistSizes();
                    // mark active
                    controls.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                });
            });
            card.appendChild(controls);

            // draggable
            makeDraggable(card);

            // NEW: Add drop zone logic for custom/empty tiles
            if (card.classList.contains('empty-tile') || card.classList.contains('custom-metric-tile')) {
                setupDropZone(card);
            }
        });
        
        // If specific card, might need immediate sizing
        if(specificCard) {
             resizeCard(specificCard, 1);
        } else {
             applySavedSizes();
        }
    }

    // NEW: Add Empty Tile Function
    function addEmptyTile() {
        const grid = document.getElementById('dashboardGrid');
        const tile = document.createElement('div');
        tile.className = 'card empty-tile';
        // Immediately give a deterministic custom id (to persist & restore correctly)
        tile.dataset.tileId = `tile-custom-${Date.now()}-${Math.floor(Math.random()*10000)}`;
        tile.innerHTML = `
            <h3>Empty Tile</h3>
            <div class="empty-tile-content">Free Space</div>
        `;
        // Append to top or bottom? Let's append to bottom by default
        grid.appendChild(tile);
        enableTileInteractivity(tile);
        persistOrder();
        persistSizes();
    }

    function setupDropZone(tile) {
        tile.addEventListener('dragover', (e) => {
            // Check if dragging a filter field
            if (e.dataTransfer.types.includes('application/x-filter-field')) {
                e.preventDefault();
                tile.classList.add('drag-over');
            }
        });

        tile.addEventListener('dragleave', () => {
            tile.classList.remove('drag-over');
        });

        tile.addEventListener('drop', (e) => {
            e.preventDefault();
            tile.classList.remove('drag-over');
            const field = e.dataTransfer.getData('application/x-filter-field');
            if (field) {
                // If it's already a custom metric tile (has one field), we are adding a second one
                // This triggers chart creation
                if(tile.dataset.fields) {
                    const fields = JSON.parse(tile.dataset.fields);
                    if(!fields.includes(field)) {
                        fields.push(field);
                        transformToChartTile(tile, fields);
                    }
                } else {
                    // First field -> Metric Tile
                    transformToMetricTile(tile, field);
                }
            }
        });
    }

    function transformToMetricTile(tile, field, restoredTitle=null, restoredValue=null, restoredLabel=null) {
        const agg = aggregateData(field);
        const uniqueCount = agg.labels.length;
        
        tile.classList.remove('empty-tile');
        tile.classList.remove('chart-card'); // In case downgrading? Unlikely but safe
        tile.classList.add('metric-card');
        tile.classList.add('custom-metric-tile');
        
        // Store fields metadata
        tile.dataset.fields = JSON.stringify([field]);
        tile.dataset.chartType = 'metric'; // explicit type

        const title = restoredTitle || formatLabel(field);
        const value = restoredValue || uniqueCount;
        const label = restoredLabel || `Unique values for ${field}`;

        tile.innerHTML = `
            <h3 contenteditable="true" spellcheck="false">${title}</h3>
            <div class="metric-value" contenteditable="true" spellcheck="false">${value}</div>
            <div class="metric-label" contenteditable="true" spellcheck="false">${label}</div>
            <div class="active-tags"><span class="active-tag">${field}</span></div>
        `;
        
        addTileControls(tile);
        persistOrder();
    }

    function transformToChartTile(tile, fields, restoredType='bar') {
        tile.classList.remove('metric-card');
        tile.classList.remove('empty-tile');
        tile.classList.add('chart-card');
        tile.classList.add('custom-metric-tile');
        
        tile.dataset.fields = JSON.stringify(fields);
        // Default to bar chart if not specified
        const chartType = restoredType; 
        tile.dataset.chartType = chartType;

        // Use the last added field as the dimension for aggregation, or primary?
        // Let's use the LAST added field as the dimension to chart.
        const dimension = fields[fields.length - 1]; 
        const canvasId = `chart-${tile.dataset.tileId}`;

        // NEW: More Chart Options in Select
        tile.innerHTML = `
            <div class="card-header">
                <h3>${formatLabel(dimension)} Analysis</h3>
                <select class="chart-type-select" onchange="updateCustomChart('${canvasId}', '${dimension}', this.value, this.closest('.card'))">
                    <option value="bar" ${chartType=='bar'?'selected':''}>Bar</option>
                    <option value="pie" ${chartType=='pie'?'selected':''}>Pie</option>
                    <option value="line" ${chartType=='line'?'selected':''}>Line</option>
                    <option value="doughnut" ${chartType=='doughnut'?'selected':''}>Doughnut</option>
                    <option value="polarArea" ${chartType=='polarArea'?'selected':''}>Polar Area</option>
                    <option value="radar" ${chartType=='radar'?'selected':''}>Radar</option>
                </select>
            </div>
            <div class="chart-container">
                <canvas id="${canvasId}"></canvas>
            </div>
            <div class="active-tags">
                ${fields.map(f => `<span class="active-tag">${f}</span>`).join('')}
            </div>
        `;
        
        addTileControls(tile);
        persistOrder();
        
        setTimeout(() => {
            updateChart(canvasId, dimension, chartType);
        }, 0);
    }

    // Helper for custom chart updates that also saves state
    window.updateCustomChart = function(canvasId, dimension, type, card) {
        updateChart(canvasId, dimension, type);
        card.dataset.chartType = type;
        persistOrder();
    }

    function addTileControls(tile) {
        const controls = document.createElement('div');
        controls.className = 'tile-controls';
        controls.innerHTML = `
            <button data-scale="1" title="1x">1x</button>
            <button data-scale="2" title="2x">2x</button>
            <button data-scale="4" title="4x">4x</button>
            <button data-scale="8" title="8x">8x</button>
            <button onclick="this.closest('.card').remove(); persistOrder(); persistSizes();" style="color:red;" title="Remove">X</button>
        `;
        controls.querySelectorAll('button[data-scale]').forEach(btn => {
            btn.addEventListener('click', (ev) => {
                ev.stopPropagation();
                resizeCard(tile, parseFloat(btn.dataset.scale));
                persistSizes();
            });
        });
        tile.appendChild(controls);
    }

    function resizeCard(card, scaleFactor) {
        // scaleFactor: 1 = original, 2 = half size, 4 = quarter size, 8 = 1/8 size
        const baseSpan = parseInt(card.dataset.baseSpan || '12', 10);
        const baseHeight = parseInt(card.dataset.baseHeight || '400', 10);

        let span, height;

        if (scaleFactor === 1) {
            span = baseSpan;
            height = baseHeight;
        } else if (scaleFactor === 2) {
            span = Math.max(2, Math.round(baseSpan / 2));
            height = Math.max(200, Math.round(baseHeight * 0.75));
        } else if (scaleFactor === 4) {
            span = Math.max(2, Math.round(baseSpan / 4));
            height = Math.max(150, Math.round(baseHeight * 0.5));
        } else if (scaleFactor === 8) {
            span = Math.max(1, Math.round(baseSpan / 6)); 
            height = Math.max(120, Math.round(baseHeight * 0.4));
        } else {
            span = baseSpan;
            height = baseHeight;
        }

        // Apply
        card.dataset.span = String(span);
        card.dataset.scale = String(scaleFactor); // Store scale for content scaling

        // Only set explicit height for visual sections; tables/metrics can stay auto
        if (
            card.classList.contains('chart-card') ||
            card.classList.contains('map-card') ||
            card.classList.contains('org-chart-card') ||
            card.classList.contains('empty-tile') ||
            (card.classList.contains('custom-metric-tile') && card.classList.contains('chart-card'))
        ) {
            card.style.height = height + 'px';
            const canvas = card.querySelector('canvas');
            // Let Chart.js recompute sizes if present
            if (canvas && charts[canvas.id]) {
                try { charts[canvas.id].resize(); } catch {}
            }
            if (card.classList.contains('org-chart-card')) {
                applyOrgChartScaling(card, scaleFactor);
            }
        } 
        
        // Metric cards are flex, so height is min-height usually
        if (card.classList.contains('metric-card') && !card.classList.contains('chart-card')) {
            card.style.minHeight = (height * 0.5) + 'px';
        }
    }

    function applyOrgChartScaling(card, scaleFactor) {
        const content = card.querySelector('#orgChartContent');
        if (!content) return;
        
        let transformScale = 1;
        if (scaleFactor === 1) transformScale = 1;
        else if (scaleFactor === 2) transformScale = 0.85;
        else if (scaleFactor === 4) transformScale = 0.65;
        else if (scaleFactor === 8) transformScale = 0.45;

        content.style.transform = `scale(${transformScale})`;
        content.style.marginBottom = scaleFactor > 1 ? `-${(1-transformScale)*100}px` : '0';
        content.style.marginRight = scaleFactor > 1 ? `-${(1-transformScale)*100}px` : '0';
    }

    function makeDraggable(card) {
        const grid = document.getElementById('dashboardGrid');
        let placeholder = null;
        card.setAttribute('draggable', 'true');

        card.addEventListener('dragstart', (e) => {
            // Only allow dragging if draggable is true (checked by browser, but double check)
            if (card.getAttribute('draggable') === 'false') {
                 e.preventDefault();
                 return false;
            }

            // Fallback: Check targets again just in case attribute toggle missed edge case
            if (e.target.closest('#mapContainer') || e.target.closest('.leaflet-container') || e.target.closest('#skillMapContainer')) {
                e.preventDefault();
                return false;
            }

            // Also block drag if source was interactive form elements OR editable text
            if (e.target.tagName === 'SELECT' || e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' || e.target.isContentEditable) {
                e.preventDefault();
                return;
            }

            card.classList.add('dragging');
            placeholder = document.createElement('div');
            placeholder.className = 'card card-placeholder';
            placeholder.dataset.span = card.dataset.span || card.dataset.baseSpan || '12';
            // size placeholder similar height
            placeholder.style.height = card.offsetHeight + 'px';
            card.after(placeholder);
            e.dataTransfer.effectAllowed = 'move';
        });

        card.addEventListener('dragend', () => {
            card.classList.remove('dragging');
            if (placeholder) {
                placeholder.replaceWith(card);
                placeholder = null;
            }
            persistOrder();
        });

        grid.addEventListener('dragover', (e) => {
            if (!placeholder) return;
            e.preventDefault();
            const target = e.target.closest('.card');
            if (!target || target === placeholder || target === card) return;
            const rect = target.getBoundingClientRect();
            const before = e.clientY < rect.top + rect.height / 2;
            if (before) target.before(placeholder);
            else target.after(placeholder);
        });

        grid.addEventListener('drop', (e) => {
            // Prevent drop if it's the filter bubble being dropped
            if (e.dataTransfer.types.includes('application/x-filter-field')) return;

            if (!placeholder) return;
            e.preventDefault();
            placeholder.replaceWith(card);
            placeholder = null;
            persistOrder();
        });
    }

    // ================= LAYOUT PERSISTENCE & RESET =================
    function persistOrder() {
        const order = Array.from(document.querySelectorAll('#dashboardGrid .card'))
            .map(el => {
                // For empty tiles that might not have ID yet if newly added and not saved
                if(!el.dataset.tileId) el.dataset.tileId = `tile-custom-${Date.now()}-${Math.random()}`;
                
                let type = 'standard';
                let data = {};
                
                if(el.classList.contains('empty-tile')) {
                    type = 'empty';
                } else if(el.classList.contains('custom-metric-tile')) {
                    // Check if it's a chart or simple metric
                    if(el.classList.contains('chart-card')) {
                        type = 'custom-chart';
                        data.fields = JSON.parse(el.dataset.fields || '[]');
                        data.chartType = el.dataset.chartType || 'bar';
                    } else {
                        type = 'custom-metric';
                        data.title = el.querySelector('h3').innerText;
                        data.value = el.querySelector('.metric-value').innerText;
                        data.label = el.querySelector('.metric-label').innerText;
                        data.fields = JSON.parse(el.dataset.fields || '[]');
                    }
                } else {
                    // It's a standard card, capture its type if it has a specific chart
                    // This is handled by saving 'standardChartConfig' separately in persistConfig below
                    // or we can attach it here.
                }
                
                return {
                    id: el.dataset.tileId,
                    type: type,
                    data: data
                };
            });
        localStorage.setItem(DASHBOARD_ORDER_KEY, JSON.stringify(order));
        persistConfig(); // Also save chart configs whenever order is saved
    }
    
    function persistConfig() {
        // Save current chart types for standard charts
        const config = {
            theme: document.getElementById('themeSelector').value,
            charts: {}
        };
        
        // Grab all standard select values
        const selects = document.querySelectorAll('select.chart-type-select[id^="chartType-"]');
        selects.forEach(sel => {
            config.charts[sel.id] = sel.value;
        });
        
        localStorage.setItem('dashboard:config', JSON.stringify(config));
    }

    function restoreSavedLayout() {
        const orderRaw = localStorage.getItem(DASHBOARD_ORDER_KEY);
        if (!orderRaw) return;
        let order = [];
        try { order = JSON.parse(orderRaw); } catch {}
        if (!Array.isArray(order) || !order.length) return;

        const grid = document.getElementById('dashboardGrid');
        const mapById = new Map();
        
        // Index existing DOM elements
        Array.from(grid.children).forEach(el => {
            if (el.classList && el.classList.contains('card')) {
                // Ensure interactive ids are set so we can match standard cards
                if (!el.dataset.tileId) {
                    el.dataset.tileId = deriveStableTileId(el);
                }
                mapById.set(el.dataset.tileId, el);
            }
        });

        // Reconstruct grid
        const fragment = document.createDocumentFragment();
        
        order.forEach(item => {
            let id = typeof item === 'object' ? item.id : item; // Handle legacy format
            let type = typeof item === 'object' ? item.type : 'standard';
            let data = typeof item === 'object' ? item.data : {};

            let el = mapById.get(id);

            // If not found, try smart lookup
            if (!el) el = findElementForSavedId(id, grid);
            
            if (el && type === 'standard') {
                fragment.appendChild(el);
            } else if (type === 'empty') {
                // Recreate empty tile
                const tile = document.createElement('div');
                tile.className = 'card empty-tile';
                tile.dataset.tileId = id; 
                tile.innerHTML = `<h3>Empty Tile</h3><div class="empty-tile-content">Free Space</div>`;
                fragment.appendChild(tile);
                enableTileInteractivity(tile); 
            } else if (type === 'custom-metric') {
                // Recreate custom metric tile
                const tile = document.createElement('div');
                tile.className = 'card metric-card custom-metric-tile';
                tile.dataset.tileId = id;
                tile.dataset.fields = JSON.stringify(data.fields || []);
                tile.innerHTML = `
                    <h3 contenteditable="true" spellcheck="false">${data.title || 'Metric'}</h3>
                    <div class="metric-value" contenteditable="true" spellcheck="false">${data.value || '0'}</div>
                    <div class="metric-label" contenteditable="true" spellcheck="false">${data.label || '-'}</div>
                    <div class="active-tags">
                        ${(data.fields||[]).map(f => `<span class="active-tag">${f}</span>`).join('')}
                    </div>
                `;
                addTileControls(tile);
                fragment.appendChild(tile);
                makeDraggable(tile);
                setupDropZone(tile); // Important: Re-enable drop zone for upgrade to chart
            } else if (type === 'custom-chart') {
                // Recreate custom chart tile
                const tile = document.createElement('div');
                tile.className = 'card chart-card custom-metric-tile';
                tile.dataset.tileId = id;
                tile.dataset.fields = JSON.stringify(data.fields || []);
                tile.dataset.chartType = data.chartType || 'bar';
                
                const dimension = (data.fields && data.fields.length > 0) ? data.fields[data.fields.length-1] : 'Unknown';
                const canvasId = `chart-${id}`;
                
                // NEW: More Chart Options in Select
                tile.innerHTML = `
                    <div class="card-header">
                        <h3>${formatLabel(dimension)} Analysis</h3>
                        <select class="chart-type-select" onchange="updateCustomChart('${canvasId}', '${dimension}', this.value, this.closest('.card'))">
                            <option value="bar" ${data.chartType=='bar'?'selected':''}>Bar</option>
                            <option value="pie" ${data.chartType=='pie'?'selected':''}>Pie</option>
                            <option value="line" ${data.chartType=='line'?'selected':''}>Line</option>
                            <option value="doughnut" ${data.chartType=='doughnut'?'selected':''}>Doughnut</option>
                            <option value="polarArea" ${data.chartType=='polarArea'?'selected':''}>Polar Area</option>
                            <option value="radar" ${data.chartType=='radar'?'selected':''}>Radar</option>
                        </select>
                    </div>
                    <div class="chart-container">
                        <canvas id="${canvasId}"></canvas>
                    </div>
                    <div class="active-tags">
                        ${(data.fields||[]).map(f => `<span class="active-tag">${f}</span>`).join('')}
                    </div>
                `;
                
                addTileControls(tile);
                fragment.appendChild(tile);
                makeDraggable(tile);
                setupDropZone(tile); 
                
                setTimeout(() => {
                    updateChart(canvasId, dimension, data.chartType);
                }, 0);
            }
        });
        
        // Append any remaining standard cards that weren't in saved order
        mapById.forEach((el, id) => {
             if(!fragment.contains(el) && !el.classList.contains('empty-tile') && !el.classList.contains('custom-metric-tile')) {
                 fragment.appendChild(el);
             }
        });

        grid.appendChild(fragment);
    }

    function persistSizes() {
        const sizes = {};
        document.querySelectorAll('#dashboardGrid .card').forEach(el => {
            if(el.dataset.tileId) {
                sizes[el.dataset.tileId] = {
                    span: el.dataset.span,
                    height: el.style.height || '',
                    minHeight: el.style.minHeight || '',
                    scale: el.dataset.scale || '1'
                };
            }
        });
        localStorage.setItem(DASHBOARD_SIZE_KEY, JSON.stringify(sizes));
    }

    function applySavedSizes() {
        const raw = localStorage.getItem(DASHBOARD_SIZE_KEY);
        if (!raw) return;
        let sizes = {};
        try { sizes = JSON.parse(raw); } catch {}
        if (!sizes || typeof sizes !== 'object') return;

        document.querySelectorAll('#dashboardGrid .card').forEach(el => {
            const s = sizes[el.dataset.tileId];
            if (!s) return;
            if (s.span) el.dataset.span = s.span;
            if (s.height) el.style.height = s.height;
            if (s.minHeight) el.style.minHeight = s.minHeight;
            if (s.scale) {
                el.dataset.scale = s.scale;
                const btn = el.querySelector(`.tile-controls button[data-scale="${s.scale}"]`);
                if(btn) {
                    el.querySelectorAll('.tile-controls button').forEach(b=>b.classList.remove('active'));
                    btn.classList.add('active');
                }
                if(el.classList.contains('org-chart-card')) {
                    applyOrgChartScaling(el, parseFloat(s.scale));
                }
            }
        });
    }
    
    function saveDashboardState() {
        persistOrder();
        persistSizes();
        persistConfig(); // Explicit call to save chart/theme config
        localStorage.setItem('dashboard:filters', JSON.stringify(activeFilters));

        if (mapInstance) {
            const center = mapInstance.getCenter();
            const zoom = mapInstance.getZoom();
            localStorage.setItem('dashboard:map', JSON.stringify({ center: [center.lat, center.lng], zoom }));
        }

        const orgFilter = document.getElementById('orgChartCompanyFilter');
        if(orgFilter) {
            localStorage.setItem('dashboard:orgFilter', orgFilter.value);
        }

        alert('Dashboard state saved successfully!');
    }

    // NEW: Load Dashboard State Function
    function loadDashboardState(autoLoad=false) {
        if(!autoLoad && !confirm('This will reload the dashboard from the last saved state. Unsaved changes will be lost. Continue?')) return;
        
        // Restore Layout and Sizes
        restoreSavedLayout();
        applySavedSizes();
        
        // Restore Filters
        restoreFilters();
        
        // Restore Theme and Chart Configs
        try {
            const configRaw = localStorage.getItem('dashboard:config');
            if(configRaw) {
                const config = JSON.parse(configRaw);
                // Restore Theme
                if(config.theme) changeTheme(config.theme);
                // Restore Chart Types
                if(config.charts) {
                    Object.entries(config.charts).forEach(([id, val]) => {
                        const sel = document.getElementById(id);
                        if(sel) sel.value = val;
                    });
                }
            }
        } catch(e) { console.error('Error restoring config', e); }
        
        // Restore Org Chart Filter
        const savedOrgFilter = localStorage.getItem('dashboard:orgFilter');
        if (savedOrgFilter) {
            const orgFilter = document.getElementById('orgChartCompanyFilter');
            if(orgFilter) {
                orgFilter.value = savedOrgFilter;
                buildOrgChart(); // Rebuild chart
            }
        }

        // Restore Map
        const savedMap = localStorage.getItem('dashboard:map');
        if (savedMap && mapInstance) {
            try {
                const p = JSON.parse(savedMap);
                mapInstance.setView(p.center, p.zoom);
            } catch(e) {}
        }
        
        updateAllVisuals();
    }

    function restoreFilters() {
        const saved = localStorage.getItem('dashboard:filters');
        if (saved) {
            try {
                const filters = JSON.parse(saved);
                // Reset active filters
                for (const key in activeFilters) delete activeFilters[key];
                // Apply saved
                Object.assign(activeFilters, filters);
                
                // Update UI buttons
                document.querySelectorAll('.filter-btn').forEach(btn => {
                    btn.classList.remove('active');
                    btn.innerHTML = `<span>${formatLabel(btn.dataset.field)}</span> <span></span>`;
                });
                Object.entries(filters).forEach(([field, val]) => {
                     updateFilterButtonState(field, val);
                });
            } catch (e) { console.error("Error restoring filters", e); }
        }
    }

    function resetDashboardLayout() {
        if(confirm('Reset dashboard to default layout?')) {
            localStorage.removeItem(DASHBOARD_ORDER_KEY);
            localStorage.removeItem(DASHBOARD_SIZE_KEY);
            localStorage.removeItem('dashboard:filters');
            localStorage.removeItem('dashboard:map');
            localStorage.removeItem('dashboard:orgFilter');
            localStorage.removeItem('dashboard:config');
            location.reload();
        }
    }

    // ================= UTILS =================
    function formatLabel(str) {
        return str.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
    }

    function animateValue(id, end) {
        const obj = document.getElementById(id);
        const start = 0; const duration = 500;
        let startTimestamp = null;
        const step = (timestamp) => {
            if (!startTimestamp) startTimestamp = timestamp;
            const progress = Math.min((timestamp - startTimestamp) / duration, 1);
            obj.innerHTML = Math.floor(progress * (end - start) + start);
            if (progress < 1) window.requestAnimationFrame(step);
        };
        window.requestAnimationFrame(step);
    }
</script>

</body>
</html>