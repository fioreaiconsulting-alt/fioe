<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Sourcing Verify</title>
<meta name="viewport" content="width=device-width,initial-scale=1">

<!-- Orbitron (cyberpunk-style) as a close substitute for "Cyberpunk 2077" typography -->
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="sourcing_verify.css">

<style>
/* Professional iOS-style toggle switch for L1/L2 mode */
.toggle-switch .toggle-slider:before {
  content: "";
  position: absolute;
  height: 18px;
  width: 18px;
  left: 3px;
  bottom: 3px;
  background-color: white;
  border-radius: 50%;
  transition: 0.3s;
  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}

.toggle-switch input:checked + .toggle-slider {
  background-color: #10b981 !important; /* Green for L2 active */
}

.toggle-switch input:checked + .toggle-slider:before {
  transform: translateX(26px);
}

.toggle-switch .toggle-slider:hover {
  opacity: 0.9;
}

/* small style for assessment badge updated by JS */
.assessment-badge { font-weight:600; color:#064e3b; }
.assessment-placeholder { color:#9ca3af; }

/* Extend toolbar width for better readability */
#toolbar {
  min-width: 100%;
  width: auto;
}

/* Bubble tags for role tags display */
.role-bubble {
  display: inline-block;
  padding: 4px 12px;
  margin: 2px 4px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border-radius: 16px;
  font-size: 12px;
  font-weight: 600;
  box-shadow: 0 2px 4px rgba(102, 126, 234, 0.3);
  transition: transform 0.2s ease;
}

.role-bubble:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(102, 126, 234, 0.4);
}
</style>

<!-- Leaflet for country map visualization in Deep Research -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

<!-- VSkillset Integration -->
<script src="vskillset.js"></script>

</head>
<body>
<h1>Talent Evaluation Panel</h1>

<!-- Tab Navigation -->
<div class="tabs-nav">
  <button class="tab-btn active" onclick="switchTab('tab-search')">Search Results</button>
  <button class="tab-btn" onclick="switchTab('tab-details')" id="tab-details-btn">View Details</button>
  <button class="tab-btn" onclick="switchTab('tab-research')" id="tab-research-btn">Deep Research</button>
</div>

<!-- Tab 1: Search Results -->
<div id="tab-search" class="tab-pane active">

  <!-- New Weightage Configuration Panel -->
  <div class="weight-config-panel" id="weightConfigPanel">
    <div class="weight-config-header" id="weightConfigHeader">
      <span>Assessment Weightage Configuration</span>
      <span id="weightConfigArrow">â–¼</span>
    </div>
    <div class="weight-config-content" id="weightConfigContent">
      <div class="weight-sliders">
        <div class="weight-slider-group">
          <label>Job Title <span id="val-jobtitle_role_tag">35%</span></label>
          <input type="range" min="0" max="100" value="35" data-key="jobtitle_role_tag" oninput="updateWeightVal(this)">
        </div>
        <div class="weight-slider-group">
          <label>Skillset <span id="val-skillset">20%</span></label>
          <input type="range" min="0" max="100" value="20" data-key="skillset" oninput="updateWeightVal(this)">
        </div>
        <div class="weight-slider-group">
          <label>Seniority <span id="val-seniority">10%</span></label>
          <input type="range" min="0" max="100" value="10" data-key="seniority" oninput="updateWeightVal(this)">
        </div>
        <div class="weight-slider-group">
          <label>Company <span id="val-company">10%</span></label>
          <input type="range" min="0" max="100" value="10" data-key="company" oninput="updateWeightVal(this)">
        </div>
        <div class="weight-slider-group">
          <label>Sector <span id="val-sector">10%</span></label>
          <input type="range" min="0" max="100" value="10" data-key="sector" oninput="updateWeightVal(this)">
        </div>
        <div class="weight-slider-group">
          <label>Country <span id="val-country">10%</span></label>
          <input type="range" min="0" max="100" value="10" data-key="country" oninput="updateWeightVal(this)">
        </div>
        <!-- New Tenure slider -->
        <div class="weight-slider-group">
          <label>Tenure <span id="val-tenure">5%</span></label>
          <input type="range" min="0" max="100" value="5" data-key="tenure" oninput="updateWeightVal(this)">
        </div>
      </div>
      <div class="weight-total">
          <button class="btn-reset-weights" onclick="resetWeightsToDefault()">Reset Defaults</button>
          <span id="weightTotalDisplay">Total: 100%</span>
      </div>
    </div>
  </div>

  <div id="rebateNotice">
    <b>Rebate Validation Guidance</b><br>
    Submission: Upload a PDF/DOC profile or use Bulk Assessment (ensure filenames match profile names).<br>
    Rebate Eligibility: Scores &lt; 50% qualify for a token refund. For scores â‰¥ 50%, submit a justification in the Appeal section to maintain eligibility.<br>
    <span style="color:#9a5a00;">Deletion Policy: Profiles receiving a rebate are automatically deleted. Manually deleting an entry also triggers a rebate.</span>
    <div style="margin-top:6px;">
      <span class="token-counter" id="rebateTokenCounter">Rebate Tokens: 0</span>
      <span class="token-counter" id="accountTokenCounter" style="background:#f5f8fa;border-color:#1f6feb;color:#0969da;margin-left:8px;">Account Tokens: â€¦</span>
    </div>
  </div>
  <p id="roleTagContext">Profiles found for your search: <span id="roleTagValue">loadingâ€¦</span></p>
  <div id="toolbar">
      <!-- Upload Profile option removed as requested -->
      
      <!-- Snipper UI removed as requested -->

      <!-- Status and Metrics -->
      <span id="status" style="margin-right:12px;"></span>
      <div class="metrics" id="metricsBox" aria-live="polite" style="margin-right:12px;">
          <span class="metric"><strong>Total Search Token:</strong> <span id="totalToken">5000</span></span>
          <span class="metric"><strong>Total Results:</strong> <span id="totalResults">0</span></span>
          <span class="metric"><strong>Tokens Left:</strong> <span id="tokensLeft">5000</span></span>
      </div>

      <!-- Refresh Button - Moved to former checkbox position -->
      <button id="reloadBtn" title="Reset assessment state and refetch data">Refresh</button>

      <!-- Combined Bulk Assessment Button (Upload + Assessment) -->
      <button id="bulkAssessmentBtn" style="background:linear-gradient(180deg,#3b82f6,#2563eb); border:1px solid #1d4ed8; color:white; margin-right:8px;" title="Verify the directory settings before initiating bulk PDF upload and assessment.">Bulk Assessment</button>
      <button id="exportExcelBtn" title="Download Excel and purge sourcing table">Download Excel</button>
      
      <!-- Hidden file input for directory upload -->
      <input type="file" id="bulkDirInput" webkitdirectory directory multiple style="display:none">
      <!-- Deep Research button: Moved to end position and styled to be invisible per requirement.
           Button remains functional with pointer-events but invisible until explicitly needed.
           Styling: white on white with opacity:0 as requested in comment #3768916799 -->
      <button id="exportCsvBtn" title="Deep Research" style="outline:white; color:white; background:white; border:1px solid white; opacity:0; pointer-events:auto;">Deep Research</button>

      <button id="marketAnalysisBtn" title="Transfer sourcing data to admin table & open Data Sorter">Run Market Analysis</button>
  </div>

  <!-- Bulk Assessment Progress Indicator (from Assessment Review) -->
  <div id="searchBulkProgressContainer" style="margin:10px 0; display:none; padding:10px; background:#f0f9ff; border:1px solid #bae6fd; border-radius:8px;">
      <div style="display:flex; justify-content:space-between; margin-bottom:4px;">
          <span style="font-size:12px; font-weight:700; color:#0369a1;">Processing Batch...</span>
          <span id="searchBulkProgressPercent" style="font-size:12px; font-weight:700; color:#0369a1;">0%</span>
      </div>
      <div style="height:6px; width:100%; background:#e0f2fe; border-radius:3px; overflow:hidden;">
          <div id="searchBulkProgressBar" style="height:100%; width:0%; background:#0ea5e9; transition:width 0.3s ease;"></div>
      </div>
  </div>

  <!-- Bulk Upload Progress Indicator -->
  <div id="bulkUploadProgressContainer" style="margin:10px 0; display:none; padding:10px; background:#f0fdf4; border:1px solid #bbf7d0; border-radius:8px;">
      <div style="display:flex; justify-content:space-between; margin-bottom:4px;">
          <span id="bulkUploadProgressText" style="font-size:12px; font-weight:700; color:#15803d;">Uploading Files...</span>
          <span id="bulkUploadProgressPercent" style="font-size:12px; font-weight:700; color:#15803d;">0%</span>
      </div>
      <div style="height:6px; width:100%; background:#dcfce7; border-radius:3px; overflow:hidden;">
          <div id="bulkUploadProgressBar" style="height:100%; width:0%; background:#22c55e; transition:width 0.3s ease;"></div>
      </div>
  </div>

  <div id="tableContainer" style="overflow:auto; max-height:65vh; border:1px solid #d0d7de; border-radius:8px; background:#fff;">
      <table id="sourcingTable">
          <thead>
              <tr>
                  <!-- Empty checkbox column retained for layout consistency (previously contained select all checkbox) -->
                  <th class="checkbox-cell"></th>
                  <th style="width:60px;">Profile</th>
                  <th>Name</th>
                  <th>Company</th>
                  <th>Job Title</th>
                  <th style="width:8%;">Country</th>
                  <th style="width:8%;">Action</th>
                  <th id="matchLevelHeader" style="width:33.33%; cursor:pointer; user-select:none;" title="Click to sort by Match Level" aria-sort="none" role="columnheader">Match Level <span aria-hidden="true"></span></th>
              </tr>
          </thead>
          <tbody id="tableBody">
              <tr><td colspan="8" style="text-align:center; padding:30px;" id="loadingRow">
                  <span class="spinner"></span> Loadingâ€¦
              </td></tr>
          </tbody>
      </table>
  </div>
  <div id="pager" class="pager" aria-live="polite" aria-label="Pagination Controls" role="navigation" style="display:none;">
      <button id="prevPageBtn" title="Previous page">&larr; Prev</button>
      <span class="info" id="pageInfo">Page 1 of 1</span>
      <button id="nextPageBtn" title="Next page">Next &rarr;</button>
  </div>

</div>

<!-- Tab 2: View Details -->
<div id="tab-details" class="tab-pane">
    <div style="margin-bottom: 20px; display: flex; gap: 12px; align-items: center;">
        <button onclick="switchTab('tab-search')" class="btn-secondary" style="background:#f6f8fa; border:1px solid #d0d7de; color:#1f2328;">&larr; Back to Search Results</button>
        <button id="viewDetailsRefreshBtn" class="btn-secondary" style="background:#f0f9ff; border:1px solid #bae6fd; color:#0369a1;" title="Hover or click to refresh current profile data">ðŸ”„ Refresh</button>
        <span id="refreshStatus" role="status" aria-live="polite" style="display:none; font-size:13px; color:#0369a1;"></span>
    </div>
    <div id="details-container">
        <div style="text-align:center; padding: 40px; color: var(--argent);">
            Please select a profile from the Search Results tab.
        </div>
    </div>
</div>

<!-- Tab 4: Deep Research (EMBEDDED DATA SORTER) -->
<div id="tab-research" class="tab-pane">
    <div style="margin-bottom: 12px;">
        <button onclick="switchTab('tab-search')" class="btn-secondary" style="background:#f6f8fa; border:1px solid #d0d7de; color:#1f2328;">&larr; Back to Search Results</button>
    </div>
    
    <!-- EMBEDDED DATA SORTER UI -->
    <div id="ds-embedded-root" class="ds-container">
      <div class="ds-section-grid" style="margin-top:.7rem;">
        <div class="ds-section-half">
          <label class="ds-form-label" style="display:flex; align-items:center; gap:.6rem;">
            <span>Data Analysis Source</span>
          </label>
          <div class="ds-rendering-analysis" id="ds-rendering-analysis" role="status" aria-live="polite"></div>
          <div id="ds-upload-status" class="subtle" style="margin-top:.45rem;"></div>
        </div>
      </div>

      <div id="ds-analysis-progress" class="ds-progress-wrapper hidden">
        <div class="ds-progress-bar-bg"><div class="ds-progress-bar-fill" id="ds-progress-bar-fill"></div></div>
        <div class="ds-eta-text" id="ds-eta-text">Analyzing...</div>
      </div>

      <div class="ds-group-box">
        <em id="suggestion-intro">Job Family Suggestions (Sector aware)</em>
        <div id="job-family-filters"></div>
        <div id="auto-job-family-group" class="ds-checkbox-group" data-group-type="family"></div>
        <!-- Visualization chooser for Job Family -->
        <div style="display:flex;gap:8px;align-items:center;margin-top:10px;">
          <label for="viz-select-jobfamily" style="font-weight:700;color:var(--text-soft);font-size:.86rem;margin:0;">Visualize as:</label>
          <select id="viz-select-jobfamily" class="ds-select" style="max-width:220px;">
            <option value="None">None</option>
            <optgroup label="Cartesian charts">
              <option value="Column">Column</option>
              <option value="Bar">Bar</option>
              <option value="Scatter">Scatterplot</option>
              <option value="Line">Line</option>
              <option value="Area">Area</option>
            </optgroup>
            <optgroup label="Pie and donut charts">
              <option value="Pie">Pie</option>
              <option value="Donut">Donut</option>
            </optgroup>
            <optgroup label="Text and tables">
              <option value="Table">Table</option>
            </optgroup>
          </select>
        </div>
        <!-- Job Family distribution chart (Job Family Visualization) -->
        <div style="margin-top:12px;">
          <div style="font-weight:700; font-size:.86rem; color:var(--accent); margin-bottom:6px;">Job Family Distribution</div>
          <div style="position:relative; width:100%; max-width:100%; height:220px;">
            <canvas id="jobfamily-chart" aria-label="Job family bar chart" role="img" style="width:100%; height:100%; display:block;"></canvas>
          </div>
          <div id="jobfamily-table" style="margin-top:8px;"></div>
        </div>
        <div id="job-family-suggestion-meta" class="subtle" style="margin-top:.5rem;"></div>
      </div>

      <div class="ds-group-box">
        <em id="seniority-intro">Seniority Distribution</em>
        <div id="seniority-filters"></div>
        <div id="auto-seniority-group" class="ds-checkbox-group" data-group-type="seniority"></div>
        <!-- Visualization chooser for Seniority -->
        <div style="display:flex;gap:8px;align-items:center;margin-top:10px;">
          <label for="viz-select-seniority" style="font-weight:700;color:var(--text-soft);font-size:.86rem;margin:0;">Visualize as:</label>
          <select id="viz-select-seniority" class="ds-select" style="max-width:220px;">
            <option value="None">None</option>
            <optgroup label="Cartesian charts">
              <option value="Column">Column</option>
              <option value="Bar">Bar</option>
              <option value="Scatter">Scatterplot</option>
              <option value="Line">Line</option>
              <option value="Area">Area</option>
            </optgroup>
            <optgroup label="Pie and donut charts">
              <option value="Pie">Pie</option>
              <option value="Donut">Donut</option>
            </optgroup>
            <optgroup label="Text and tables">
              <option value="Table">Table</option>
            </optgroup>
          </select>
        </div>
        <div style="margin-top:12px;">
          <div style="font-weight:700; font-size:.86rem; color:var(--accent); margin-bottom:6px;">Seniority Distribution</div>
          <div style="position:relative; width:100%; max-width:100%; height:220px;">
            <canvas id="seniority-chart" aria-label="Seniority chart" role="img" style="width:100%; height:100%; display:block;"></canvas>
          </div>
          <div id="seniority-table" style="margin-top:8px;"></div>
        </div>
        <div id="seniority-suggestion-meta" class="subtle" style="margin-top:.5rem;"></div>
      </div>

      <div class="ds-group-box">
        <em id="company-intro">Company Distribution</em>
        <div id="company-filters"></div>
        <div id="auto-company-group" class="ds-checkbox-group" data-group-type="company"></div>
        <!-- Visualization chooser for Company -->
        <div style="display:flex;gap:8px;align-items:center;margin-top:10px;">
          <label for="viz-select-company" style="font-weight:700;color:var(--text-soft);font-size:.86rem;margin:0;">Visualize as:</label>
          <select id="viz-select-company" class="ds-select" style="max-width:220px;">
            <option value="None">None</option>
            <optgroup label="Cartesian charts">
              <option value="Column">Column</option>
              <option value="Bar">Bar</option>
              <option value="Scatter">Scatterplot</option>
              <option value="Line">Line</option>
              <option value="Area">Area</option>
            </optgroup>
            <optgroup label="Pie and donut charts">
              <option value="Pie">Pie</option>
              <option value="Donut">Donut</option>
            </optgroup>
            <optgroup label="Text and tables">
              <option value="Table">Table</option>
            </optgroup>
          </select>
        </div>
        <div style="margin-top:12px;">
          <div style="font-weight:700; font-size:.86rem; color:var(--accent); margin-bottom:6px;">Company Distribution</div>
          <div style="position:relative; width:100%; max-width:100%; height:220px;">
            <canvas id="company-chart" aria-label="Company chart" role="img" style="width:100%; height:100%; display:block;"></canvas>
          </div>
          <div id="company-table" style="margin-top:8px;"></div>
        </div>
        <div id="company-suggestion-meta" class="subtle" style="margin-top:.5rem;"></div>
      </div>

      <!-- Country Inference Section - Map Added -->
      <div class="ds-group-box">
        <em id="geo-intro">Country Inference</em>
        <div style="display:flex;flex-wrap:wrap;gap:1.1rem;">
          <div style="flex:1 1 100%;">
            <div style="margin:.25rem 0 .55rem; font-size:.86rem; letter-spacing:.6px; font-weight:700; text-transform:uppercase; color:var(--accent);">Countries</div>
            <div id="country-filters"></div>
            <div id="suggested-country-group" class="ds-checkbox-group" data-group-type="country"></div>
            <div id="country-suggestion-meta" class="subtle" style="margin-top:.55rem;"></div>
            
            <div style="display:flex;gap:8px;align-items:center;margin-top:10px;margin-bottom:6px;">
              <label for="viz-select-country" style="font-weight:700;color:var(--text-soft);font-size:.86rem;margin:0;">Visualize as:</label>
              <select id="viz-select-country" class="ds-select" style="max-width:220px;">
                <option value="Table" selected>Table</option>
                <optgroup label="Cartesian charts">
                  <option value="Column">Column</option>
                  <option value="Bar">Bar</option>
                </optgroup>
                <optgroup label="Map">
                  <option value="Map">Map</option>
                </optgroup>
              </select>
            </div>

            <div style="margin-top:10px;">
              <!-- Map Container reinstated for performance-aware mapping -->
              <div id="country-map" style="width:100%;height:220px;display:none;border-radius:8px;overflow:hidden;"></div>

              <div id="country-chart-alt" style="width:100%;height:220px;display:none;">
                 <canvas id="country-chart-canvas" aria-label="Country chart" role="img" style="width:100%;height:100%;display:block;"></canvas>
              </div>
              <div id="country-table" style="margin-top:8px;"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="ds-group-box" style="border:none; background:transparent; padding:0; box-shadow:none;">
        <label class="ds-form-label" style="margin-top:0;">Contact Columns</label>
        <div class="ds-checkbox-group clean-buttons" id="ds-contact-group" style="margin-top:.55rem;"></div>
      </div>

      <!-- Removed Sourcing Status section as requested -->

      <div class="ds-group-box">
        <em>Sourcing Status (Editable Chips)</em>
        <div class="ds-chip-wrap" id="ds-sourcing-chip-container" style="display:none;"></div>
        <div class="ds-inline-add" style="display:none;">
          <input type="text" id="ds-add-sourcing-status-input" class="ds-input" placeholder="Add new sourcing status">
          <button type="button" class="ds-btn ds-btn-small" id="ds-add-sourcing-status-btn">Add</button>
        </div>
      </div>

      <div class="error-box" id="ds-preview-error" style="display:none;"></div>
      
      <!-- EXPORT ACTIONS -->
      <div style="margin-top:1.25rem; display:flex; gap:10px;">
          <button type="button" class="ds-btn" id="ds-export-excel-btn">Preview & Export Excel</button>
      </div>

      <div id="ds-export-progress" class="ds-progress-wrapper hidden">
        <div class="ds-progress-bar-bg"><div class="ds-progress-bar-fill ds-export-bar-fill" id="ds-export-bar-fill"></div></div>
        <div class="ds-eta-text ds-eta-text-export" id="ds-export-eta">Preparing Excel...</div>
        <div class="timer-line" id="ds-export-elapsed">Elapsed: 0.0s</div>
        <div class="disclaimer" id="ds-export-disclaimer"></div>
      </div>
    </div>
    </div>
    <!-- END EMBEDDED DATA SORTER UI -->
</div>

<script>
/* Simple Tab Switcher Logic */
function switchTab(tabId) {
    document.querySelectorAll('.tab-pane').forEach(el => el.classList.remove('active'));
    document.querySelectorAll('.tab-btn').forEach(el => el.classList.remove('active'));
    
    const pane = document.getElementById(tabId);
    if (pane) pane.classList.add('active');

    // Highlight correct button
    if(tabId === 'tab-search') {
        document.querySelector('.tab-btn:nth-child(1)').classList.add('active');
        // Refresh data when switching to Search Results tab
        if (typeof refreshData === 'function') {
            refreshData();
        }
    } else if(tabId === 'tab-details') {
        document.querySelector('.tab-btn:nth-child(2)').classList.add('active');
        // Auto-refresh View Details tab: trigger refresh button after 1 second
        // The 1-second delay is intentional as per requirement specification
        setTimeout(() => {
            const viewDetailsRefreshBtn = document.getElementById('viewDetailsRefreshBtn');
            if (viewDetailsRefreshBtn) {
                viewDetailsRefreshBtn.click();
            }
        }, 1000);
    } else if (tabId === 'tab-research') {
        document.querySelector('.tab-btn:nth-child(3)').classList.add('active');
        // Trigger Deep Research logic when tab is activated to ensure data is present
        if (typeof deepResearch === 'function') {
            deepResearch();
        }
    }
}
</script>

<script>
/* Fetch and cache data_sorter.json for reference */
let _dataSorterReference = null;
(async function loadDataSorterJson() {
    try {
        const response = await fetch('data_sorter.json');
        if (response.ok) {
            _dataSorterReference = await response.json();
            console.log("Loaded data_sorter.json for reference");
        } else {
            console.warn("Could not load data_sorter.json");
        }
    } catch (e) {
        console.warn("Error loading data_sorter.json", e);
    }
})();

function getReferenceMapping(jobTitle) {
    if (!_dataSorterReference || !jobTitle) return null;
    const titleLower = jobTitle.trim().toLowerCase();
    if (_dataSorterReference.mappings && _dataSorterReference.mappings[titleLower]) {
        return _dataSorterReference.mappings[titleLower];
    }
    if (_dataSorterReference.patterns) {
        for (const pattern of _dataSorterReference.patterns) {
            try {
                if (new RegExp(pattern.regex, 'i').test(titleLower)) {
                    return { family: pattern.family, seniority: pattern.seniority };
                }
            } catch(_) { continue; }
        }
    }
    return null;
}
</script>

<script>
/* Weight Configuration Logic */
const defaultWeights = {
  "jobtitle_role_tag": 35,
  "skillset": 20,
  "seniority": 10,
  "company": 10,
  "sector": 10,
  "country": 10,
  "tenure": 5
};

function toggleWeightConfig() {
  const content = document.getElementById('weightConfigContent');
  const arrow = document.getElementById('weightConfigArrow');
  content.classList.toggle('open');
  arrow.textContent = content.classList.contains('open') ? 'â–²' : 'â–¼';
}

// Setup hover behavior for Assessment Weightage Configuration
(function setupWeightConfigHover() {
  const panel = document.getElementById('weightConfigPanel');
  const content = document.getElementById('weightConfigContent');
  const arrow = document.getElementById('weightConfigArrow');
  const header = document.getElementById('weightConfigHeader');
  
  if (panel && content && arrow && header) {
    // Hover behavior - expand on mouseenter
    panel.addEventListener('mouseenter', function() {
      content.classList.add('open');
      arrow.textContent = 'â–²';
    });
    
    // Collapse on mouseleave - validate weights when closing
    panel.addEventListener('mouseleave', function() {
      content.classList.remove('open');
      arrow.textContent = 'â–¼';
      
      // Validate weights when panel closes
      setTimeout(function() {
        if (typeof window.validateWeightsOnClose === 'function') {
          window.validateWeightsOnClose();
        }
      }, 200);
    });
    
    // Focus behavior for keyboard accessibility
    header.addEventListener('focus', function() {
      content.classList.add('open');
      arrow.textContent = 'â–²';
    });
    
    header.addEventListener('blur', function() {
      // Delay to allow clicking on sliders inside the panel
      setTimeout(function() {
        if (!panel.contains(document.activeElement)) {
          content.classList.remove('open');
          arrow.textContent = 'â–¼';
          
          // Validate weights when panel closes
          if (typeof window.validateWeightsOnClose === 'function') {
            window.validateWeightsOnClose();
          }
        }
      }, 150);
    });
  }
})();

function loadWeights() {
  let saved = localStorage.getItem('sv_assessment_weights');
  let current = defaultWeights;
  if (saved) {
    try {
      const parsed = JSON.parse(saved);
      if (parsed) current = Object.assign({}, defaultWeights, parsed);
    } catch(e) {}
  }
  
  document.querySelectorAll('.weight-sliders input[type=range]').forEach(input => {
    const key = input.dataset.key;
    if (key && current[key] !== undefined) {
      input.value = current[key];
      // update label
      const labelEl = document.getElementById('val-' + key);
      if (labelEl) labelEl.textContent = current[key] + '%';
    }
  });
  validateTotalWeight();
}

function updateWeightVal(input) {
  const key = input.dataset.key;
  const labelEl = document.getElementById('val-' + key);
  if (labelEl) labelEl.textContent = input.value + '%';
  validateTotalWeight();
}

function validateTotalWeight() {
  const inputs = document.querySelectorAll('.weight-sliders input[type=range]');
  let sum = 0;
  let config = {};
  
  inputs.forEach(input => {
    if(!input.disabled) {
      const val = parseInt(input.value) || 0;
      sum += val;
      config[input.dataset.key] = val;
    }
  });
  
  const display = document.getElementById('weightTotalDisplay');
  display.textContent = `Total: ${sum}%`;
  
  if (sum === 100) {
    display.classList.remove('invalid');
    display.style.color = '#10b981'; // Green
    localStorage.setItem('sv_assessment_weights', JSON.stringify(config));
  } else {
    display.classList.add('invalid');
    display.style.color = '#ef4444'; // Red
  }
}

function getActiveWeights() {
  let saved = localStorage.getItem('sv_assessment_weights');
  if (saved) {
    try {
      return JSON.parse(saved);
    } catch(e) {}
  }
  return defaultWeights;
}

function resetWeightsToDefault() {
    localStorage.removeItem('sv_assessment_weights');
    loadWeights();
}

document.addEventListener('DOMContentLoaded', loadWeights);

// Weight snapshot + enforcement (restore previous weights if total != 100)
(function() {
  // previous weights snapshot (in-memory and persisted briefly)
  let _prevWeights = null;

  function readSavedWeights() {
    try {
      const raw = localStorage.getItem('sv_assessment_weights');
      if (!raw) return null;
      return JSON.parse(raw);
    } catch (e) { return null; }
  }

  function savePrevWeightsSnapshot() {
    // capture current displayed slider values as snapshot
    const inputs = document.querySelectorAll('.weight-sliders input[type=range]');
    const snap = {};
    inputs.forEach(i => { if (i.dataset && i.dataset.key) snap[i.dataset.key] = parseInt(i.value) || 0; });
    _prevWeights = snap;
    try { localStorage.setItem('sv_assessment_weights_prev', JSON.stringify(snap)); } catch(_) {}
  }

  function restorePrevWeights() {
    const prev = _prevWeights || (function(){ try { return JSON.parse(localStorage.getItem('sv_assessment_weights_prev')||'{}'); } catch(e){return null;} })();
    if (!prev) return;
    document.querySelectorAll('.weight-sliders input[type=range]').forEach(input => {
      const key = input.dataset.key;
      if (key && typeof prev[key] !== 'undefined') {
        input.value = prev[key];
        const labelEl = document.getElementById('val-' + key);
        if (labelEl) labelEl.textContent = prev[key] + '%';
      }
    });
    validateTotalWeight(); // update total display and saved state
  }

  // Global function to validate weights when panel closes
  window.validateWeightsOnClose = function() {
    const sum = Array.from(document.querySelectorAll('.weight-sliders input[type=range]'))
                     .reduce((acc, el) => acc + (parseInt(el.value) || 0), 0);
    if (sum !== 100) {
      // Revert to snapshot and prompt user
      restorePrevWeights();
      // Show alert when panel is toggled off with invalid total
      alert('Weight total must equal 100%. Your change was reverted to the previous values. Please re-adjust the sliders so the total equals 100%.');
    }
  };

  // Save snapshot when user begins interacting with any slider (pointerdown/focus)
  document.addEventListener('DOMContentLoaded', function() {
    document.querySelectorAll('.weight-sliders input[type=range]').forEach(input => {
      input.addEventListener('pointerdown', savePrevWeightsSnapshot);
      input.addEventListener('touchstart', savePrevWeightsSnapshot, {passive:true});
      input.addEventListener('focus', savePrevWeightsSnapshot);
      // On change (user finished moving), just update display without alert
      input.addEventListener('change', function() {
        // Update display but don't show alert yet - wait until panel closes
        validateTotalWeight();
      });
    });
  });

  // Wrap/extend validateTotalWeight so it only writes to localStorage when sum === 100
  const _origValidateTotalWeight = window.validateTotalWeight;
  window.validateTotalWeight = function() {
    // If original exists, use it to update labels; otherwise run current implementation
    try {
      // compute sum here (avoid calling original which also persisted)
      const inputs = document.querySelectorAll('.weight-sliders input[type=range]');
      let sum = 0;
      let config = {};
      inputs.forEach(input => {
        if (!input.disabled) {
          const val = parseInt(input.value) || 0;
          sum += val;
          if (input.dataset && input.dataset.key) config[input.dataset.key] = val;
        }
      });
      const display = document.getElementById('weightTotalDisplay');
      if (display) display.textContent = `Total: ${sum}%`;
      if (sum === 100) {
        if (display) { display.classList.remove('invalid'); display.style.color = '#10b981'; }
        try { localStorage.setItem('sv_assessment_weights', JSON.stringify(config)); } catch(_) {}
      } else {
        if (display) { display.classList.add('invalid'); display.style.color = '#ef4444'; }
        // do not save invalid totals
      }
    } catch (e) {
      // Fallback to original if available
      if (typeof _origValidateTotalWeight === 'function') _origValidateTotalWeight();
    }
  };

  // Keep resetDefaults behavior (if you still want a hard reset to application defaults)
  // Existing resetWeightsToDefault continues to call loadWeights()

})();
</script>

<script>
/* Assessment Review Logic Module */

/*
  Problem diagnosed / fix summary:
  - Error "Cannot set properties of null (setting 'innerHTML')" occurred in renderAssessmentReviewTable
    because that function expected an element with id "reviewTableBody" to exist. In the current UI
    the Assessment Review tab/UI was intentionally removed which left the DOM node absent.
  - Fix strategy:
    1) Add a hidden placeholder table with tbody id="reviewTableBody" (above) so legacy functions will
       find the element if they attempt to render.
    2) Add defensive guards in JS so functions behave gracefully if the element is missing.
    3) If assessment results come from the Search tab (not Assessment Review table), update the Search
       table rows directly with a lightweight badge so users immediately see scores without needing the
       Review table to be visible.
*/

let pendingReviewRows = [];
let bulkJobId = null;
let bulkPollInterval = null;
let bulkPollEventSource = null;  // NEW: SSE connection for bulk assessment

/* Helper: safely find element by id */
function $id(id) { return document.getElementById(id); }

/* Helper: update a row in Search Results table with assessment result (best-effort) */
function updateSearchTableRowWithResult(linkedinurl, result) {
    try {
        if (!linkedinurl || !result) return false;
        // Use CSS.escape for safety, fallback if not available
        const selUrl = (window.CSS && CSS.escape) ? CSS.escape(linkedinurl) : linkedinurl.replace(/"/g,'\\"');
        const tr = document.querySelector(`#sourcingTable tbody tr[data-linkedinurl="${selUrl}"]`);
        if (!tr) return false;
        // attach rating JSON to dataset for later use
        try { tr.dataset.rating = JSON.stringify(result); } catch(e) { /* ignore */ }
        // mark row as assessed visually in last cell
        const lastCell = tr.querySelector('td:last-child') || tr.appendChild(document.createElement('td'));
        const total_score = result.total_score || (result.totalScore || '') || '0%';
        const starCount = typeof result.stars !== 'undefined' ? result.stars : (result.star || 0);
        const assessmentLevel = result.assessment_level || (result.is_level2 ? 'L2 Assessment' : 'L1 Assessment');
        // Generate visual star HTML (filled/unfilled)
        let starsHtml = '';
        for (let i = 0; i < 5; i++) {
            starsHtml += `<span class="${i < starCount ? 'filled' : ''}">â˜…</span>`;
        }
        lastCell.innerHTML = `<div class="assessment-badge"><div style="font-size:11px;color:#6b7280;">${assessmentLevel}: <b>${total_score}</b></div><div class="assessment-stars">${starsHtml}</div></div>`;
        // add a class so other logic can pick it up
        tr.classList.add('assessment-complete');
        return true;
    } catch (e) {
        console.warn('[updateSearchTableRowWithResult] failed', e);
        return false;
    }
}

/* Helper: update a row in Search Results table with "Assessment pending" status */
function updateSearchTableRowWithPendingStatus(linkedinurl) {
    try {
        if (!linkedinurl) return false;
        // Use CSS.escape for safety, fallback if not available
        const selUrl = (window.CSS && CSS.escape) ? CSS.escape(linkedinurl) : linkedinurl.replace(/"/g,'\\"');
        const tr = document.querySelector(`#sourcingTable tbody tr[data-linkedinurl="${selUrl}"]`);
        if (!tr) return false;
        // Clear any existing rating data
        try { delete tr.dataset.rating; } catch(e) { /* ignore */ }
        // mark row as pending in last cell
        const lastCell = tr.querySelector('td:last-child') || tr.appendChild(document.createElement('td'));
        lastCell.innerHTML = `<span class="assessment-placeholder">Assessment pending</span>`;
        // remove assessment-complete class if it exists
        tr.classList.remove('assessment-complete');
        return true;
    } catch (e) {
        console.warn('[updateSearchTableRowWithPendingStatus] failed', e);
        return false;
    }
}

/* Helper: update Upload CV button to View button after assessment */
function updateUploadButtonToView(linkedinurl) {
    try {
        if (!linkedinurl) return false;
        const selUrl = (window.CSS && CSS.escape) ? CSS.escape(linkedinurl) : linkedinurl.replace(/"/g,'\\"');
        const tr = document.querySelector(`#sourcingTable tbody tr[data-linkedinurl="${selUrl}"]`);
        if (!tr) return false;
        
        // Find the credential cell with Upload CV button
        const credentialCell = tr.querySelector('td[data-field="linkedinurl"], td[data-field="credential"]');
        if (!credentialCell) return false;
        
        // Check if there's a button that needs to be converted to View
        const uploadBtn = credentialCell.querySelector('button');
        if (uploadBtn) {
            const btnText = uploadBtn.textContent || '';
            // Convert if it's "Upload CV", "Analyzing...", "Processing...", or similar states
            const shouldConvert = btnText.includes('Upload CV') || 
                                 btnText.includes('Analyzing') || 
                                 btnText.includes('Processing') ||
                                 uploadBtn.classList.contains('assessment-active');
            
            if (shouldConvert) {
                // Replace with View button
                credentialCell.innerHTML = '';
                const viewBtn = document.createElement('button');
                viewBtn.textContent = 'View';
                viewBtn.className = 'view-btn assessment-complete';
                viewBtn.style.cssText = 'width:100%; padding:6px 12px; font-size:13px; cursor:pointer;';
                viewBtn.title = "Assessment Complete - Click to View";
                viewBtn.onclick = () => { 
                    if (window.__sv_namecard && window.__sv_namecard.toggleNameCard) {
                        window.__sv_namecard.toggleNameCard(tr);
                    }
                };
                credentialCell.appendChild(viewBtn);
                return true;
            }
        }
        return false;
    } catch (e) {
        console.warn('[updateUploadButtonToView] failed', e);
        return false;
    }
}

/* Helper functions for bulk assessment */

// CACHE_UPDATE_DELAY_MS: Delay to ensure localStorage cache writes complete before View Details refresh.
// This prevents race conditions where View Details renders before cached assessment data is persisted.
// Value of 200ms provides a safe buffer accounting for:
// - localStorage write operation (typically 10-50ms)
// - Browser rendering cycle (typically 16-32ms at 60fps)
// - Occasional browser lag or slow devices (up to 100ms)
// - Additional safety margin to prevent edge case race conditions
// Total: 200ms balances reliability vs UI responsiveness
const CACHE_UPDATE_DELAY_MS = 200;

// BACKEND_PROCESSING_BUFFER_MS: Additional delay to allow backend processing to complete after assessment.
// Ensures skillset and product data are fully processed and available in database before View Details refresh.
// Value of 1000ms accounts for:
// - CV analysis and skillset extraction (typically 300-700ms)
// - Database write operations (typically 50-200ms)
// - Network latency for subsequent fetch (typically 100-200ms)
// Total: 1000ms ensures data availability without excessive delay
const BACKEND_PROCESSING_BUFFER_MS = 1000;

/* Helper: Auto-refresh Search Results after bulk assessment completes */
function autoRefreshViewDetailsIfActive() {
    // After bulk assessment completes, trigger auto-refresh to show updated skillset/product
    console.log('[Bulk Assessment] Triggering auto-refresh after assessment completion');
    
    setTimeout(() => {
        // 1. First, refresh the Search Result table data
        const reloadBtn = document.getElementById('reloadBtn');
        if (reloadBtn) {
            console.log('[Bulk Assessment] Clicking Refresh button in Search Result tab');
            reloadBtn.click();
        } else {
            console.warn('[Bulk Assessment] Search Result Refresh button not found');
        }
        
        // 2. Also refresh View Details tab if it's currently active
        const detailsTab = document.getElementById('tab-details');
        const viewDetailsRefreshBtn = document.getElementById('viewDetailsRefreshBtn');
        if (detailsTab && detailsTab.classList.contains('active') && viewDetailsRefreshBtn) {
            console.log('[Bulk Assessment] View Details tab is active - clicking its Refresh button');
            viewDetailsRefreshBtn.click();
        }
    }, BACKEND_PROCESSING_BUFFER_MS); // Pause for backend processing to complete
}

/* Helper: animate button during bulk assessment processing */
function animateButtonDuringBulkAssessment(linkedinurl, state) {
    try {
        if (!linkedinurl) return false;
        const selUrl = (window.CSS && CSS.escape) ? CSS.escape(linkedinurl) : linkedinurl.replace(/"/g,'\\"');
        const tr = document.querySelector(`#sourcingTable tbody tr[data-linkedinurl="${selUrl}"]`);
        if (!tr) return false;
        
        const credentialCell = tr.querySelector('td[data-field="linkedinurl"], td[data-field="credential"]');
        if (!credentialCell) return false;
        
        const uploadBtn = credentialCell.querySelector('button');
        if (!uploadBtn) return false;
        
        // Animate through states: Upload CV â†’ Analyzing â†’ Processing â†’ View
        switch(state) {
            case 'analyzing':
                uploadBtn.textContent = 'Analyzing...';
                uploadBtn.disabled = true;
                uploadBtn.style.opacity = '0.7';
                break;
            case 'processing':
                uploadBtn.textContent = 'Processing...';
                uploadBtn.style.opacity = '0.7';
                break;
            case 'view':
                // Transition to View button
                updateUploadButtonToView(linkedinurl);
                break;
            default:
                break;
        }
        return true;
    } catch (e) {
        console.warn('[animateButtonDuringBulkAssessment] failed', e);
        return false;
    }
}

/* Helper: Cache assessment HTML for a profile */
function cacheAssessmentHTML(linkedinurl, result) {
    if (!linkedinurl || !result || result.error) return;
    
    const { fullHtml, tableHtml } = generateAssessmentHTML(result);
    
    // Extract numeric score from total_score string (e.g., "75%" -> 75, "75.5%" -> 75.5)
    let totalScore = 0;
    if (result.total_score) {
        const scoreMatch = result.total_score.toString().match(/^(\d+(?:\.\d+)?)%?$/);
        totalScore = scoreMatch ? parseFloat(scoreMatch[1]) : 0;
    }
    
    if (fullHtml && window.__sv_namecard && window.__sv_namecard.setCardCache) {
        window.__sv_namecard.setCardCache(linkedinurl, {
            assessmentHTML: fullHtml,
            assessmentTableHTML: tableHtml,
            totalScore: totalScore  // Store numeric score for tick/cross display
        });
        // Log cache operation without exposing PII - simple hash for debugging
        // Use length and first few chars for lightweight unique identifier
        const hashId = `${linkedinurl.length}_${(linkedinurl.charCodeAt(0) * 31 + linkedinurl.charCodeAt(linkedinurl.length - 1)) % 10000}`;
        console.log(`[cacheAssessmentHTML] Cached full assessment HTML for profile: id_${hashId}, score: ${totalScore}%`);
    }
}

/* Helper: Generate full assessment HTML from assessment result data */
function generateAssessmentHTML(data) {
    if (!data || data.error) return { fullHtml: '', tableHtml: '' };
    
    // Helper to escape HTML
    function escapeHtml(unsafe) {
        if (unsafe == null) return '';
        return String(unsafe)
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    }
    
    const starCount = data.stars || 0;
    const assessmentLevel = data.assessment_level || (data.is_level2 ? 'L2 Assessment' : 'L1 Assessment');
    const totalScore = data.total_score || '0%';
    const combinedHeader = `${assessmentLevel}: ${totalScore}`;
    
    // Generate stars HTML (just the star spans, wrapper div added in template)
    let starsSpans = '';
    for (let i = 0; i < 5; i++) {
        starsSpans += `<span class="${i < starCount ? 'filled' : ''}">â˜…</span>`;
    }
    
    // Build Category Appraisals HTML if available
    let categoryAppraisalsHtml = '';
    // Ensure category_appraisals is a plain object (not array or null)
    if (data.category_appraisals && typeof data.category_appraisals === 'object' && !Array.isArray(data.category_appraisals)) {
        const categories = Object.entries(data.category_appraisals);
        if (categories.length > 0) {
            categoryAppraisalsHtml = '<div class="category-appraisals">';
            categoryAppraisalsHtml += '<div class="category-appraisals-title">Category Breakdown</div>';
            categoryAppraisalsHtml += '<table class="category-appraisals-table">';
            categoryAppraisalsHtml += '<thead><tr><th>Category</th><th>Weightage Score</th><th>Rating</th></tr></thead>';
            categoryAppraisalsHtml += '<tbody>';
            
            categories.forEach(([category, details]) => {
                const weightPercent = details.weight_percent || 0;
                const starString = details.star_string || '';
                categoryAppraisalsHtml += `
                    <tr>
                        <td class="category-name">${escapeHtml(category)}</td>
                        <td class="category-weight">${weightPercent}%</td>
                        <td class="category-rating">${starString}</td>
                    </tr>
                `;
            });
            
            categoryAppraisalsHtml += '</tbody></table></div>';
        }
    }
    
    // Overall Comment HTML if available
    let overallCommentHtml = '';
    if (data.overall_comment) {
        overallCommentHtml = `<div class="assessment-overall-comment" style="margin-top: 8px; padding: 8px; background: #f0f9ff; border-left: 3px solid #0ea5e9; font-size: 12px; font-style: italic; color: #0c4a6e;">${escapeHtml(data.overall_comment)}</div>`;
    }
    
    // Full HTML for Details Tab (includes comments, category appraisals, and overall comment)
    const fullHtml = `
        <div class="assessment-header">${escapeHtml(combinedHeader)}</div>
        <div class="assessment-stars" style="color: #f59e0b; font-size: 14px; margin-top: 4px;">${starsSpans}</div>
        ${overallCommentHtml}
        <div class="assessment-comments" style="margin-top: 8px; font-size: 11px; color: #6b7280;">Comments: ${escapeHtml(data.comments || 'None')}</div>
        ${categoryAppraisalsHtml}
    `;
    
    // Simplified HTML for Search Results Table (ONLY assessment level + stars, no comments or other text)
    const tableHtml = `
        <div class="assessment-header">${escapeHtml(combinedHeader)}</div>
        <div class="assessment-stars" style="color: #f59e0b; font-size: 14px; margin-top: 4px;">${starsSpans}</div>
    `;
    
    return { fullHtml, tableHtml };
}

/* Apply bulk results: update Review table if present, otherwise update Search table rows */
/* Helper: sync a successful assessment result into rowsData and DOM dataset */
function _syncAssessmentToRowsData(linkedinurl, result) {
    try {
        const scoreMatch = (result.total_score || '0%').toString().match(/(\d+)%?/);
        const scoreNum = scoreMatch ? scoreMatch[1] : '0';
        const ratingLevel = result.is_level2 ? 'L2' : (
            result.assessment_level && result.assessment_level.includes('L2') ? 'L2' : 'L1'
        );

        // Sync rowsData so any subsequent renderTable() call preserves L2 state
        const idx = rowsData.findIndex(r => r.linkedinurl === linkedinurl);
        if (idx >= 0) {
            rowsData[idx].rating = result;
            rowsData[idx].rating_score = scoreNum;
            rowsData[idx].rating_stars = String(result.stars || 0);
            rowsData[idx].rating_level = ratingLevel;
        }

        // Sync DOM dataset so tr.dataset.rating is up-to-date for namecard
        try {
            const selUrl = (window.CSS && CSS.escape) ? CSS.escape(linkedinurl) : linkedinurl.replace(/"/g, '\\"');
            const tr = document.querySelector(`#sourcingTable tbody tr[data-linkedinurl="${selUrl}"]`);
            if (tr) {
                try { tr.dataset.rating = JSON.stringify(result); } catch(e) { console.warn('_syncAssessmentToRowsData: failed to serialize rating', e); }
                tr.classList.add('assessment-complete');
            }
        } catch(e) { console.warn('_syncAssessmentToRowsData: DOM sync failed', e); }
    } catch(e) { console.warn('_syncAssessmentToRowsData: rowsData sync failed', e); }
}

function applyBulkAssessmentResults(results) {
    if (!results || !Array.isArray(results)) return;
    // If pendingReviewRows is empty, renderAssessmentReviewTable will be no-op (guarded).
    if (!pendingReviewRows || pendingReviewRows.length === 0) {
        console.log('[applyBulkAssessmentResults] No rows in Assessment Review table to update. Will try updating Search Results table directly.');
        let updatedCount = 0;
        results.forEach(item => {
            const linkedinurl = item.linkedinurl;
            const result = item.result;
            // Handle both error results and successful results
            if (!result) return;
            // Check if this is an "Assessment pending" error
            if (result.error && result.error.includes('Assessment pending')) {
                // Update row to show "Assessment pending"
                if (updateSearchTableRowWithPendingStatus(linkedinurl)) updatedCount++;
            } else if (!result.error) {
                // Generate and cache full assessment HTML with category breakdown
                cacheAssessmentHTML(linkedinurl, result);
                // Sync into rowsData and DOM dataset to survive subsequent renderTable() calls
                _syncAssessmentToRowsData(linkedinurl, result);
                
                // Try update search table row with successful result
                if (updateSearchTableRowWithResult(linkedinurl, result)) {
                    updatedCount++;
                    // Also update Upload CV button to View button after successful assessment
                    updateUploadButtonToView(linkedinurl);
                }
            }
        });
        console.log(`[applyBulkAssessmentResults] Updated ${updatedCount}/${results.length} rows in Search table`);
        return;
    }

    console.log('[applyBulkAssessmentResults] Applying results for', results.length, 'profiles to', pendingReviewRows.length, 'table rows');

    let updatedCount = 0;
    results.forEach(resultItem => {
        const linkedinurl = resultItem.linkedinurl;
        const result = resultItem.result;
        
        // Handle "Assessment pending" errors
        if (result && result.error && result.error.includes('Assessment pending')) {
            console.log('[applyBulkAssessmentResults] Profile pending assessment (no CV):', linkedinurl);
            // Try to update in both tables
            updateSearchTableRowWithPendingStatus(linkedinurl);
            const rowIndex = pendingReviewRows.findIndex(r => r.linkedinurl === linkedinurl);
            if (rowIndex >= 0) {
                const row = pendingReviewRows[rowIndex];
                row.rating_score = '';
                row.rating_stars = '';
                row.rating_level = '';
                row.rating = null;
                updatedCount++;
            }
            return;
        }
        
        if (!result || result.error) {
            console.log('[applyBulkAssessmentResults] Skipping result with error for', linkedinurl);
            return;
        }

        // Generate and cache full assessment HTML with category breakdown
        cacheAssessmentHTML(linkedinurl, result);
        // Sync into rowsData and DOM dataset to survive subsequent renderTable() calls
        _syncAssessmentToRowsData(linkedinurl, result);

        const rowIndex = pendingReviewRows.findIndex(r => r.linkedinurl === linkedinurl);
        if (rowIndex >= 0) {
            const row = pendingReviewRows[rowIndex];
            const scoreMatch = (result.total_score || '0%').toString().match(/(\d+)%?/);
            const scoreNum = scoreMatch ? scoreMatch[1] : '0';
            row.rating_score = scoreNum;
            row.rating_stars = String(result.stars || 0);
            row.rating_level = result.is_level2 ? 'L2' : 'L1';
            row.rating = JSON.stringify(result);
            console.log(`[applyBulkAssessmentResults] Updated ${linkedinurl}: ${scoreNum}% (${result.stars}â˜…) ${row.rating_level}`);
            updatedCount++;
        } else {
            // If the review table doesn't contain this entry, try updating the Search table (user likely ran from Search tab)
            if (updateSearchTableRowWithResult(linkedinurl, result)) {
                console.log(`[applyBulkAssessmentResults] (fallback) Updated Search table row for ${linkedinurl}`);
                // Also update Upload CV button to View button after successful assessment
                updateUploadButtonToView(linkedinurl);
            } else {
                console.log('[applyBulkAssessmentResults] Row not found in pendingReviewRows or Search table for', linkedinurl);
            }
        }
    });

    if (updatedCount > 0) {
        console.log(`[applyBulkAssessmentResults] Re-rendering review table with ${updatedCount} updated scores`);
        try { renderAssessmentReviewTable(pendingReviewRows); } catch(e){ console.warn('renderAssessmentReviewTable failed', e); }
    } else {
        console.log('[applyBulkAssessmentResults] No matching rows found in current review table. Scores saved to database and may appear on next refresh.');
    }
}

/* Render function with defensive null checks */
function renderAssessmentReviewTable(rows) {
    const tbody = $id('reviewTableBody');
    if (!tbody) {
        // Defensive: review table is removed/hidden in the UI, avoid throwing errors.
        console.warn('[renderAssessmentReviewTable] reviewTableBody not present in DOM; skipping render.');
        return;
    }

    tbody.innerHTML = '';

    if (!rows || rows.length === 0) {
        tbody.innerHTML = `<tr><td colspan="7" style="text-align:center; padding:30px;"><span class="assessment-placeholder">No pending assessments found for current search results.</span></td></tr>`;
        return;
    }

    rows.forEach(r => {
        const tr = document.createElement('tr');
        tr.dataset.linkedinurl = r.linkedinurl || '';
        tr.dataset.normalized = r.normalized_linkedin || '';

        // Checkbox
        const tdCheck = document.createElement('td');
        tdCheck.className = 'checkbox-cell';
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.className = 'review-row-select';
        cb.addEventListener('change', updateBulkActionButtons);
        tdCheck.appendChild(cb);
        tr.appendChild(tdCheck);

        // Name
        const tdName = document.createElement('td');
        tdName.textContent = r.name || 'â€”';
        tr.appendChild(tdName);

        // Company
        const tdComp = document.createElement('td');
        tdComp.textContent = r.company || 'â€”';
        tr.appendChild(tdComp);

        // Job
        const tdJob = document.createElement('td');
        tdJob.textContent = r.jobtitle || 'â€”';
        tr.appendChild(tdJob);

        // Status
        const tdStatus = document.createElement('td');
        const badge = document.createElement('span');
        badge.className = 'status-badge pending';

        let statusText = 'Pending';
        let currentScore = 0;

        if (r.rating_score !== undefined && r.rating_score !== null && r.rating_score !== '') {
            statusText = 'Completed';
            badge.className = 'status-badge completed';
            currentScore = parseInt(r.rating_score) || 0;
        } else if (r.rating) {
            try {
                const robj = typeof r.rating === 'string' ? JSON.parse(r.rating) : r.rating;
                if (robj && robj.total_score) {
                    statusText = 'Completed';
                    badge.className = 'status-badge completed';
                    currentScore = parseInt(robj.total_score.replace('%','')) || 0;
                }
            } catch(_) {}
        }
        badge.textContent = statusText;
        tdStatus.appendChild(badge);
        tr.appendChild(tdStatus);

        // Score/Details
        const tdScore = document.createElement('td');
        if (r.rating_score !== undefined && r.rating_score !== null && r.rating_score !== '') {
            const score = r.rating_score;
            const starCount = parseInt(r.rating_stars) || 0;
            const level = r.rating_level || 'L1';
            // Generate visual star HTML
            let starsHtml = '';
            for (let i = 0; i < 5; i++) {
                starsHtml += `<span class="${i < starCount ? 'filled' : ''}">â˜…</span>`;
            }
            const levelText = level === 'L2' ? 'L2 Assessment' : 'L1 Assessment';
            tdScore.innerHTML = `<div style="font-size:11px;color:#6b7280;">${levelText}: <b>${score}%</b></div><div class="assessment-stars">${starsHtml}</div>`;
        } else if (r.rating) {
            try {
                const robj = typeof r.rating === 'string' ? JSON.parse(r.rating) : r.rating;
                if (robj && robj.total_score) {
                    const starCount = robj.stars || 0;
                    // Generate visual star HTML
                    let starsHtml = '';
                    for (let i = 0; i < 5; i++) {
                        starsHtml += `<span class="${i < starCount ? 'filled' : ''}">â˜…</span>`;
                    }
                    const assessmentLevel = robj.assessment_level || 'L1 Assessment';
                    tdScore.innerHTML = `<div style="font-size:11px;color:#6b7280;">${assessmentLevel}: <b>${robj.total_score}</b></div><div class="assessment-stars">${starsHtml}</div>`;
                } else {
                    tdScore.innerHTML = '<span style="color:#999; font-size:11px;">(Assessment pending)</span>';
                }
            } catch(e) { tdScore.innerHTML = '<span style="color:#ef4444;">Invalid Data</span>'; }
        } else {
            tdScore.innerHTML = '<span style="color:#999; font-size:11px;">(Assessment pending)</span>';
        }
        tr.appendChild(tdScore);

        // Actions
        const tdActions = document.createElement('td');
        const btnRefresh = document.createElement('button');
        btnRefresh.className = 'review-action-btn refresh';
        btnRefresh.textContent = 'ðŸ”„';
        btnRefresh.title = 'Refresh this profile data';
        btnRefresh.style.marginRight = '4px';
        btnRefresh.onclick = () => { if (typeof refreshSearchResultsInBackground === 'function') refreshSearchResultsInBackground(); };

        const btnView = document.createElement('button');
        btnView.className = 'review-action-btn view';
        btnView.textContent = 'View';
        btnView.onclick = () => {
            if (typeof refreshSearchResultsInBackground === 'function') refreshSearchResultsInBackground();
            switchTab('tab-details');
            const dummyTr = document.createElement('tr');
            dummyTr.dataset.linkedinurl = r.linkedinurl || '';
            dummyTr.innerHTML = `
                <td></td>
                <td>${r.name||''}</td>
                <td>${r.company||''}</td>
                <td>${r.jobtitle||''}</td>
                <td>${r.country||''}</td>
                <td>${r.linkedinurl||''}</td>
                <td data-field="experience" data-experience="${(r.experience||'').replace(/"/g,'&quot;')}"></td>
            `;
            if (window.__sv_namecard && typeof window.__sv_namecard.renderNameCardToTab === 'function') {
                try { 
                    window.__sv_namecard.renderNameCardToTab(dummyTr);
                    // Also cache the rating HTML if available so it displays
                    if(r.rating) {
                        try {
                            const robj = typeof r.rating === 'string' ? JSON.parse(r.rating) : r.rating;
                            if(robj && typeof robj === 'object' && robj.total_score != null && r.linkedinurl) {
                               let starsHtml = ''; 
                               const starCount = robj.stars || 0;
                               for (let i = 0; i < 5; i++) {
                                   starsHtml += `<span class="${i < starCount ? 'filled' : ''}">â˜…</span>`;
                               }
                               const assessmentHeader = `${robj.assessment_level||'Assessment'}: ${robj.total_score}`;
                               const html = `
                                 <div class="assessment-header">${escapeHtml(assessmentHeader)}</div>
                                 <div class="assessment-stars">${starsHtml}</div>
                                 <div class="assessment-comments">Comments: ${escapeHtml(robj.comments||'')}</div>
                               `;
                               window.__sv_namecard.setCardCache(r.linkedinurl, { assessmentHTML: html });
                               // Re-render to show it
                               window.__sv_namecard.renderNameCardToTab(dummyTr);
                            }
                        } catch(e) { console.warn('Assessment caching failed', e); }
                    }
                } catch(e){ console.warn('renderNameCardToTab failed', e); }
            }
        };

        const btnAccept = document.createElement('button');
        btnAccept.className = 'review-action-btn accept';
        btnAccept.textContent = 'âœ“';
        btnAccept.title = 'Accept & Transfer';
        btnAccept.onclick = () => finalizeBulk('accept', [r.linkedinurl]);

        const btnRebate = document.createElement('button');
        btnRebate.className = 'review-action-btn rebate';
        btnRebate.textContent = 'Rebate';
        btnRebate.title = 'Rebate/Delete';
        if (currentScore > 50) {
            btnRebate.disabled = true;
            btnRebate.title = 'Rebate disabled (Score > 50%)';
            btnRebate.style.opacity = '0.5';
            btnRebate.style.cursor = 'not-allowed';
        }
        btnRebate.onclick = () => { if (currentScore <= 50) finalizeBulk('rebate', [r.linkedinurl]); };

        tdActions.appendChild(btnRefresh);
        tdActions.appendChild(btnView);
        tdActions.appendChild(btnAccept);
        tdActions.appendChild(btnRebate);
        tr.appendChild(tdActions);

        tbody.appendChild(tr);
    });
}


function sortReviewTable() {
    if(!pendingReviewRows || pendingReviewRows.length === 0) return;
    
    // Sort logic
    pendingReviewRows.sort((a, b) => {
        let scoreA = 0; 
        if (a.rating) {
            try { const robj = typeof a.rating === 'string' ? JSON.parse(a.rating) : a.rating;
                  if (robj.total_score) scoreA = parseInt(robj.total_score.replace('%','')) || 0; } catch(_) {}
        }
        let scoreB = 0;
        if (b.rating) {
            try { const robj = typeof b.rating === 'string' ? JSON.parse(b.rating) : b.rating;
                  if (robj.total_score) scoreB = parseInt(robj.total_score.replace('%','')) || 0; } catch(_) {}
        }
        return scoreB - scoreA;
    });
    
    renderAssessmentReviewTable(pendingReviewRows);
}

function toggleAllReviewRows(cb) {
    document.querySelectorAll('.review-row-select').forEach(el => el.checked = cb.checked);
    updateBulkActionButtons();
}

function updateBulkActionButtons() {
    const count = document.querySelectorAll('.review-row-select:checked').length;
    document.getElementById('acceptSelectedBtn').disabled = count === 0;
    document.getElementById('rebateSelectedBtn').disabled = count === 0;
}

async function runBulkAssessment() {
    const uid = window.__SV_ACTIVE_USERID || '';
    if(!uid) return;
    
    const statusEl = document.getElementById('reviewStatus');
    const btn = document.getElementById('runBulkBtn');
    
    // All assessments use L2 (inference mode) by default
    const useL2 = true;
    
    // Gather pending linkedinurls (or send empty list to let server find all)
    // Here we'll let server find all pending for the user to ensure sync
    
    btn.disabled = true;
    if(statusEl) statusEl.textContent = 'Starting bulk L2 assessment...';
    
    try {
        const payload = {
            userid: uid,
            async: true,
            custom_weights: getActiveWeights(), // Send current weights
            assessment_level: 'L2'  // Always use L2 (inference mode)
        };
        
        const res = await fetch('/process/bulk_assess', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(payload),
            credentials: 'same-origin'
        });
        
        const data = await res.json();
        
        if (res.ok && data.job_id) {
            bulkJobId = data.job_id;
            document.getElementById('bulkProgressContainer').style.display = 'block';
            pollBulkJob();
        } else {
            if(statusEl) statusEl.textContent = 'Failed to start bulk job.';
            btn.disabled = false;
        }
    } catch(e) {
        console.error("Bulk start failed", e);
        if(statusEl) statusEl.textContent = 'Error starting bulk job.';
        btn.disabled = false;
    }
}

function pollBulkJob() {
    if(!bulkJobId) return;
    
    // NEW: Use EventSource for Server-Sent Events (SSE) - FASTER sync mechanism
    if(bulkPollEventSource) {
        bulkPollEventSource.close();
    }
    
    bulkPollEventSource = new EventSource(`/process/bulk_assess_stream/${bulkJobId}`);
    
    bulkPollEventSource.onmessage = (event) => {
        try {
            const data = JSON.parse(event.data);
            
            // Update UI
            const processed = data.processed || 0;
            const total = data.total || 1;
            const pct = Math.round((processed / total) * 100);
            
            document.getElementById('bulkProgressBar').style.width = pct + '%';
            document.getElementById('bulkProgressPercent').textContent = pct + '%';
            document.getElementById('reviewStatus').textContent = `Processing: ${processed}/${total}`;
            
            // Refresh list periodically to show completed items
            // Note: Assessment Review removed - refresh handled in Search Result tab
            
            if (data.status === 'done' || data.status === 'error') {
                bulkPollEventSource.close();
                bulkJobId = null;
                document.getElementById('runBulkBtn').disabled = false;
                document.getElementById('reviewStatus').textContent = data.status === 'done' ? 'Bulk Assessment Complete.' : 'Job finished with errors.';
                
                // Apply results from JSON file to the table
                if (data.status === 'done' && data.results && Array.isArray(data.results)) {
                    applyBulkAssessmentResults(data.results);
                    // Refresh the assessment review table to show updated scores
                    renderAssessmentReviewTable(pendingReviewRows);
                }
                
                // Set all assessed profiles to "view" state in Assessment Review tab
                if (data.status === 'done') {
                    setAllAssessedToViewState();
                }
                
                // Refresh removed - Assessment Review tab no longer exists
                
                // Auto-refresh Search Result tab while keeping user on current tab
                if (data.status === 'done') {
                    refreshSearchResultsInBackground();
                    
                    // *** FIX: Auto-refresh View Details tab if currently viewing a profile ***
                    autoRefreshViewDetailsIfActive();
                }
                
                // Show completion alert?
                // if(data.status === 'done') alert('Bulk Assessment Complete');
            }
        } catch(e) {
            console.warn("SSE message parse failed", e);
            bulkPollEventSource.close();
        }
    };
    
    bulkPollEventSource.onerror = (error) => {
        console.error("SSE connection error in pollBulkJob", error);
        bulkPollEventSource.close();
        bulkJobId = null;
        document.getElementById('runBulkBtn').disabled = false;
        document.getElementById('reviewStatus').textContent = 'Connection error during bulk assessment';
    };
}

function refreshSearchResultsInBackground() {
    // Refresh the Search Results tab data without switching to it
    // This ensures latest assessment results are visible when user switches back
    try {
        // Re-run the search to refresh the table with updated assessment data
        if (typeof performSearch === 'function') {
            performSearch();  // This will refresh the search results table
        }
    } catch(e) {
        console.warn("Failed to refresh search results in background", e);
    }
}

// Wrapper function for refreshData to maintain compatibility with code that calls it
function refreshData() {
    refreshSearchResultsInBackground();
}

function setAllAssessedToViewState() {
    // Set all rows in the Assessment Review tab that have assessments to "view" state
    const reviewRows = document.querySelectorAll('#reviewTableBody tr[data-linkedinurl]');
    reviewRows.forEach(row => {
        const statusCell = row.querySelector('td:nth-child(5)'); // Status column
        if (statusCell) {
            const currentStatus = statusCell.textContent.trim().toLowerCase();
            // If assessment is complete (has a score), set to view state
            const scoreCell = row.querySelector('td:nth-child(6)'); // Assessment Score column
            if (scoreCell && scoreCell.textContent.includes('%')) {
                statusCell.innerHTML = '<span style="color:#059669; font-weight:600;">âœ“ Ready to View</span>';
            }
        }
    });
}

async function finalizeBulk(action, specificList = null) {
    let urls = specificList;
    if (!urls) {
        urls = Array.from(document.querySelectorAll('.review-row-select:checked'))
                    .map(cb => cb.closest('tr').dataset.linkedinurl);
    }
    
    if (!urls || urls.length === 0) return;
    
    const label = action === 'accept' ? 'Accept & Transfer' : 'Rebate/Delete';
    if (!confirm(`${label} ${urls.length} profile(s)?`)) return;
    
    const statusEl = document.getElementById('reviewStatus');
    if(statusEl) statusEl.textContent = `Processing ${action}...`;
    
    // Process sequentially or batch if API supported
    // Reusing single record helpers loop for simplicity
    
    let successCount = 0;
    
    for (const url of urls) {
        try {
            if (action === 'accept') {
                // Use existing helper transferSingleRecordToMarket
                // We need to fetch context first
                const ctx = getRowContextForAnchor(url); 
                // Note: getRowContextForAnchor scrapes the MAIN search table. 
                // If items are only in Review tab, we might need data from pending rows.
                // Fallback: use data from pendingReviewRows array
                let recordData = pendingReviewRows.find(r => r.linkedinurl === url);
                
                // Construct payload
                const payload = {
                    name: recordData?.name || ctx.name,
                    company: recordData?.company || ctx.company,
                    role: recordData?.jobtitle || ctx.role,
                    country: recordData?.country || ctx.country,
                    linkedinurl: url,
                    rating: recordData?.rating || ctx.rating || '',
                    experience: recordData?.experience || ctx.experience || ''
                };
                
                const ok = await transferSingleRecordToMarket(payload);
                if (ok) successCount++;
                
            } else if (action === 'rebate') {
                // Rebate flow: Token +1, Delete Row, Token -1 (net 0 cost if purely deleting, or rebate logic)
                // Assuming rebate logic:
                // 1. Credit token (rebate)
                await applyTokenDelta(1);
                rebateTokens += 1;
                // 2. Delete
                await deleteBackendRow(url);
                // 3. Debit token (cleanup cost?) - logic in main script implies this dance.
                // Actually the prompt logic was: apply +1, update display, delete, apply -1.
                try { await applyTokenDelta(-1); } catch(e){}
                successCount++;
            }
        } catch(e) {
            console.error(`Error processing ${url}`, e);
        }
    }
    
    if(statusEl) statusEl.textContent = `${action} complete: ${successCount}/${urls.length}`;
    if(action === 'rebate') updateRebateTokenDisplay();
    refreshAccountTokens();
    // Refresh removed - Assessment Review tab no longer exists
}

// New functions for Search Result tab bulk assessment controls

// Helper function to clean unwanted characters from names
function cleanNameForUpload(name) {
    if (!name) return '';
    // Remove unwanted characters like Î´Ã¯Ã¿ and other special Unicode characters
    // Keep only letters, numbers, spaces, and common punctuation (.,'-/)
    return name.replace(/[^\p{L}\p{N}\s.,'\-\/]/gu, '').trim();
}

// Helper function to disable/enable all action buttons during bulk operations
function setSearchResultButtonsEnabled(enabled) {
    const buttons = [
        'bulkAssessmentBtn',
        'exportExcelBtn',
        'exportCsvBtn',
        'marketAnalysisBtn'
    ];
    
    buttons.forEach(btnId => {
        const btn = document.getElementById(btnId);
        if (btn) {
            btn.disabled = !enabled;
        }
    });
}

async function runBulkAssessmentFromSearch() {
    const uid = window.__SV_ACTIVE_USERID || '';
    if(!uid) return;
    
    // Auto-detect all profiles in the table (no manual selection required)
    const allRows = document.querySelectorAll('#sourcingTable tbody tr');
    const linkedinurls = [];
    const alreadyAssessedUrls = [];
    
    allRows.forEach(tr => {
        if (tr.dataset.linkedinurl) {
            const linkedinurl = tr.dataset.linkedinurl;
            
            // Check if profile already has an assessment score
            const hasAssessment = tr.classList.contains('assessment-complete') || 
                                  (tr.dataset.rating && tr.dataset.rating !== 'null' && tr.dataset.rating !== '{}');
            
            if (hasAssessment) {
                alreadyAssessedUrls.push(linkedinurl);
                // Immediately transition button to View for already-assessed profiles
                updateUploadButtonToView(linkedinurl);
            } else {
                linkedinurls.push(linkedinurl);
            }
        }
    });
    
    // Check if there are any profiles to assess
    if (linkedinurls.length === 0) {
        if (alreadyAssessedUrls.length > 0) {
            alert(`All ${alreadyAssessedUrls.length} profiles already have assessments. No new assessments needed.`);
        } else {
            alert('No profiles found to assess');
        }
        return;
    }
    
    const statusEl = document.getElementById('status');
    const btn = document.getElementById('bulkAssessmentBtn');  // Updated to new combined button
    const progressContainer = document.getElementById('searchBulkProgressContainer');
    const progressBar = document.getElementById('searchBulkProgressBar');
    const progressPercent = document.getElementById('searchBulkProgressPercent');
    
    // All assessments use L2 (inference mode) by default
    const useL2 = true;
    
    console.log(`[Bulk Assessment] Assessment Level: L2`);
    console.log(`[Bulk Assessment] Profiles to assess: ${linkedinurls.length}, Already assessed: ${alreadyAssessedUrls.length}`);
    
    // Disable all buttons during bulk assessment
    setSearchResultButtonsEnabled(false);
    
    if (btn) btn.disabled = true;
    const totalProfiles = linkedinurls.length + alreadyAssessedUrls.length;
    const statusMsg = `Starting bulk L2 assessment (${linkedinurls.length}/${totalProfiles} profiles, ${alreadyAssessedUrls.length} already assessed)...`;
    if(statusEl) setStatus(statusMsg, 'info');
    if(progressContainer) progressContainer.style.display = 'block';
    
    try {
        const payload = {
            userid: uid,
            linkedinurls: linkedinurls,
            async: true,
            custom_weights: getActiveWeights(),
            assessment_level: 'L2'  // Always use L2 (inference mode)
        };
        
        console.log('[Bulk Assessment] Payload:', JSON.stringify(payload, null, 2));
        
        const res = await fetch('/process/bulk_assess', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(payload),
            credentials: 'same-origin'
        });
        
        const data = await res.json();
        
        if (res.ok && data.job_id) {
            // Use Server-Sent Events (SSE) for real-time progress updates (FASTER than polling)
            const jobId = data.job_id;
            
            // Animation timing constants
            const BUTTON_TRANSITION_DELAY_MS = 100; // Delay between each button transition for smooth animation
            const FINAL_PROGRESS_DELAY_MS = 500; // Extra delay after transitions before hiding progress bar
            const MAX_PROGRESS_DURING_PROCESSING = 95; // Cap progress at 95% until buttons complete transition
            const TABLE_RENDER_DELAY_MS = 1000; // Delay to allow table rendering to complete before starting assessment
            
            // Animate all Upload CV buttons to "Analyzing..." state at start
            linkedinurls.forEach(url => animateButtonDuringBulkAssessment(url, 'analyzing'));
            
            let processedCount = 0;
            
            // NEW: Use EventSource for Server-Sent Events (SSE) - FASTER sync mechanism
            const eventSource = new EventSource(`/process/bulk_assess_stream/${jobId}`);
            
            eventSource.onmessage = (event) => {
                try {
                    const pollData = JSON.parse(event.data);
                    
                    if (pollData.status === 'done' || pollData.status === 'failed') {
                        eventSource.close();
                        
                        // Re-enable all buttons when bulk assessment completes
                        setSearchResultButtonsEnabled(true);
                        if (btn) btn.disabled = false;
                        
                        if (pollData.status === 'done') {
                            if(statusEl) setStatus('Bulk assessment complete!', 'success');
                            
                            // Apply results from JSON file to the table
                            if (pollData.results && Array.isArray(pollData.results)) {
                                applyBulkAssessmentResults(pollData.results);
                                // Refresh the assessment review table to show updated scores
                                renderAssessmentReviewTable(pendingReviewRows);
                                
                                // Ensure all buttons transition to View after results are applied
                                // Skip profiles with errors (e.g., no CV uploaded)
                                pollData.results.forEach((item, index) => {
                                    if (item.result && !item.result.error) {
                                        // Delay each button transition slightly for smooth animation
                                        setTimeout(() => {
                                            animateButtonDuringBulkAssessment(item.linkedinurl, 'view');
                                        }, index * BUTTON_TRANSITION_DELAY_MS);
                                    } else {
                                        // For profiles with errors, reset button to original state
                                        setTimeout(() => {
                                            const selUrl = (window.CSS && CSS.escape) ? CSS.escape(item.linkedinurl) : item.linkedinurl.replace(/"/g,'\\"');
                                            const tr = document.querySelector(`#sourcingTable tbody tr[data-linkedinurl="${selUrl}"]`);
                                            if (tr) {
                                                const credentialCell = tr.querySelector('td[data-field="linkedinurl"], td[data-field="credential"]');
                                                if (credentialCell) {
                                                    const uploadBtn = credentialCell.querySelector('button');
                                                    if (uploadBtn) {
                                                        uploadBtn.textContent = 'Upload CV';
                                                        uploadBtn.disabled = false;
                                                        uploadBtn.style.opacity = '1';
                                                    }
                                                }
                                            }
                                        }, index * BUTTON_TRANSITION_DELAY_MS);
                                    }
                                });
                                
                                // Hide progress bar only after all buttons have transitioned
                                setTimeout(() => {
                                    if(progressContainer) progressContainer.style.display = 'none';
                                    if(progressBar) progressBar.style.width = '100%';
                                    if(progressPercent) progressPercent.textContent = '100%';
                                    
                                    // Auto-refresh data and View Details after loading bar animation completes
                                    // NOTE: This delay is intentional and occurs AFTER progress animation
                                    // Total delay = BUTTON_TRANSITION_DELAY * results + FINAL_PROGRESS_DELAY + CACHE_UPDATE_DELAY
                                    setTimeout(() => {
                                        if (typeof refreshData === 'function') {
                                            refreshData();
                                        }
                                        
                                        // *** FIX: Auto-refresh View Details tab if currently viewing a profile ***
                                        autoRefreshViewDetailsIfActive();
                                    }, CACHE_UPDATE_DELAY_MS); // Delay to ensure all cache operations complete before refreshing UI
                                }, pollData.results.length * BUTTON_TRANSITION_DELAY_MS + FINAL_PROGRESS_DELAY_MS);
                            } else {
                                if(progressContainer) progressContainer.style.display = 'none';
                            }
                        } else {
                            if(statusEl) setStatus('Bulk assessment failed', 'error');
                            if(progressContainer) progressContainer.style.display = 'none';
                        }
                    } else {
                        // Update progress - but cap at 95% until all buttons transition
                        const rawProgress = pollData.progress || 0;
                        const progress = Math.min(rawProgress, MAX_PROGRESS_DURING_PROCESSING);
                        if(progressBar) progressBar.style.width = progress + '%';
                        if(progressPercent) progressPercent.textContent = progress + '%';
                        
                        // Animate buttons to "Processing..." as they get processed
                        const newProcessed = pollData.processed || 0;
                        if (newProcessed > processedCount) {
                            for (let i = processedCount; i < newProcessed && i < linkedinurls.length; i++) {
                                animateButtonDuringBulkAssessment(linkedinurls[i], 'processing');
                            }
                            processedCount = newProcessed;
                        }
                    }
                } catch(e) {
                    console.error('SSE message parse failed', e);
                    eventSource.close();
                    
                    // Re-enable all buttons on error
                    setSearchResultButtonsEnabled(true);
                    if (btn) btn.disabled = false;
                    if(progressContainer) progressContainer.style.display = 'none';
                }
            };
            
            eventSource.onerror = (error) => {
                console.error('SSE connection error', error);
                eventSource.close();
                
                // Re-enable all buttons on error
                setSearchResultButtonsEnabled(true);
                if (btn) btn.disabled = false;
                if(progressContainer) progressContainer.style.display = 'none';
                if(statusEl) setStatus('Connection error during bulk assessment', 'error');
            };
        } else {
            if(statusEl) setStatus('Failed to start bulk job.', 'error');
            
            // Re-enable all buttons on failure
            setSearchResultButtonsEnabled(true);
            if (btn) btn.disabled = false;
            if(progressContainer) progressContainer.style.display = 'none';
        }
    } catch(e) {
        console.error("Bulk start failed", e);
        if(statusEl) setStatus('Error starting bulk job.', 'error');
        
        // Re-enable all buttons on exception
        setSearchResultButtonsEnabled(true);
        if (btn) btn.disabled = false;
        if(progressContainer) progressContainer.style.display = 'none';
    }
}

async function finalizeBulkFromSearch(action) {
    // Get selected rows that have assessments
    const selectedCheckboxes = document.querySelectorAll('#sourcingTable .row-select:checked');
    const urls = [];
    
    selectedCheckboxes.forEach(cb => {
        const tr = cb.closest('tr');
        if (tr && tr.dataset.linkedinurl) {
            // Check if row has assessment (has View Details button)
            const viewBtn = tr.querySelector('.view-btn.assessment-complete');
            if (viewBtn) {
                urls.push(tr.dataset.linkedinurl);
            }
        }
    });
    
    if (urls.length === 0) {
        alert('Please select assessed profiles to finalize');
        return;
    }
    
    const label = action === 'accept' ? 'Accept & Transfer' : 'Rebate/Delete';
    if (!confirm(`${label} ${urls.length} profile(s)?`)) return;
    
    const statusEl = document.getElementById('status');
    if(statusEl) setStatus(`Processing ${action}...`, 'info');
    
    let successCount = 0;
    
    for (const url of urls) {
        try {
            if (action === 'accept') {
                // Get row data
                const tr = document.querySelector(`tr[data-linkedinurl="${url}"]`);
                if (!tr) continue;
                
                const name = tr.querySelector('td[data-field="name"]')?.textContent.trim() || '';
                const company = tr.querySelector('td[data-field="company"]')?.textContent.trim() || '';
                const jobtitle = tr.querySelector('td[data-field="jobtitle"]')?.textContent.trim() || '';
                const country = tr.querySelector('td[data-field="country"]')?.textContent.trim() || '';
                
                // Get assessment data from cache
                let rating = '';
                let experience = '';
                try {
                    if (window.__sv_namecard) {
                        const cached = window.__sv_namecard.getCardCache(url);
                        if (cached) {
                            rating = cached.assessmentHTML || '';
                            experience = cached.experience || '';
                        }
                    }
                } catch(e) {}
                
                const payload = {
                    name, company, role: jobtitle, country, linkedinurl: url,
                    rating, experience
                };
                
                const ok = await transferSingleRecordToMarket(payload);
                if (ok) successCount++;
                
            } else if (action === 'rebate') {
                // Rebate flow
                await applyTokenDelta(1);
                rebateTokens += 1;
                await deleteBackendRow(url);
                try { await applyTokenDelta(-1); } catch(e){}
                successCount++;
            }
        } catch(e) {
            console.error(`Error processing ${url}`, e);
        }
    }
    
    if(statusEl) setStatus(`${action} complete: ${successCount}/${urls.length}`, 'success');
    if(action === 'rebate') updateRebateTokenDisplay();
    refreshAccountTokens();
    loadRows(currentPage); // Refresh the table
}

async function finalizeIndividualAssessment(linkedinurl, action) {
    if (!linkedinurl) return;
    
    const label = action === 'accept' ? 'Accept & Transfer' : 'Rebate/Delete';
    if (!confirm(`${label} this profile?`)) return;
    
    const statusEl = document.getElementById('status');
    if(statusEl) setStatus(`Processing ${action}...`, 'info');
    
    try {
        if (action === 'accept') {
            // Get row data
            const tr = document.querySelector(`tr[data-linkedinurl="${linkedinurl}"]`);
            if (!tr) {
                if(statusEl) setStatus('Row not found', 'error');
                return;
            }
            
            const name = tr.querySelector('td[data-field="name"]')?.textContent.trim() || '';
            const company = tr.querySelector('td[data-field="company"]')?.textContent.trim() || '';
            const jobtitle = tr.querySelector('td[data-field="jobtitle"]')?.textContent.trim() || '';
            const country = tr.querySelector('td[data-field="country"]')?.textContent.trim() || '';
            
            // Get assessment data from cache
            let rating = '';
            let experience = '';
            try {
                if (window.__sv_namecard) {
                    const cached = window.__sv_namecard.getCardCache(linkedinurl);
                    if (cached) {
                        rating = cached.assessmentHTML || '';
                        experience = cached.experience || '';
                    }
                }
            } catch(e) {}
            
            const payload = {
                name, company, role: jobtitle, country, linkedinurl,
                rating, experience
            };
            
            const ok = await transferSingleRecordToMarket(payload);
            if (ok) {
                if(statusEl) setStatus('Profile accepted and transferred!', 'success');
                loadRows(currentPage); // Refresh the table
            } else {
                if(statusEl) setStatus('Transfer failed', 'error');
            }
            
        } else if (action === 'rebate') {
            // Rebate flow
            await applyTokenDelta(1);
            rebateTokens += 1;
            await deleteBackendRow(linkedinurl);
            try { await applyTokenDelta(-1); } catch(e){}
            
            if(statusEl) setStatus('Profile rebated and deleted', 'success');
            updateRebateTokenDisplay();
            refreshAccountTokens();
            loadRows(currentPage); // Refresh the table
        }
    } catch(e) {
        console.error(`Error processing individual ${action}`, e);
        if(statusEl) setStatus(`Error: ${e.message}`, 'error');
    }
}

</script>

<script>
(function authGateAndBanner(){
  try{
    function readCookie(name){
      const m = document.cookie && document.cookie.match(new RegExp('(?:^|\\s*)' + name + '=([^;]+)'));
      return m && m[1] ? decodeURIComponent(m[1]) : null;
    }
    function getFirstNonEmpty(){
      for(let i=0;i<arguments.length;i++){ const v=arguments[i]; if(v && String(v).trim()) return String(v).trim(); }
      return "";
    }
    function updateRoleTagContextFrom(val){
      try{
        const roleTagValueEl = document.getElementById('roleTagValue');
        if (!roleTagValueEl) return;
        
        if (!val || !String(val).trim()) {
          roleTagValueEl.textContent = 'â€”';
          return;
        }
        
        const roleTagStr = String(val).trim();
        
        // Split by comma and create bubble tags for each role
        const roles = roleTagStr.split(',').map(role => role.trim()).filter(role => role);
        
        if (roles.length === 0) {
          roleTagValueEl.textContent = 'â€”';
          return;
        }
        
        // Clear existing content
        roleTagValueEl.innerHTML = '';
        
        // Create bubble tag for each role
        roles.forEach(role => {
          const bubble = document.createElement('span');
          bubble.className = 'role-bubble';
          bubble.textContent = role;
          roleTagValueEl.appendChild(bubble);
        });
      }catch(_){}
    }
    function setAccountTokenDisplay(v){
      const el=document.getElementById('accountTokenCounter');
      if(el) el.textContent='Account Tokens: ' + (v==null?'â€”':v);
    }
    async function fetchAccountTokens(username){
      if(!username) return;
      try{
        const r=await fetch('/user/resolve?username=' + encodeURIComponent(username), {credentials:'same-origin'});
        if(!r.ok) return;
        const data=r.json ? await r.json() : null;
        if(data && typeof data.token !== 'undefined'){
          sessionStorage.setItem('account_token', data.token);
          localStorage.setItem('account_token', data.token);
          setAccountTokenDisplay(data.token);
          syncMetricTokens(data.token);
        }
      }catch(_){}
    }
    function persistRoleTag(val){
      try{
        sessionStorage.setItem('role_tag', val||'');
        localStorage.setItem('role_tag', val||'');
      }catch(_){}
      updateRoleTagContextFrom(val||'');
    }
    const storedUsername = getFirstNonEmpty(sessionStorage.getItem('username'), localStorage.getItem('username'), readCookie('username'));
    const storedUserid   = getFirstNonEmpty(sessionStorage.getItem('userid'),   localStorage.getItem('userid'),   readCookie('userid'));
    if(!storedUsername || !storedUserid){
      const next = encodeURIComponent(location.pathname + location.search + location.hash);
      location.replace('/login.html?next=' + next);
      return;
    }
    window.__SV_ACTIVE_USERNAME = storedUsername;
    window.__SV_ACTIVE_USERID   = storedUserid;
    try{
      ['role_tag','account_token'].forEach(k=>{
        sessionStorage.removeItem(k);
        localStorage.removeItem(k);
      });
    }catch(_){}
    updateRoleTagContextFrom('(loading)');
    setAccountTokenDisplay('â€¦');
    let fullname = getFirstNonEmpty(sessionStorage.getItem('fullname'), localStorage.getItem('fullname'), readCookie('fullname'));

    function _getInitials(name, fallback){
      const src = (name && String(name).trim()) ? name.trim() : (fallback||'');
      const parts = src.split(/\s+/).filter(Boolean);
      if(parts.length === 0) return (fallback||'U').slice(0,1).toUpperCase();
      if(parts.length === 1) return parts[0].slice(0,2).toUpperCase();
      return (parts[0].slice(0,1) + parts[1].slice(0,1)).toUpperCase();
    }

    function buildBanner(nameForWelcome){
      const bar=document.createElement('div');
      bar.setAttribute('id','sessionBanner');
      bar.style.cssText = [
        'display:flex','align-items:center','justify-content:space-between',
        'padding:12px 16px','margin:0 0 12px 0','border-radius:10px',
        'background:#ffffff','border:1px solid #d0d7de',
        'box-shadow:0 4px 16px -8px rgba(31,111,235,0.25)','gap:12px'
      ].join(';');

      const left = document.createElement('div');
      left.style.cssText = 'display:flex;align-items:center;gap:12px';

      const avatar = document.createElement('div');
      avatar.style.cssText = [
        'width:44px','height:44px','border-radius:10px',
        'background:linear-gradient(180deg,#1f6feb,#143d8c)',
        'display:flex','align-items:center','justify-content:center',
        'color:#fff','font-weight:700','font-size:16px',
        'box-shadow:0 4px 12px rgba(31,111,235,0.35)'
      ].join(';');
      const initials = _getInitials(nameForWelcome || storedUsername, storedUsername);
      avatar.textContent = initials;

      const textWrap = document.createElement('div');
      textWrap.style.cssText = 'display:flex;flex-direction:column;line-height:1';

      const welcome = document.createElement('div');
      welcome.style.cssText = 'font-weight:700;color:#1f2328;font-size:15px';
      welcome.textContent = 'Welcome, ' + (nameForWelcome || storedUsername);

      const sub = document.createElement('div');
      sub.style.cssText = 'font-size:12px;color:#57606a;margin-top:3px';
      sub.textContent = storedUsername || '';

      textWrap.appendChild(welcome);
      textWrap.appendChild(sub);

      left.appendChild(avatar);
      left.appendChild(textWrap);

      const right = document.createElement('div');
      right.style.cssText = 'display:flex;align-items:center;gap:8px';

      const logoutBtn = document.createElement('button');
      logoutBtn.type = 'button';
      logoutBtn.textContent = 'Logout';
      logoutBtn.style.cssText = [
        'background:#f6f8fa','color:#1f2328','border:1px solid #d0d7de',
        'padding:8px 12px','border-radius:8px','font-weight:700','cursor:pointer','box-shadow:none'
      ].join(';');

      logoutBtn.addEventListener('click', function(){
        try{
          ['username','userid','fullname','role_tag','account_token'].forEach(k=>{
            sessionStorage.removeItem(k); localStorage.removeItem(k);
            document.cookie = k + '=; Max-Age=0; path=/';
          });
        }catch(_){}
        // snipper cleanup removed
        location.replace('/login.html');
      });

      right.appendChild(logoutBtn);
      bar.appendChild(left);
      bar.appendChild(right);
      document.body.insertBefore(bar, document.body.firstChild);
    }

    function processUserResolve(data){
      if(data){
        if(data.fullname){
          try{
            sessionStorage.setItem('fullname', data.fullname);
            localStorage.setItem('fullname', data.fullname);
            document.cookie='fullname=' + encodeURIComponent(data.fullname) + '; path=/; max-age=2592000';
          }catch(_){}
        }
        if(typeof data.role_tag !== 'undefined'){
          persistRoleTag(data.role_tag||'');
        }
        if(typeof data.token !== 'undefined'){
          sessionStorage.setItem('account_token', data.token);
            localStorage.setItem('account_token', data.token);
            setAccountTokenDisplay(data.token);
            syncMetricTokens(data.token);
        }
      }
    }

    if(fullname){
      buildBanner(fullname);
      fetch('/user/resolve?username=' + encodeURIComponent(storedUsername), {credentials:'same-origin'})
        .then(r=>r.ok?r.json():null)
        .then(processUserResolve)
        .catch(()=>{});
    } else {
      fetch('/user/resolve?username=' + encodeURIComponent(storedUsername), { credentials:'same-origin' })
        .then(r=>r.ok?r.json():null)
        .then(data=>{
          buildBanner(data && data.fullname ? data.fullname : storedUsername);
          processUserResolve(data||{});
        })
        .catch(()=>{
          buildBanner(storedUsername);
          fetchAccountTokens(storedUsername);
        });
    }
  }catch(e){
    try{ location.replace('/login.html'); }catch(_){}
  }
})();

const API_LIST   = '/sourcing/list';
const API_UPDATE = '/sourcing/update';
const API_DELETE = '/sourcing/delete';
const API_MARKET = '/sourcing/market_analysis';
// Snipper-related constants removed
const GEMINI_EXTRACT_API = '/gemini/company_job_extract';
const GEMINI_REBATE_VALIDATE_API = '/gemini/rebate_validate';
const TOKEN_APPLY_API = '/user/token_apply';
const TOKEN_UPDATE_API = '/user/token_update';
const APPEAL_SAVE_API = '/sourcing/update';
// SNIPPER_CLEANUP_API removed
const API_UPLOAD_CV = '/process/upload_cv'; 
const API_DOWNLOAD_CV = '/process/download_cv'; 
// SOURCE OF TRUTH: CV Column - Parses CV from process.cv column exclusively via Gemini
// Extracts skillset and employment history format: "Job Title, Company, StartYear to EndYear"
// OR "Job Title, Company, StartYear to present" (for current positions)
const API_PARSE_CV_AND_UPDATE = '/process/parse_cv_and_update'; 
const API_SCAN_AND_UPLOAD = '/process/scan_and_upload_cvs';
const API_UPLOAD_MULTIPLE = '/process/upload_multiple_cvs'; // New bulk endpoint

const PROCESS_GEO_API = 'http://127.0.0.1:8091/process/geography'; 

// No-op stubs for removed snipper functions (keeps existing code safe)
const tableBody   = document.getElementById('tableBody');
const statusEl    = document.getElementById('status');
// Delete button removed per requirements
// const deleteBtn   = document.getElementById('deleteBtn');
// Select All checkbox removed per requirements
// const selectAllCb = document.getElementById('selectAll');
const reloadBtn   = document.getElementById('reloadBtn');
const marketBtn   = document.getElementById('marketAnalysisBtn');
const bulkAssessmentBtn = document.getElementById('bulkAssessmentBtn');
const bulkDirInput = document.getElementById('bulkDirInput');

let rowsData = [];
let pendingUpdate = new Map();
let rebateTokens = 0;
const TOTAL_SEARCH_TOKEN_BASE = 5000;
let currentPage = 1;
let totalRowCount = 0;
const PAGE_SIZE = 15;

let excelBlobUrl = null;
function deleteClientExcelBlob(){
  if(excelBlobUrl){
    try{ URL.revokeObjectURL(excelBlobUrl); }catch(_){}
    excelBlobUrl = null;
  }
}
function disableActionButton(btn){
  if(btn){
    btn.disabled = true;
    btn.title = 'Disabled after action (one-time use)';
  }
}

function updateRebateTokenDisplay(){
  const el = document.getElementById('rebateTokenCounter');
  if(el) el.textContent = 'Rebate Tokens: ' + rebateTokens;
}
updateRebateTokenDisplay();

function refreshAccountTokens(){
  const username = window.__SV_ACTIVE_USERNAME || '';
  if(!username) return;
  fetch('/user/resolve?username=' + encodeURIComponent(username))
    .then(r=>r.ok?r.json():null)
    .then(data=>{
      if(data && typeof data.token !== 'undefined'){
        sessionStorage.setItem('account_token', data.token);
        localStorage.setItem('account_token', data.token);
        const el=document.getElementById('accountTokenCounter');
        if(el) el.textContent='Account Tokens: ' + data.token;
        syncMetricTokens(data.token);
      }
    })
    .catch(()=>{});
}

function setStatus(msg, kind='info') {
  statusEl.textContent = msg;
  statusEl.className = kind === 'error' ? 'error' : (kind === 'success' ? 'success' : '');
}

let __metricsInitialized = false;
let __prevResults = null;
async function persistFinalToken(_left){}
function schedulePersist(_left){}
function syncMetricTokens(backendToken){
  const totalTokenEl = document.getElementById('totalToken');
  const tokensLeftEl = document.getElementById('tokensLeft');
  const totalResultsEl = document.getElementById('totalResults');
  const effectiveTotal = typeof totalRowCount === 'number' && totalRowCount > 0 ? totalRowCount : rowsData.length;
  totalResultsEl.textContent = String(effectiveTotal);
  const acctToken = Number(backendToken);
  let leftComputed = 0;
  if(!isNaN(acctToken) && acctToken >= 0){
    totalTokenEl.textContent = String(acctToken);
    leftComputed = Math.max(0, acctToken - effectiveTotal);
    tokensLeftEl.textContent = String(leftComputed);
  } else {
    totalTokenEl.textContent = String(TOTAL_SEARCH_TOKEN_BASE);
    leftComputed = Math.max(0, TOTAL_SEARCH_TOKEN_BASE - effectiveTotal);
    tokensLeftEl.textContent = String(leftComputed);
  }
  __prevResults = effectiveTotal;
  if (!__metricsInitialized) __metricsInitialized = true;
}

function updateDisplayCounters() {
  const effectiveTotal = totalRowCount || rowsData.length;
  document.getElementById('totalResults').textContent = String(effectiveTotal);
  const backendToken = sessionStorage.getItem('account_token') || localStorage.getItem('account_token');
  syncMetricTokens(backendToken);
}

function adjustCountersAfterDeletion(deletedCount) {
  if (deletedCount > 0) updateDisplayCounters();
}

function showDeleteIfNeeded() {
  // Delete button functionality removed per requirements
  // const anyChecked = [...document.querySelectorAll('.row-select:checked')].length > 0;
  // deleteBtn.style.display = anyChecked ? 'inline-block' : 'none';
  
  // Also update bulk action buttons
  const acceptBtn = document.getElementById('searchAcceptSelectedBtn');
  const rebateBtn = document.getElementById('searchRebateSelectedBtn');
  
  // Count how many selected rows have assessments
  let assessedCount = 0;
  document.querySelectorAll('.row-select:checked').forEach(cb => {
    const tr = cb.closest('tr');
    if (tr && tr.querySelector('.view-btn.assessment-complete')) {
      assessedCount++;
    }
  });
  
  if (acceptBtn) acceptBtn.disabled = assessedCount === 0;
  if (rebateBtn) rebateBtn.disabled = assessedCount === 0;
}

function getDisabledDetailRows(){
  try{
    const raw = localStorage.getItem('sv_disabled_detail_rows');
    if(!raw) return [];
    const arr = JSON.parse(raw);
    return Array.isArray(arr) ? arr : [];
  }catch(_){ return []; }
}
function persistDisabledDetailRow(link){
  if(!link) return;
  try{
    const arr = getDisabledDetailRows();
    if(!arr.includes(link)){
      arr.push(link);
      localStorage.setItem('sv_disabled_detail_rows', JSON.stringify(arr));
    }
  }catch(_){}
}
function isRowDetailDisabled(link){
  return getDisabledDetailRows().includes(link);
}

function getCompletedDetailRows(){
  try{
    const raw = localStorage.getItem('sv_completed_detail_rows');
    if(!raw) return [];
    const arr = JSON.parse(raw);
    return Array.isArray(arr) ? arr : [];
  }catch(_){ return []; }
}
function persistCompletedDetailRow(link){
  if(!link) return;
  try{
    const arr = getCompletedDetailRows();
    if(!arr.includes(link)){
      arr.push(link);
      localStorage.setItem('sv_completed_detail_rows', JSON.stringify(arr));
    }
  }catch(_){}
}
function isRowDetailCompleted(link){
  return getCompletedDetailRows().includes(link);
}

async function getProcessGeography(linkedinurl) {
  if (!linkedinurl || !String(linkedinurl).trim()) {
    console.warn('getProcessGeography called with empty linkedinurl:', linkedinurl);
    return null;
  }
  const original = String(linkedinurl).split('?')[0].trim();
  let normalized = '';
  try {
    const u = new URL(original, window.location.origin);
    normalized = (u.pathname || '').toLowerCase().replace(/\/+$/, '');
  } catch (_) {
    normalized = original.replace(/^https?:\/\/[^/]+/i, '').toLowerCase().replace(/\/+$/, '');
  }

  /* AFFECTED: Check local data_sorter reference first if loaded */
  if (_dataSorterReference) {
      // Logic to resolve against data_sorter logic if applicable
      // For simple mapping, we could infer it here if we have title/company context passed or available.
      // But getProcessGeography takes a URL. It fetches data.
      // We should apply reference logic AFTER fetching the basic data to augment it.
  }

  // Constants for retry logic - defined outside tryFetch for performance
  // Using linear backoff (1s, 2s, 3s) instead of exponential (1s, 2s, 4s)
  // Linear backoff is gentler on the server and provides adequate retry spacing for transient errors
  const MAX_RETRIES = 3;
  const RETRY_DELAY_MS = 1000;

  const tryFetch = async (val, retryCount = 0) => {
    if (!val) return null;
    const url = PROCESS_GEO_API + '?linkedin=' + encodeURIComponent(val);
    
    try {
      const res = await fetch(url, { credentials: 'omit', cache: 'no-store' });
      if (!res.ok) {
        // For 404/400 errors, don't retry - data doesn't exist
        if (res.status === 404 || res.status === 400) return null;
        
        // For server errors (5xx) or transient errors, retry
        if (res.status >= 500 && retryCount < MAX_RETRIES) {
          console.warn(`[View Details] Server error ${res.status}, retrying (${retryCount + 1}/${MAX_RETRIES})...`);
          await new Promise(resolve => setTimeout(resolve, RETRY_DELAY_MS * (retryCount + 1)));
          return tryFetch(val, retryCount + 1);
        }
        
        return null;
      }
      const data = await res.json().catch(()=>null);
      if (!data) return null;
      
      let geographic = (data.geographic || data.region || data.geography || '').toString().trim();
      let country = (data.country || data.nation || '').toString().trim();
      let seniority = (data.seniority || data.level || '').toString().trim();
      let jobFamily = (data.jobfamily || data.job_family || data.family || '').toString().trim();
      
      /* AFFECTED: Reference Data Sorter JSON logic override */
      if (_dataSorterReference && data.jobtitle) {
          const ref = getReferenceMapping(data.jobtitle);
          if (ref) {
              if (ref.family) jobFamily = ref.family;
              if (ref.seniority) seniority = ref.seniority;
              if (ref.geographic) geographic = ref.geographic;
          }
      }

      // IMPORTANT: We will treat 'sector' separately (the database/source may populate it)
      const sector = (data.sector || '').toString().trim();
      const cv = data.cv; 
      const exp = (data.exp || data.total_years || '').toString().trim();
      const education = (data.education || '').toString().trim();
      const experience = (data.experience || '').toString().trim();

      let skillset = data.skillset;
      if (typeof skillset === 'string') {
        // Try JSON parse first (for JSON array strings like '["Python", "Java"]')
        try {
          const parsed = JSON.parse(skillset);
          if (Array.isArray(parsed)) {
            skillset = parsed;
          } else {
            skillset = skillset.split(/[,|]/).map(s => s.trim()).filter(Boolean);
          }
        } catch (e) {
          // Fallback to split if not valid JSON
          skillset = skillset.split(/[,|]/).map(s => s.trim()).filter(Boolean);
        }
      }
      if (Array.isArray(skillset)) {
        skillset = skillset.map(s => s.toString().trim()).filter(Boolean);
      } else {
        skillset = [];
      }

      let product = data.product;
      if (typeof product === 'string') {
        // Try JSON parse first (for JSON array strings)
        try {
          const parsed = JSON.parse(product);
          if (Array.isArray(parsed)) {
            product = parsed;
          } else {
            product = product.split(/[,|]/).map(s => s.trim()).filter(Boolean);
          }
        } catch (e) {
          // Fallback to split if not valid JSON
          product = product.split(/[,|]/).map(s => s.trim()).filter(Boolean);
        }
      }
      if (Array.isArray(product)) {
        product = product.map(s => s.toString().trim()).filter(Boolean);
      } else {
        product = [];
      }

      if (!geographic && !country && !seniority && !jobFamily && !sector && !skillset.length && !product.length && !cv && !exp && !education && !experience) return null;
      // include tenure if backend returns it
      const tenure = (typeof data.tenure !== 'undefined') ? data.tenure : undefined;
      
      // Parse vskillset if available
      let vskillset = data.vskillset;
      if (typeof vskillset === 'string') {
        try {
          vskillset = JSON.parse(vskillset);
          if (!Array.isArray(vskillset)) {
            vskillset = [];
          }
        } catch (e) {
          vskillset = [];
        }
      } else if (!Array.isArray(vskillset)) {
        vskillset = [];
      }
      
      return { geographic: geographic || '', country: country || '', seniority, job_family: jobFamily, sector, skillset, product, cv, exp, education, experience, tenure, vskillset };
    } catch (e) {
      console.error('[View Details] PROCESS_GEO_API fetch error:', e);
      // Retry for network errors
      if ((e.name === 'TypeError' || e.message.includes('network')) && retryCount < MAX_RETRIES) {
        console.warn(`[View Details] Network error, retrying (${retryCount + 1}/${MAX_RETRIES})...`);
        await new Promise(resolve => setTimeout(resolve, RETRY_DELAY_MS * (retryCount + 1)));
        return tryFetch(val, retryCount + 1);
      }
      return null;
    }
  };

  let out = await tryFetch(original);
  if (out) return out;
  out = await tryFetch(normalized);
  return out || null;
}

/* Helper to check if a job title indicates an internship role.
   Returns true if the job title contains "intern" or "internship". */
function isInternshipRole(jobTitle) {
  if (!jobTitle) return false;
  return /\bintern\b|\binternship\b/i.test(jobTitle);
}

/* Helper to normalize company names for matching duplicate employers.
   Removes common suffixes like Inc., LLC, Ltd., Corp., etc. */
function normalizeCompanyName(name) {
  if (!name) return null;
  return name.toLowerCase()
    .replace(/\s+inc\.?$/i, '')
    .replace(/\s+llc\.?$/i, '')
    .replace(/\s+ltd\.?$/i, '')
    .replace(/\s+corp\.?$/i, '')
    .replace(/\s+corporation$/i, '')
    .replace(/\s+company$/i, '')
    .replace(/\s+co\.?$/i, '')
    .trim();
}

/* Compute tenure from experience text or array.
   Formula: total employment duration (excluding internships) / number of UNIQUE employers (excluding internships).
   Expected format: "Job Title, Company, YYYY to YYYY" or "Job Title, Company, YYYY to present"
   Returns average tenure (years) rounded to one decimal, or null if not computable. */
function computeTenureFromExperienceText(text) {
  try {
    if (!text) return null;
    
    // Handle array of experience entries
    let lines = [];
    if (Array.isArray(text)) {
      lines = text;
    } else if (typeof text === 'string') {
      lines = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
    } else {
      return null;
    }
    
    const nowYear = new Date().getFullYear();
    const employerDurations = new Map(); // Map<normalizedCompanyName, totalYears>
    
    for (const line of lines) {
      // Expected format: "Job Title, Company, YYYY to YYYY|present"
      // Extract company name (2nd comma-separated field) and duration
      const parts = line.split(',').map(s => s.trim());
      
      if (parts.length < 3) {
        // Skip entries that don't match expected format - we can't reliably parse company
        continue;
      }
      
      // Parse: parts[0] = Job Title, parts[1] = Company, parts[2] = Duration
      const jobTitle = parts[0];
      const company = parts[1];
      const durationStr = parts[2];
      
      // Skip internship roles by checking job title field specifically
      if (isInternshipRole(jobTitle)) {
        continue;
      }
      
      const m = durationStr.match(/(\b\d{4})\s*(?:to|[-â€“â€”])\s*(present|\b\d{4}\b)/i);
      
      if (m && company) {
        const start = parseInt(m[1], 10);
        let endRaw = m[2].toLowerCase();
        let end = (endRaw === 'present') ? nowYear : parseInt(endRaw, 10);
        if (!isNaN(start) && !isNaN(end) && end >= start) {
          const duration = end - start;
          // Normalize company name to group similar names
          const normalizedCompany = normalizeCompanyName(company);
          if (normalizedCompany) {
            // Accumulate duration for this employer
            employerDurations.set(normalizedCompany, (employerDurations.get(normalizedCompany) || 0) + duration);
          }
        }
      }
    }
    
    if (employerDurations.size === 0) {
      return null;
    }
    
    // Calculate total duration and count unique employers
    let totalDuration = 0;
    for (const duration of employerDurations.values()) {
      totalDuration += duration;
    }
    const uniqueEmployers = employerDurations.size;
    
    // Tenure = total duration / unique employers
    const tenure = totalDuration / uniqueEmployers;
    return Math.round(tenure * 10) / 10;
  } catch (e) {
    console.warn('computeTenureFromExperienceText error', e);
    return null;
  }
}

/* Compute tenure using total experience from Process table (Postgres) divided by number of unique employers.
   This is used when we have the total experience (exp column) from the database but need to calculate tenure.
   Formula: total experience (from Process table) / number of UNIQUE employers (excluding internships).
   
   Args:
     totalExperience: Total experience in years from the Process table (exp column)
     experienceText: Experience entries in text or array format to count unique employers
   
   Returns: Average tenure (years) rounded to one decimal, or null if not computable. */
function computeTenureFromTotalExperience(totalExperience, experienceText) {
  try {
    if (!totalExperience || !experienceText) return null;
    
    const expNum = Number(totalExperience);
    if (isNaN(expNum) || expNum <= 0) return null;
    
    // Handle array of experience entries
    let lines = [];
    if (Array.isArray(experienceText)) {
      lines = experienceText;
    } else if (typeof experienceText === 'string') {
      lines = experienceText.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
    } else {
      return null;
    }
    
    const uniqueEmployers = new Set();
    
    for (const line of lines) {
      // Expected format: "Job Title, Company, YYYY to YYYY|present"
      const parts = line.split(',').map(s => s.trim());
      
      if (parts.length < 3) {
        continue;
      }
      
      // Parse: parts[0] = Job Title, parts[1] = Company, parts[2] = Duration
      const jobTitle = parts[0];
      const company = parts[1];
      
      // Skip internship roles by checking job title field specifically
      if (isInternshipRole(jobTitle)) {
        continue;
      }
      
      if (company) {
        const normalizedCompany = normalizeCompanyName(company);
        if (normalizedCompany) {
          uniqueEmployers.add(normalizedCompany);
        }
      }
    }
    
    if (uniqueEmployers.size === 0) {
      return null;
    }
    
    // Tenure = total experience from Process table / unique employers count
    const tenure = expNum / uniqueEmployers.size;
    return Math.round(tenure * 10) / 10;
  } catch (e) {
    console.warn('computeTenureFromTotalExperience error', e);
    return null;
  }
}

async function pollProcessGeographyAfterDeepResearch(anchor, { maxMs = 10000, stepMs = 600 } = {}) {
  const deadline = Date.now() + maxMs;
  while (Date.now() < deadline) {
    try {
      const geo = await getProcessGeography(anchor);
      if (geo && (geo.geographic || geo.country || geo.seniority || geo.job_family || geo.sector || (Array.isArray(geo.skillset) && geo.skillset.length))) return geo;
    } catch (_) {}
    await new Promise(r => setTimeout(r, stepMs));
  }
  return null;
}

function getExperienceFromTableAnchor(anchor) {
  try {
    if (!anchor) return '';
    const norm = String(anchor).trim();
    const trs = Array.from(document.querySelectorAll('#tableBody tr')).filter(tr => tr && tr.dataset);
    let tr = trs.find(t => (t.dataset.linkedinurl || '').trim() === norm);
    if (!tr) {
      const lowered = norm.toLowerCase();
      tr = trs.find(t => (t.dataset.linkedinurl || '').toLowerCase().indexOf(lowered) !== -1);
    }
    if (!tr) return '';
    const expCell = tr.querySelector('td[data-field="experience"]');
    let val = '';
    if (expCell) {
      if (expCell.dataset && expCell.dataset.experience) {
        val = String(expCell.dataset.experience || '').trim();
      } else {
        val = String(expCell.textContent || '').trim();
      }
    } else {
      const r = rowsData.find(rr => (rr.linkedinurl || '').trim() === norm);
      if (r && r.experience) val = String(r.experience).trim();
    }
    if (!val) return '';
    val = val.replace(/<\/?[^>]+(>|$)/g, '').replace(/\s+/g, ' ').trim();
    if (val.length > 4000) val = val.slice(0,4000);
    return val;
  } catch (e) {
    console.warn('getExperienceFromTableAnchor error', e);
    return '';
  }
}

function sanitizeRatingText(s) {
  try {
    let out = String(s || '');
    out = out.replace(/<\/?[^>]+(>|$)/g, '');
    out = out.replace(/\s+/g, ' ').trim();
    if (out.length > 2000) out = out.slice(0, 2000);
    return out;
  } catch (e) {
    return String(s || '').slice(0,2000);
  }
}

function getMatchingLevelFromTableAnchor(anchor) {
  try {
    if (!anchor) return '';
    const norm = String(anchor).trim();
    const trs = Array.from(document.querySelectorAll('#tableBody tr')).filter(t => t && t.dataset && t.dataset.linkedinurl);
    let tr = trs.find(t => (t.dataset.linkedinurl || '').trim() === norm);
    if (!tr) {
      const lowered = norm.toLowerCase();
      tr = trs.find(t => (t.dataset.linkedinurl || '').toLowerCase().indexOf(lowered) !== -1);
    }
    if (!tr) return '';
    const expCell = tr.querySelector('td[data-field="experience"]');
    if (!expCell) return '';
    const container = expCell.querySelector('.assessment-result-container');
    let val = '';
    if (container) {
      val = String(container.innerText || container.textContent || '').trim();
      if (val) return val;
    }
    if (expCell.dataset && expCell.dataset.experience) {
      val = String(expCell.dataset.experience || '').trim();
      if (val) return val;
    }
    val = String(expCell.textContent || '').trim();
    return val;
  } catch (e) {
    console.warn('getMatchingLevelFromTableAnchor error', e);
    return '';
  }
}

async function transferSingleRecordViaMarketNoDelete({ name, company, role, country, linkedinurl, experience, rating }) {
  setStatus('Preparing single-record transferâ€¦');
  const uid = window.__SV_ACTIVE_USERID || '';
  const uname = window.__SV_ACTIVE_USERNAME || '';
  if (!uid) { setStatus('Missing user session.','error'); return false; }

  const currentRoleTag = (sessionStorage.getItem('role_tag') || localStorage.getItem('role_tag') || '').trim();

  let canonicalExperience = (experience && String(experience).trim()) ? String(experience).trim() : '';

  if (!canonicalExperience) {
    try {
      const uidForQuery = window.__SV_ACTIVE_USERID || '';
      if (uidForQuery) {
        const listRes = await fetch(`${API_LIST}?userid=${encodeURIComponent(uidForQuery)}&all=1`, { credentials: 'same-origin' });
        if (listRes && listRes.ok) {
          const listData = await listRes.json().catch(()=>({ rows: [] }));
          const rows = Array.isArray(listData.rows) ? listData.rows : [];
          const normTarget = (linkedinurl || '').trim().toLowerCase();
          let found = rows.find(r => ((r.linkedinurl||'').trim().toLowerCase() === normTarget));
          if (!found) {
            found = rows.find(r => ((r.linkedinurl||'').toLowerCase().indexOf(normTarget) !== -1));
          }
          if (found && found.experience) {
            canonicalExperience = String(found.experience || '').trim();
          }
        }
      }
    } catch (e) {
      console.warn('Failed to fetch sourcing row for canonical experience:', e);
    }
  }

  if (!canonicalExperience) {
    canonicalExperience = getExperienceFromTableAnchor(linkedinurl) || '';
  }

  let canonicalRating = (rating && String(rating).trim()) ? String(rating).trim() : '';
  if (!canonicalRating) {
    canonicalRating = getMatchingLevelFromTableAnchor(linkedinurl) || '';
  }

  const payload = {
    records: [{
      name: (name || '').trim(),
      organisation: (company || '').trim(),
      company: (company || '').trim(),
      role: (role || '').trim(),
      country: (country || '').trim(),
      snapshot_at: (linkedinurl || '').trim(),
      linkedinurl: (linkedinurl || '').trim(),
      username: uname,
      userid: uid,
      role_tag: currentRoleTag,
      experience: canonicalExperience,
      rating: sanitizeRatingText(canonicalRating || '')
    }]
  };

  try {
    const res = await fetch(API_MARKET, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'same-origin',
      body: JSON.stringify(payload)
    });
    const data = await res.json().catch(()=>({}));
    if (!res.ok) {
      setStatus(`Transfer failed: ${data.error || ('HTTP ' + res.status)}`, 'error');
      return false;
    }
    const insertedProcess = (typeof data.inserted_process !== 'undefined') ? data.inserted_process :
                            (typeof data.inserted !== 'undefined') ? data.inserted : 1;
    setStatus(`Transfer complete: inserted=${insertedProcess}/1`, 'success');
    return true;
  } catch (e) {
    setStatus(`Transfer failed: ${e && e.message ? e.message : 'network error'}`, 'error');
    return false;
  }
}

// Global variable to track the toggle state
let _profileSourceMode = 'upload'; // 'snip' or 'upload' - default set to upload now

// Apply bulk assessment results from JSON file to table rows
function buildRow(row) {
  const tr = document.createElement('tr');
  tr.classList.add('fade-in');
  tr.dataset.linkedinurl = row.linkedinurl;

  const checkboxCell = document.createElement('td');
  checkboxCell.className = 'checkbox-cell';
  checkboxCell.style.textAlign = 'center';
  checkboxCell.style.width = '45px';
  
  // Determine if profile has been assessed
  let hasAssessment = false;
  let cached = null;
  try {
      if (window.__sv_namecard) {
          cached = window.__sv_namecard.getCardCache(row.linkedinurl);
      }
  } catch(e) {}
  
  if (row.experience && (row.experience.includes('Assessment') || row.experience.match(/\d+%/))) {
      hasAssessment = true;
  }
  if (cached && cached.assessmentHTML) {
      hasAssessment = true;
  }
  
  if (!hasAssessment) {
      // BEFORE ASSESSMENT: Show checkbox for selection
      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.className = 'row-select';
      if(isRowDetailDisabled(row.linkedinurl) || isRowDetailCompleted(row.linkedinurl)){
        cb.disabled = true;
        cb.title = isRowDetailCompleted(row.linkedinurl) ? 'Completed (View)' : 'Disabled after View action';
      }
      cb.addEventListener('change', showDeleteIfNeeded);
      checkboxCell.appendChild(cb);
  } else {
      // AFTER ASSESSMENT: Show tick or cross icon based on score
      const cachedScore = (cached && typeof cached.totalScore === 'number') ? cached.totalScore : null;
      const scoreThreshold = 50;
      
      if (cachedScore !== null && cachedScore >= scoreThreshold) {
          // âœ“ PASS - Green tick icon
          const tickIcon = document.createElement('button');
          tickIcon.innerHTML = 'âœ“';
          tickIcon.className = 'score-icon';
          tickIcon.style.cssText = 'width:25px; height:25px; border:2px solid #10b981; background:#d1fae5; color:#047857; border-radius:6px; cursor:pointer; font-size:16px; font-weight:bold; display:flex; align-items:center; justify-content:center; transition:all 0.2s;';
          tickIcon.title = `Accept (Score: ${cachedScore.toFixed(1)}% â‰¥ 50%)`;
          tickIcon.onclick = () => finalizeIndividualAssessment(row.linkedinurl, 'accept');
          tickIcon.onmouseover = function() { this.style.transform = 'scale(1.15)'; this.style.boxShadow = '0 4px 8px rgba(16,185,129,0.3)'; };
          tickIcon.onmouseout = function() { this.style.transform = 'scale(1)'; this.style.boxShadow = 'none'; };
          checkboxCell.appendChild(tickIcon);
      } else if (cachedScore !== null && cachedScore < scoreThreshold) {
          // âœ— FAIL - Red cross icon
          const crossIcon = document.createElement('button');
          crossIcon.innerHTML = 'âœ—';
          crossIcon.className = 'score-icon';
          crossIcon.style.cssText = 'width:25px; height:25px; border:2px solid #ef4444; background:#fee2e2; color:#dc2626; border-radius:6px; cursor:pointer; font-size:16px; font-weight:bold; display:flex; align-items:center; justify-content:center; transition:all 0.2s;';
          crossIcon.title = `Rebate (Score: ${cachedScore.toFixed(1)}% < 50%)`;
          crossIcon.onclick = () => finalizeIndividualAssessment(row.linkedinurl, 'rebate');
          crossIcon.onmouseover = function() { this.style.transform = 'scale(1.15)'; this.style.boxShadow = '0 4px 8px rgba(239,68,68,0.3)'; };
          crossIcon.onmouseout = function() { this.style.transform = 'scale(1)'; this.style.boxShadow = 'none'; };
          checkboxCell.appendChild(crossIcon);
      }
  }
  tr.appendChild(checkboxCell);

  // Profile Picture Cell
  const picCell = document.createElement('td');
  picCell.style.cssText = 'width:55px; text-align:center; padding:4px;';
  
  // Handle profile picture - check if it's bytea data or URL
  let picSrc = null;
  if (row.pic && row.pic.trim()) {
    // Check if it's already a URL
    if (row.pic.startsWith('http://') || row.pic.startsWith('https://') || row.pic.startsWith('data:')) {
      picSrc = row.pic;
    } else {
      // Assume it's base64 encoded bytea data from Postgres
      // If it doesn't have data URI prefix, add it
      if (!row.pic.startsWith('data:image/')) {
        picSrc = `data:image/jpeg;base64,${row.pic}`;
      } else {
        picSrc = row.pic;
      }
    }
  }
  
  if (picSrc) {
    const img = document.createElement('img');
    img.src = picSrc;
    img.alt = row.name || 'Profile';
    img.style.cssText = 'width:50px; height:50px; border-radius:50%; object-fit:cover; border:2px solid #e5e7eb; cursor:pointer; transition:transform 0.2s, box-shadow 0.2s;';
    img.title = 'Click to view details';
    img.onclick = (e) => {
      e.stopPropagation();
      window.__sv_namecard.toggleNameCard(tr);
    };
    img.onmouseover = function() {
      this.style.transform = 'scale(1.05)';
      this.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';
    };
    img.onmouseout = function() {
      this.style.transform = 'scale(1)';
      this.style.boxShadow = 'none';
    };
    img.onerror = function() {
      // Fallback to placeholder if image fails to load
      this.style.display = 'none';
      const placeholder = document.createElement('div');
      placeholder.style.cssText = 'width:50px; height:50px; border-radius:50%; background:#f3f4f6; display:flex; align-items:center; justify-content:center; color:#9ca3af; font-weight:600; font-size:18px; border:2px solid #e5e7eb; cursor:pointer; transition:transform 0.2s, box-shadow 0.2s;';
      placeholder.textContent = (row.name || '?').charAt(0).toUpperCase();
      placeholder.title = 'Click to view details';
      placeholder.onclick = (e) => {
        e.stopPropagation();
        window.__sv_namecard.toggleNameCard(tr);
      };
      placeholder.onmouseover = function() {
        this.style.transform = 'scale(1.05)';
        this.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';
      };
      placeholder.onmouseout = function() {
        this.style.transform = 'scale(1)';
        this.style.boxShadow = 'none';
      };
      this.parentNode.appendChild(placeholder);
    };
    picCell.appendChild(img);
  } else {
    // Placeholder for missing profile picture - also clickable
    const placeholder = document.createElement('div');
    placeholder.style.cssText = 'width:50px; height:50px; border-radius:50%; background:#f3f4f6; display:flex; align-items:center; justify-content:center; color:#9ca3af; font-weight:600; font-size:18px; margin:0 auto; border:2px solid #e5e7eb; cursor:pointer; transition:transform 0.2s, box-shadow 0.2s;';
    placeholder.textContent = (row.name || '?').charAt(0).toUpperCase();
    placeholder.title = 'Click to view details';
    placeholder.onclick = (e) => {
      e.stopPropagation();
      window.__sv_namecard.toggleNameCard(tr);
    };
    placeholder.onmouseover = function() {
      this.style.transform = 'scale(1.05)';
      this.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';
    };
    placeholder.onmouseout = function() {
      this.style.transform = 'scale(1)';
      this.style.boxShadow = 'none';
    };
    picCell.appendChild(placeholder);
  }
  tr.appendChild(picCell);

  function makeEditableCell(field, value, editable=true, linkedinUrl=null) {
    const td = document.createElement('td');
    td.dataset.field = field;
    
    // Special handling for name field - make it clickable to open LinkedIn
    if (field === 'name' && linkedinUrl) {
      td.style.cssText = 'cursor:pointer; color:#0a66c2; text-decoration:none;';
      td.textContent = value ?? '';
      td.title = 'Click to open LinkedIn profile';
      td.onclick = (e) => {
        e.stopPropagation();
        const uid = window.__SV_ACTIVE_USERID || '';
        fetch('/sourcing/save_profile_json', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ linkedinurl: linkedinUrl, userid: uid })
        }).catch(err => console.warn('JSON save failed', err));
        
        // Validate LinkedIn URL before opening
        if (linkedinUrl && (linkedinUrl.startsWith('http://') || linkedinUrl.startsWith('https://'))) {
          window.open(linkedinUrl, '_blank');
        } else if (linkedinUrl) {
          // If URL doesn't have protocol, add https://
          window.open('https://' + linkedinUrl, '_blank');
        } else {
          console.warn('Invalid or missing LinkedIn URL');
        }
      };
      td.onmouseover = function() { this.style.textDecoration = 'underline'; };
      td.onmouseout = function() { this.style.textDecoration = 'none'; };
      return td;
    }
    
    if (editable) {
      td.contentEditable = "true";
      td.textContent = value ?? '';
      td.addEventListener('keydown', e => {
        if (e.key === 'Enter') { e.preventDefault(); td.blur(); }
      });
      td.addEventListener('input', () => {
        markDirty(td);
        debounceUpdate(tr.dataset.linkedinurl, field, td.textContent.trim(), td);
      });
      td.addEventListener('blur', () => {
        flushImmediate(tr.dataset.linkedinurl, field, td.textContent.trim(), td);
      });
    } else {
      td.classList.add('readonly');
      if (field === 'linkedinurl') {
        // Determine button mode based on toggle
        if (_profileSourceMode === 'upload') {
            // Check matching level for completion or intermediate state
            let isComplete = isRowDetailCompleted(row.linkedinurl);
            let hasAssessment = false;
            let isLevel2 = false;

            // Check if profile has rating data from database (primary check for persistence)
            if (row.rating && row.rating_score != null && row.rating_score !== '') {
                hasAssessment = true;
                if (row.rating_level === 'L2') isLevel2 = true;
            }

            // Try to infer status from experience/rating content (which often holds the HTML for stars/score)
            // Or from cached card state
            let cached = null;
            try {
                if (window.__sv_namecard) {
                    cached = window.__sv_namecard.getCardCache(row.linkedinurl);
                }
            } catch(e) {}

            // Additional checks from cached data and experience field
            if (row.experience && (row.experience.includes('Assessment') || row.experience.match(/\d+%/))) {
                 hasAssessment = true;
            }
            if (cached && cached.assessmentHTML) {
                 hasAssessment = true;
                 if (cached.assessmentHTML.includes('Level 2')) isLevel2 = true;
            }
            if (row.experience && row.experience.includes('Level 2')) isLevel2 = true;

            // If Level 2 is reached or L1 assessment completed, show View button only
            // (tick/cross icons are in checkbox column, LinkedIn link is on name)
            if (isLevel2 || hasAssessment) {
                const btn = document.createElement('button');
                btn.textContent = 'View';
                btn.className = 'view-btn assessment-complete';
                btn.title = isLevel2 ? "View - L2 Complete" : "View - L1 Complete";
                btn.onclick = () => { window.__sv_namecard.toggleNameCard(tr); };
                // Revert to previous button styling (default gray button)
                btn.style.cssText = 'width:100%; padding:6px 12px; font-size:13px; cursor:pointer;';
                td.appendChild(btn);
                return td;
            }

            // No assessment yet - show Upload CV button only
            // Upload CV Button - using outlined LinkedIn button design (matches reference image)
            const browseBtn = document.createElement('button');
            browseBtn.textContent = 'Upload CV';
            browseBtn.className = 'view-btn';
            // White background with LinkedIn blue outline and text
            browseBtn.style.cssText = 'width:100%; padding:6px 12px; font-size:13px; font-weight:500; background:white; color:#0a66c2; border:1px solid #0a66c2; border-radius:6px; cursor:pointer; transition:all 0.2s;';
            browseBtn.title = "Upload CV";
            // Hover effect: light blue background
            browseBtn.onmouseover = function() { this.style.background = '#eff3f8'; };
            browseBtn.onmouseout = function() { this.style.background = 'white'; };
            
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = 'application/pdf,application/msword,application/vnd.openxmlformats-officedocument.wordprocessingml.document';
            fileInput.style.display = 'none';

            browseBtn.onclick = (e) => {
                e.stopPropagation();
                fileInput.click();
            };

            fileInput.onchange = async () => {
                    if (!fileInput.files.length) return;
                    const file = fileInput.files[0];
                    if (file.type !== 'application/pdf' && !file.name.match(/\.(doc|docx)$/i)) {
                        alert('Please upload a PDF or DOC file.');
                        fileInput.value = '';
                        return;
                    }

                    browseBtn.textContent = '...';
                    browseBtn.disabled = true;

                    const fd = new FormData();
                    fd.append('cv', file); 
                    fd.append('linkedinurl', value);
                    /* AFFECTED: Pass name for insertion */
                    const nameCell = tr.querySelector('td[data-field="name"]');
                    const candName = nameCell ? nameCell.textContent.trim() : '';
                    if(candName) {
                        // Clean unwanted characters before uploading
                        const cleanedName = cleanNameForUpload(candName);
                        fd.append('name', cleanedName);
                    }

                    const uid = window.__SV_ACTIVE_USERID || '';
                    if (uid) fd.append('userid', uid);

                    console.log(`[Upload CV] Uploading file: ${file.name}, size: ${file.size}, type: ${file.type}`);
                    console.log(`[Upload CV] LinkedIn URL: ${value}`);

                    try {
                        const res = await fetch(API_UPLOAD_CV, {
                          method: 'POST', body: fd, credentials: 'same-origin'
                        });
                        
                        if (res.ok) {
                            const uploadResult = await res.json();
                            console.log('[Upload CV] Upload successful:', uploadResult);
                            
                            browseBtn.textContent = 'Analyzing...';
                            const analyzeRes = await fetch(API_PARSE_CV_AND_UPDATE, {
                                method: 'POST', headers: {'Content-Type': 'application/json'},
                                body: JSON.stringify({ linkedinurl: value })
                            });
                            const analyzeData = await analyzeRes.json();
                            console.log('[Upload CV] Parse result:', analyzeData);
                            
                            if (analyzeRes.ok) {
                                // Update basic cells
                                const newCompany = analyzeData.company || analyzeData.organisation || '';
                                const newJob = analyzeData.job_title || analyzeData.jobtitle || '';
                                const newCountry = analyzeData.country || analyzeData.location || '';
                                
                                if (newCompany) { const cCell = tr.querySelector('td[data-field="company"]'); if(cCell) { cCell.textContent = newCompany; markDirty(cCell); flushImmediate(value, 'company', newCompany, cCell); } }
                                if (newJob) { const jCell = tr.querySelector('td[data-field="jobtitle"]'); if(jCell) { jCell.textContent = newJob; markDirty(jCell); flushImmediate(value, 'jobtitle', newJob, jCell); } }
                                if (newCountry) { const cntCell = tr.querySelector('td[data-field="country"]'); if(cntCell) { cntCell.textContent = newCountry; markDirty(cntCell); flushImmediate(value, 'country', newCountry, cntCell); } }
                                
                                // All assessments use L2 (inference mode) by default
                                const useL2 = true;
                                
                                // Set button to Processing state before assessment
                                browseBtn.textContent = 'Processing...';
                                
                                // Perform Combined Assessment with toggle state
                                await performCombinedAssessment(tr, value, analyzeData, useL2);
                                
                                // After assessment completes, update button to View
                                // Find credential cell and update button
                                const actionCell = tr.querySelector('td[data-field="credential"], td[data-field="linkedinurl"]');
                                if (actionCell) {
                                    // Use updateUploadButtonToView to properly convert button to View
                                    updateUploadButtonToView(value);
                                }
                                
                                // Trigger table refresh to update tick/cross icons in checkbox column
                                // Icons are now handled by buildRow() based on assessment score
                                // Row is already updated in place, no full table re-render needed
                                persistCompletedDetailRow(value);
                                
                                // Auto-refresh after individual assessment completion
                                // Wait 1 second then simulate click on Refresh button
                                setTimeout(() => {
                                    const reloadBtn = document.getElementById('reloadBtn');
                                    if (reloadBtn) {
                                        reloadBtn.click();
                                    }
                                }, 1000);

                            } else {
                                browseBtn.textContent = 'Upload CV';
                                browseBtn.disabled = false;
                                alert('Analysis failed: ' + analyzeData.error);
                            }
                        } else {
                             throw new Error('Upload failed');
                        }
                    } catch(e) {
                        console.error("Row upload failed", e);
                        browseBtn.textContent = 'Upload CV';
                        browseBtn.disabled = false;
                        alert("Upload failed.");
                    }
                    fileInput.value = '';
                };

                td.appendChild(browseBtn);
                td.appendChild(fileInput);

            return td;
        }

        // Snip mode logic (Default)
        const btn = document.createElement('button');
        btn.textContent = 'Assessment';
        btn.className = 'view-btn';
        btn.dataset.profileUrl = value || '';

        if (isRowDetailCompleted(row.linkedinurl)) {
          btn.textContent = 'View';
          btn.disabled = false;
          btn.classList.add('assessment-complete');
          btn.title = "Assessment Complete - Click to View";
          btn.onclick = () => { 
            if (window.__sv_namecard && window.__sv_namecard.toggleNameCard) {
              window.__sv_namecard.toggleNameCard(tr);
            }
          };
          try { persistDisabledDetailRow(row.linkedinurl); } catch(_) {}
          td.appendChild(btn);
          return td;
        }

        btn.addEventListener('click', async () => {
          if (btn.dataset.assessmentActive === '1') return;

          let assessmentCompleted = false;
          setAssessmentActive(btn);
          
          persistDisabledDetailRow(tr.dataset.linkedinurl);
          try {
            const rowCheckbox = tr.querySelector('.row-select');
            if (rowCheckbox && !rowCheckbox.disabled) {
              rowCheckbox.checked = false;
              rowCheckbox.disabled = true;
              rowCheckbox.title = 'Disabled after View action';
              showDeleteIfNeeded();
            }
          } catch(_){}

          const link = btn.dataset.profileUrl;

          try {
            if (link) {
              const payload = { detail: { url: link } };
              try { window.dispatchEvent(new CustomEvent('sv:open_and_capture', payload)); } catch(_) {}
              try { document.dispatchEvent(new CustomEvent('sv:open_and_capture', payload)); } catch(_) {}
            }
          } catch (e) { console.warn('sv dispatch failed', e); }

          try { window.__sv_lastLinkedIn = tr.dataset.linkedinurl || link || ''; } catch (_) {}
          try {
            const _marker = `__sv_marker_${Date.now()}_${Math.random().toString(36).slice(2)}`;

            // snipper calls removed; we'll proceed using existing experience text if present.

            setStatus('Extracting with Geminiâ€¦');
            let gemCompany=null, gemJob=null, usedGemini=false;
            try {
              const ocrFallbackText = getExperienceFromTableAnchor(tr.dataset.linkedinurl) || '';
              // If we have any text from table, attempt to run gemini extraction on it,
              // otherwise skip to fallback heuristics.
              if (ocrFallbackText) {
                const gem = await geminiExtractCompanyJob(ocrFallbackText);
                if (gem && (gem.company || gem.job_title)) {
                  gemCompany = (gem.company || '').trim();
                  gemJob = (gem.job_title || '').trim();
                  usedGemini = true;
                }
              }
            } catch(e){ console.warn('Gemini extraction failed:', e); }
            let fallbackCompany=null, fallbackJob=null;
            if (!usedGemini) {
              const ocrText = getExperienceFromTableAnchor(tr.dataset.linkedinurl) || '';
              fallbackCompany = extractFullTimeLine(ocrText);
              fallbackJob = extractJobTitleAboveCompany(ocrText);
              if (fallbackCompany) fallbackCompany = stripFullTimeSuffix(fallbackCompany);
              setStatus('Fallback extraction applied.', 'info');
            } else {
              setStatus('Gemini extraction successful.', 'success');
            }
            const finalCompany = (gemCompany || fallbackCompany || '').trim();
            const finalJob     = (gemJob || fallbackJob || '').trim();
            const anchor = (window.__sv_lastLinkedIn || '').trim() || tr.dataset.linkedinurl;
            const companyCell = tr.querySelector('td[data-field="company"]');
            if (companyCell && finalCompany) {
              try { window.__sv_namecard.updateNameCard(tr, { company: finalCompany }); } catch(_) {}
              try { companyCell.textContent = finalCompany; } catch(_) {}
              markDirty(companyCell);
              flushImmediate(tr.dataset.linkedinurl, 'company', finalCompany, companyCell);
            }
            const jobCell = tr.querySelector('td[data-field="jobtitle"]');
            if (jobCell && finalJob) {
              try { window.__sv_namecard.updateNameCard(tr, { jobtitle: finalJob }); } catch(_) {}
              try { jobCell.textContent = finalJob; } catch(_) {}
              markDirty(jobCell);
              flushImmediate(tr.dataset.linkedinurl, 'jobtitle', finalJob, jobCell);
            }
            if (finalCompany) {
              try { /* snipper save removed */ } catch(_) {}
            }

            try {
              const expCell = tr.querySelector('td[data-field="experience"]');
              if (expCell) {
                const rawText = (expCell.dataset.experience || '').trim() || getExperienceFromTableAnchor(tr.dataset.linkedinurl) || '';
                const applyFormatted = async (sourceText) => {
                  // IMPORTANT CHANGE: retain entire formatted experience (do not pick only latest)
                  const formatted = await formatExperienceText(sourceText);
                  if (!formatted) {
                    try { window.__sv_namecard.updateNameCard(tr, { experience: '' }); } catch(_) {}
                    return;
                  }

                  try {
                    window.__sv_namecard.updateNameCard(tr, { experience: formatted });
                  } catch(_) {}

                  if (expCell) {
                      expCell.dataset.experience = formatted;
                      markDirty(expCell);
                      flushImmediate(anchor, 'experience', formatted, expCell);
                  }

                  // Do NOT extract just the latest employment to update job/company;
                  // keep the full experience for analysis, and compute tenure from full history.
                  await triggerLevel1Assessment(tr, anchor);
                };
                await applyFormatted(rawText);

                assessmentCompleted = true;
                markAssessmentComplete(btn);
              }
            } catch(e){ console.warn('Experience populate failed', e); }

          } catch (err) {
            setStatus(err && err.message ? err.message : 'Snipper sequence failed', 'error');
          } finally {
            if (!assessmentCompleted) {
              clearAssessmentActive(btn);
            }
          }
        });
        td.appendChild(btn);
      } else {
        td.textContent = value ?? '';
      }
    }

    if (field === 'experience') {
      td.innerHTML = '';
      td.classList.add('readonly');
      td.style.width = '33.33%';
      td.style.maxWidth = '33.33%';
      td.style.minWidth = '33.33%';

      const container = document.createElement('div');
      container.className = 'assessment-result-container';
      container.style.fontSize = '11px';
      
      try {
          const cache = window.__sv_namecard && window.__sv_namecard.getCardCache ? window.__sv_namecard.getCardCache(row.linkedinurl) : null;
          if (cache && cache.assessmentTableHTML) {
              // Use the TABLE-specific HTML (ONLY level + stars) for Search Results
              container.innerHTML = cache.assessmentTableHTML;
          } else if (cache && cache.assessmentHTML) {
              // Fallback: Strip everything except header and stars from full HTML
              let html = cache.assessmentHTML;
              const tempDiv = document.createElement('div');
              tempDiv.innerHTML = html;
              // Remove overall comment, regular comments, and category breakdown
              const overallComment = tempDiv.querySelector('.assessment-overall-comment');
              if (overallComment) overallComment.remove();
              const commentNode = tempDiv.querySelector('.assessment-comments');
              if (commentNode) commentNode.remove();
              const categoryNode = tempDiv.querySelector('.category-appraisals');
              if (categoryNode) categoryNode.remove();
              container.innerHTML = tempDiv.innerHTML;
          } else {
              container.innerHTML = '<span style="color:#999;">(Assessment pending)</span>';
          }
      } catch (e) {
          container.innerHTML = '<span style="color:#999;">(Assessment pending)</span>';
      }
      
      td.dataset.experience = value || '';
      td.appendChild(container);
    }

    if (field === 'country') {
      td.style.width = '8%';
      td.style.maxWidth = '8%';
    }
    if (field === 'linkedinurl') {
      td.style.width = '8%';
      td.style.maxWidth = '8%';
    }

    return td;
  }

  tr.appendChild(makeEditableCell('name', row.name, true, row.linkedinurl));
  tr.appendChild(makeEditableCell('company', row.company, true));
  tr.appendChild(makeEditableCell('jobtitle', row.jobtitle, true));
  tr.appendChild(makeEditableCell('country', row.country, true));
  tr.appendChild(makeEditableCell('linkedinurl', row.linkedinurl, false));
  
  // Matching Level / Assessment Score column
  const matchingLevelCell = document.createElement('td');
  matchingLevelCell.dataset.field = 'experience';
  
  // Check if row has rating data (assessment already completed)
  if (row.rating && (row.rating_score !== undefined && row.rating_score !== '')) {
    // Display assessment score with stars (including 0% scores as valid assessments)
    const score = row.rating_score;
    const starCount = parseInt(row.rating_stars) || 0;
    const level = row.rating_level || 'L1';
    let starsHtml = '';
    for (let i = 0; i < 5; i++) {
      starsHtml += `<span class="${i < starCount ? 'filled' : ''}">â˜…</span>`;
    }
    const levelText = level === 'L2' ? 'L2 Assessment' : 'L1 Assessment';
    matchingLevelCell.innerHTML = `<div class="assessment-badge"><div style="font-size:11px;color:#6b7280;">${levelText}: <b>${score}%</b></div><div class="assessment-stars">${starsHtml}</div></div>`;
    tr.classList.add('assessment-complete');
    // Store rating data in dataset for later use
    try { 
      tr.dataset.rating = JSON.stringify(typeof row.rating === 'string' ? JSON.parse(row.rating) : row.rating); 
    } catch(e) { 
      console.warn('[buildRow] Failed to serialize rating for row:', row.linkedinurl, e); 
    }
  } else if (row.rating) {
    // Try to parse rating JSON if available
    try {
      const robj = typeof row.rating === 'string' ? JSON.parse(row.rating) : row.rating;
      if (robj && robj.total_score) {
        const starCount = robj.stars || 0;
        let starsHtml = '';
        for (let i = 0; i < 5; i++) {
          starsHtml += `<span class="${i < starCount ? 'filled' : ''}">â˜…</span>`;
        }
        const assessmentLevel = robj.assessment_level || 'L1 Assessment';
        matchingLevelCell.innerHTML = `<div class="assessment-badge"><div style="font-size:11px;color:#6b7280;">${assessmentLevel}: <b>${robj.total_score}</b></div><div class="assessment-stars">${starsHtml}</div></div>`;
        tr.classList.add('assessment-complete');
        try { 
          tr.dataset.rating = JSON.stringify(robj); 
        } catch(e) { 
          console.warn('[buildRow] Failed to serialize rating object for row:', row.linkedinurl, e); 
        }
      } else {
        matchingLevelCell.innerHTML = '<span class="assessment-placeholder">Assessment pending</span>';
      }
    } catch(e) {
      matchingLevelCell.innerHTML = '<span class="assessment-placeholder">Assessment pending</span>';
    }
  } else if (row.experience) {
    // Fallback to experience text if no rating (legacy behavior)
    matchingLevelCell.textContent = row.experience;
  } else {
    // No assessment or experience data
    matchingLevelCell.innerHTML = '<span class="assessment-placeholder">Assessment pending</span>';
  }
  
  tr.appendChild(matchingLevelCell);
  return tr;
}

window.__sv_assessment_in_flight = window.__sv_assessment_in_flight || new Set();
// Global guard to prevent Level 1 from running if Level 2 is manually triggered
window.__sv_skip_level1 = false;

/* =========================================================
   Fix: Implement assessment button state helpers used across code
   These were missing and caused ReferenceError on Level-2 uploads.
   Keep implementations minimal and safe.
   ========================================================= */
function setAssessmentActive(btn) {
  try {
    if (!btn) return;
    // mark as active to prevent duplicate clicks
    btn.dataset.assessmentActive = '1';
    btn.classList.add('assessment-active');
    // preserve original text to restore later
    if (!btn.dataset._origText) btn.dataset._origText = btn.textContent || '';
    btn.textContent = 'Processing...';
    btn.disabled = true;
  } catch (e) {
    console.warn('setAssessmentActive error', e);
  }
}
function clearAssessmentActive(btn) {
  try {
    if (!btn) return;
    btn.dataset.assessmentActive = '0';
    btn.classList.remove('assessment-active');
    // restore original text if present
    if (btn.dataset._origText) {
      btn.textContent = btn.dataset._origText;
      delete btn.dataset._origText;
    }
    btn.disabled = false;
  } catch (e) {
    console.warn('clearAssessmentActive error', e);
  }
}
function markAssessmentComplete(btn) {
  try {
    if (!btn) return;
    btn.dataset.assessmentActive = '0';
    btn.classList.remove('assessment-active');
    btn.classList.add('assessment-complete');
    // set to View state
    btn.textContent = 'View';
    btn.disabled = false;
    if (btn.dataset._origText) delete btn.dataset._origText;
  } catch (e) {
    console.warn('markAssessmentComplete error', e);
  }
}
/* ========================================================= */

async function triggerLevel1Assessment(tr, anchor) {
    if(!tr) return;
    
    // GUARD
    if (window.__sv_skip_level1) {
        console.info('Skipping Level-1 assessment due to in-progress Level-2 orchestration.');
        return;
    }
    
    // GUARD
    if (window.__sv_assessment_in_flight && window.__sv_assessment_in_flight.has(anchor)) {
        console.warn("Assessment already in flight for", anchor);
        return;
    }
    window.__sv_assessment_in_flight.add(anchor);

    const container = tr.querySelector('.assessment-result-container');
    /* AFFECTED: Don't show loading spinner in main table container as requested. 
       Instead, we show loading status in the details tab if active. 
       We leave the container content as is or set a minimal placeholder. */
    // if(!container) return;
    // container.innerHTML = '<span class="spinner"></span> Assessing...'; 
    
    // Instead check if Details Tab is open and show spinner there
    const detailsContainer = document.querySelector('#details-container .sv-namecard .assessment-result-container');
    if (detailsContainer) {
        detailsContainer.innerHTML = '<span class="spinner"></span> Assessing...';
    } else if (container) {
       // Minimal feedback in table still useful, but user asked to move animation. 
       // We'll interpret "move the loading bar" as the 'Assessment...' text + spinner.
       // We'll keep existing content or set a static "..."
       container.style.opacity = '0.5';
    }
    
    const jobTitle = (tr.querySelector('td[data-field="jobtitle"]')?.textContent || '').trim();
    const roleTag = (sessionStorage.getItem('role_tag') || localStorage.getItem('role_tag') || '').trim();
    const company = (tr.querySelector('td[data-field="company"]')?.textContent || '').trim();
    const country = (tr.querySelector('td[data-field="country"]')?.textContent || '').trim();
    
    let seniority = "";
    let sector = "";
    let candidateSkillset = [];

    /* Re-fetch data from namecard cache since we don't have the next row anymore in this view */
    const cache = window.__sv_namecard.getCardCache(anchor);
    if(cache) {
        if(cache.seniority) seniority = cache.seniority;
        if(cache.sector) sector = cache.sector;
        if(cache.skillset) candidateSkillset = cache.skillset;
    }
    
    const expCell = tr.querySelector('td[data-field="experience"]');
    const experienceText = (expCell && expCell.dataset.experience) ? expCell.dataset.experience : '';

    // AFFECTED: Retrieve custom weights from config
    const customWeights = getActiveWeights();

    // Compute tenure: try cache first, then compute using exp from Process (Postgres) if available
    let tenureVal = null;
    let expVal = null;
    try {
      if (cache && typeof cache.tenure !== 'undefined' && cache.tenure !== null && !Number.isNaN(Number(cache.tenure))) {
        tenureVal = cache.tenure;
      } else {
        // Get exp value from cache if available
        if (cache && cache.exp) {
          expVal = cache.exp;
        }
        
        // Priority: Use exp from Process table if available, otherwise compute from experience text
        if (expVal && experienceText) {
          const computed = computeTenureFromTotalExperience(expVal, experienceText);
          if (computed !== null) tenureVal = computed;
        } else if (experienceText) {
          const computed = computeTenureFromExperienceText(experienceText);
          if (computed !== null) tenureVal = computed;
        }
      }
    } catch(e) { tenureVal = null; }

    const payload = {
        linkedinurl: anchor,
        job_title: jobTitle,
        role_tag: roleTag,
        company: company,
        country: country,
        seniority: seniority,
        sector: sector,
        skillset: candidateSkillset,
        experience_text: experienceText,
        username: window.__SV_ACTIVE_USERNAME || '',
        userid: window.__SV_ACTIVE_USERID || '',
        custom_weights: customWeights, // Sending custom weights
        tenure: tenureVal
    };
    
    try {
        const res = await fetch('/gemini/assess_profile', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(payload)
        });
        
        if(!res.ok) {
            const errorData = await res.json().catch(() => ({}));
            const errorMsg = errorData.error || `HTTP ${res.status}`;
            throw new Error(`Assessment API failed: ${errorMsg}`);
        }
        
        const data = await res.json();
        
        let starsHtml = '';
        const starCount = data.stars || 0;
        for(let i=0; i<5; i++) {
            starsHtml += `<span class="${i < starCount ? 'filled' : ''}">â˜…</span>`;
        }
        
        // Use assessment_level from backend data (authoritative source)
        // Fallback to is_level2 flag only for legacy data
        const headerText = data.assessment_level || (data.is_level2 ? "L2 Assessment" : "L1 Assessment");
        /* AFFECTED: Combine Level and Score for main display */
        const combinedHeader = `${headerText}: ${data.total_score || '0%'}`;
        
        // Build Category Appraisals HTML if available
        let categoryAppraisalsHtml = '';
        if (data.category_appraisals && typeof data.category_appraisals === 'object') {
            const categories = Object.entries(data.category_appraisals);
            console.log('[Assessment L1] category_appraisals entries:', categories.length, categories);
            if (categories.length > 0) {
                categoryAppraisalsHtml = '<div class="category-appraisals">';
                categoryAppraisalsHtml += '<div class="category-appraisals-title">Category Breakdown</div>';
                categoryAppraisalsHtml += '<table class="category-appraisals-table">';
                categoryAppraisalsHtml += '<thead><tr><th>Category</th><th>Weightage Score</th><th>Rating</th></tr></thead>';
                categoryAppraisalsHtml += '<tbody>';
                
                categories.forEach(([category, details]) => {
                    const weightPercent = details.weight_percent || 0;
                    const starString = details.star_string || '';
                    categoryAppraisalsHtml += `
                        <tr>
                            <td class="category-name">${escapeHtml(category)}</td>
                            <td class="category-weight">${weightPercent}%</td>
                            <td class="category-rating">${starString}</td>
                        </tr>
                    `;
                });
                
                categoryAppraisalsHtml += '</tbody></table></div>';
            }
        } else {
            console.log('[Assessment L1] No category_appraisals in data:', data);
        }
        
        // Overall Comment HTML if available
        let overallCommentHtml = '';
        if (data.overall_comment) {
            overallCommentHtml = `<div class="assessment-overall-comment" style="margin-top: 8px; padding: 8px; background: #f0f9ff; border-left: 3px solid #0ea5e9; font-size: 12px; font-style: italic; color: #0c4a6e;">${escapeHtml(data.overall_comment)}</div>`;
        }
        
        // Full HTML for Details Tab (includes comments, category appraisals, and overall comment)
        const fullHtml = `
            <div class="assessment-header">${escapeHtml(combinedHeader)}</div>
            <div class="assessment-stars">${starsHtml}</div>
            ${overallCommentHtml}
            <div class="assessment-comments" style="margin-top: 8px; font-size: 11px; color: #6b7280;">Comments: ${escapeHtml(data.comments || 'None')}</div>
            ${categoryAppraisalsHtml}
        `;
        
        // Simplified HTML for Search Results Table (ONLY assessment level + stars, no comments or other text)
        const tableHtml = `
            <div class="assessment-header">${escapeHtml(combinedHeader)}</div>
            <div class="assessment-stars">${starsHtml}</div>
        `;

        // Update container in table
        if (container) {
            container.innerHTML = tableHtml;
            container.style.opacity = '1';
        }
        
        // Update container in details tab if present
        if (detailsContainer) {
            detailsContainer.innerHTML = fullHtml;
        }
        
        try {
            if(window.__sv_namecard && window.__sv_namecard.setCardCache) {
                // Store BOTH versions: full HTML for Details tab, table HTML for Search Results
                window.__sv_namecard.setCardCache(anchor, { 
                    assessmentHTML: fullHtml,           // Full details for View tab
                    assessmentTableHTML: tableHtml      // Simplified for Search Results table
                });
            }
        } catch(e) { console.warn("Failed to cache assessment HTML", e); }

        let totalScoreVal = 0;
        try {
            totalScoreVal = parseInt(data.total_score.replace('%', '')) || 0;
        } catch(e) {}

        const threshold = 50; 
        const ratingString = `${headerText}: ${data.total_score} (${starCount} â˜…) - ${data.comments || ''}`;

        if (totalScoreVal < threshold) {
            if (typeof openRebateModal === 'function') {
                openRebateModal({
                    title: 'Rebate Eligible (Low Match Score)',
                    headerChip: 'Rebate',
                    body: `
                        <b>${escapeHtml(combinedHeader)}</b><br>
                        ${starsHtml} <span style="font-size:12px;color:#666">(${starCount} Stars)</span><br><br>
                        <b>Assessment Comments:</b><br>
                        <i>${escapeHtml(data.comments || 'No comments')}</i><br><br>
                        Since the match score is below ${threshold}%, this profile is flagged for rebate.
                    `,
                    primaryLabel: 'Confirm Rebate',
                    secondaryLabel: 'Do not Proceed',
                    onPrimary: async () => {
                        await applyTokenDelta(1);
                        rebateTokens += 1;
                        updateRebateTokenDisplay();
                        await deleteBackendRow(anchor);
                        autoDeleteRow(anchor);
                        try { await applyTokenDelta(-1); } catch(e){}
                        setStatus('Rebate confirmed & profile removed.', 'success');
                        refreshAccountTokens();
                        await loadRows(currentPage);
                    },
                    onSecondary: async () => {
                    try {
                        setStatus('Processing transfer (retaining sourcing row)...');
                        const ok = await transferSingleRecordViaMarketNoDelete({
                            name: (tr.querySelector('td[data-field="name"]')?.textContent || '').trim(),
                            company: company,
                            role: jobTitle,
                            country: country,
                            linkedinurl: anchor,
                            experience: '',
                            rating: ratingString 
                        });
                        if(ok) {
                            setStatus('Record transferred. Rebate declined.', 'success');
                            deepResearchBackgroundForAnchor(anchor);
                        }
                    } catch(e) { console.error(e); setStatus('Transfer action failed', 'error'); }
                }
            });
            }
        } else {
            /* AFFECTED: Add Appeal Button if score > 50% */
            if (typeof openRebateModal === 'function') {
                openRebateModal({
                    title:'Rebate denied',
                    headerChip:'Relevant',
                    body: `Job Title (latest): <b>${escapeHtml(jobTitle)}</b><br>Searched Title: <b>${escapeHtml(roleTag)}</b><br><br><b>Explanation:</b><br>Score ${data.total_score} (>= ${threshold}%) deems this relevant.<br><br>You may file an appeal with justification.`,
                    primaryLabel:'Appeal',
                    secondaryLabel:'Close',
                    onPrimary:()=> { 
                        if(typeof openAppealModal === 'function') {
                            openAppealModal({ finalJob: jobTitle, roleTag: roleTag, anchor: anchor });
                        } else {
                            // Fallback simple appeal prompt
                            const reason = prompt("Enter justification for appeal:");
                            if(reason) {
                                // Assuming appeal saving logic
                                setStatus("Appeal submitted (mock).", "success"); 
                            }
                        }
                    },
                    onSecondary: async () => {
                        try {
                            setStatus('Processing transfer (retaining sourcing row)...');
                            const ok = await transferSingleRecordViaMarketNoDelete({
                                name: (tr.querySelector('td[data-field="name"]')?.textContent || '').trim(),
                                company: company,
                                role: jobTitle,
                                country: country,
                                linkedinurl: anchor,
                                experience: '',
                                rating: ratingString 
                            });
                            if(ok) {
                                setStatus('Record transferred. Rebate declined.', 'success');
                                deepResearchBackgroundForAnchor(anchor);
                            }
                        } catch(e) { console.error(e); setStatus('Transfer action failed', 'error'); }
                    }
                });
            }
        }

    } catch(e) {
        console.error("Assessment failed", e);
        if(container) container.innerHTML = '<span class="error">Assessment failed.</span>';
        if(detailsContainer) detailsContainer.innerHTML = '<span class="error">Assessment failed.</span>';
    } finally {
        window.__sv_assessment_in_flight.delete(anchor);
    }
}

async function performCombinedAssessment(tr, anchor, analyzeData, isLevel2Request = false) {
    if(!tr) return;
    
    // L1 vs L2 Assessment:
    // L1 (Level 1): CV-only, strictly extractive, no inference
    // L2 (Level 2): Contextual inference allowed based on job title, company, domain
    // 
    // SOURCE OF TRUTH for L1: CV Column exclusively
    // analyzeData comes from /process/parse_cv_and_update which uses cv column from process table
    // Employment history format: "Job Title, Company, StartYear to EndYear"
    // OR "Job Title, Company, StartYear to present" (for current positions)
    
    // GUARD
    if (window.__sv_assessment_in_flight && window.__sv_assessment_in_flight.has(anchor)) {
        console.warn("Combined assessment skipped; already in flight for", anchor);
        return;
    }
    window.__sv_assessment_in_flight.add(anchor);

    // Sync button state
    let btn = null;
    try { btn = tr.querySelector('.view-btn'); } catch(e) {}
    if (btn) setAssessmentActive(btn);

    // UI Loading state
    const container = tr.querySelector('.assessment-result-container');
    const detailsContainer = document.querySelector('#details-container .sv-namecard .assessment-result-container');
    if (detailsContainer) {
        detailsContainer.innerHTML = '<span class="spinner"></span> Level-2 Assessing...';
    } else if (container) {
       container.style.opacity = '0.5';
    }

    // Build rich payload
    const jobTitle = analyzeData.job_title || analyzeData.jobtitle || (tr.querySelector('td[data-field="jobtitle"]')?.textContent || '').trim();
    const roleTag = (sessionStorage.getItem('role_tag') || localStorage.getItem('role_tag') || '').trim();
    const company = analyzeData.company || (tr.querySelector('td[data-field="company"]')?.textContent || '').trim();
    const country = analyzeData.country || (tr.querySelector('td[data-field="country"]')?.textContent || '').trim();
    
    // Attempt to get seniority/sector from existing cache or assume analysis didn't extract them separately
    let seniority = "";
    let sector = "";
    const cache = window.__sv_namecard.getCardCache(anchor);
    if(cache) {
        if(cache.seniority) seniority = cache.seniority;
        if(cache.sector) sector = cache.sector;
    }

    // Use analyzed skillset
    let candidateSkillset = analyzeData.skillset || [];
    
    // Use analyzed experience text
    const experienceText = analyzeData.experience_text || analyzeData.experience || '';

    const customWeights = getActiveWeights();

    // Compute tenure: prefer analyzeData.tenure, else use exp from Process (Postgres) if available
    let tenureVal = null;
    try {
      if (typeof analyzeData.tenure !== 'undefined' && analyzeData.tenure !== null && !Number.isNaN(Number(analyzeData.tenure))) {
        tenureVal = analyzeData.tenure;
      } else {
        // Get exp value from analyzeData or cache if available
        let expVal = null;
        if (analyzeData.exp) {
          expVal = analyzeData.exp;
        } else if (cache && cache.exp) {
          expVal = cache.exp;
        }
        
        // Priority: Use exp from Process table if available, otherwise compute from experience text
        if (expVal && experienceText) {
          const computed = computeTenureFromTotalExperience(expVal, experienceText);
          if (computed !== null) tenureVal = computed;
        } else if (experienceText) {
          const computed = computeTenureFromExperienceText(experienceText);
          if (computed !== null) tenureVal = computed;
        }
      }
    } catch(e) { tenureVal = null; }

    const payload = {
        linkedinurl: anchor,
        job_title: jobTitle,
        role_tag: roleTag,
        company: company,
        country: country,
        seniority: seniority,
        sector: sector,
        skillset: candidateSkillset,
        experience_text: experienceText,
        username: window.__SV_ACTIVE_USERNAME || '',
        userid: window.__SV_ACTIVE_USERID || '',
        custom_weights: customWeights,
        tenure: tenureVal,
        assessment_level: isLevel2Request ? 'L2' : 'L1'  // L1 = extractive only, L2 = contextual inference
    };
    
    try {
        const res = await fetch('/gemini/assess_profile', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(payload)
        });
        
        if(!res.ok) {
            const errorData = await res.json().catch(() => ({}));
            const errorMsg = errorData.error || `HTTP ${res.status}`;
            throw new Error(`Assessment API failed: ${errorMsg}`);
        }
        
        const data = await res.json();
        
        let starsHtml = '';
        const starCount = data.stars || 0;
        for(let i=0; i<5; i++) {
            starsHtml += `<span class="${i < starCount ? 'filled' : ''}">â˜…</span>`;
        }
        
        // Use assessment_level from backend data (authoritative source)
        // Fallback to is_level2 flag only for legacy data compatibility
        const isLevel2 = !!data.is_level2; // Used for styling only
        const headerText = data.assessment_level || (isLevel2 ? "L2 Assessment" : "L1 Assessment");
        const combinedHeader = `${headerText}: ${data.total_score || '0%'}`;
        
        // Build Category Appraisals HTML if available
        let categoryAppraisalsHtml = '';
        if (data.category_appraisals && typeof data.category_appraisals === 'object') {
            const categories = Object.entries(data.category_appraisals);
            console.log('[Assessment L2] category_appraisals entries:', categories.length, categories);
            if (categories.length > 0) {
                categoryAppraisalsHtml = '<div class="category-appraisals">';
                categoryAppraisalsHtml += '<div class="category-appraisals-title">Category Breakdown</div>';
                categoryAppraisalsHtml += '<table class="category-appraisals-table">';
                categoryAppraisalsHtml += '<thead><tr><th>Category</th><th>Weightage Score</th><th>Rating</th></tr></thead>';
                categoryAppraisalsHtml += '<tbody>';
                
                categories.forEach(([category, details]) => {
                    const weightPercent = details.weight_percent || 0;
                    const starString = details.star_string || '';
                    categoryAppraisalsHtml += `
                        <tr>
                            <td class="category-name">${escapeHtml(category)}</td>
                            <td class="category-weight">${weightPercent}%</td>
                            <td class="category-rating">${starString}</td>
                        </tr>
                    `;
                });
                
                categoryAppraisalsHtml += '</tbody></table></div>';
            }
        } else {
            console.log('[Assessment L2] No category_appraisals in data:', data);
        }
        
        // Overall Comment HTML if available
        let overallCommentHtml = '';
        if (data.overall_comment) {
            overallCommentHtml = `<div class="assessment-overall-comment" style="margin-top: 8px; padding: 8px; background: #f0f9ff; border-left: 3px solid #0ea5e9; font-size: 12px; font-style: italic; color: #0c4a6e;">${escapeHtml(data.overall_comment)}</div>`;
        }
        
        const fullHtml = `
            <div class="assessment-header" style="${isLevel2 ? 'color:#0969da' : ''}">${escapeHtml(combinedHeader)}</div>
            <div class="assessment-stars">${starsHtml}</div>
            ${overallCommentHtml}
            <div class="assessment-comments" style="margin-top: 8px; font-size: 11px; color: #6b7280;">Comments: ${escapeHtml(data.comments || 'None')}</div>
            ${categoryAppraisalsHtml}
        `;
        
        const tableHtml = `
            <div class="assessment-header" style="${isLevel2 ? 'color:#0969da' : ''}">${escapeHtml(combinedHeader)}</div>
            <div class="assessment-stars">${starsHtml}</div>
        `;

        if (container) {
            container.innerHTML = tableHtml;
            container.style.opacity = '1';
        }
        
        if (detailsContainer) {
            detailsContainer.innerHTML = fullHtml;
        }
        
        // Parse total score BEFORE caching
        let totalScoreVal = 0;
        try {
            totalScoreVal = parseInt(data.total_score.replace('%', '')) || 0;
        } catch(e) {}
        
        try {
            if(window.__sv_namecard && window.__sv_namecard.setCardCache) {
                // Store BOTH versions: full HTML for Details tab, table HTML for Search Results
                // PLUS total_score for icon logic
                window.__sv_namecard.setCardCache(anchor, { 
                    assessmentHTML: fullHtml,           // Full details for View tab
                    assessmentTableHTML: tableHtml,     // Simplified for Search Results table
                    totalScore: totalScoreVal           // Score value for conditional icon display
                });
            }
        } catch(e) { console.warn("Failed to cache assessment HTML (L2)", e); }

        // Render vskillset from assessment response into UI (table row & details card)
        try {
            if (data.vskillset && Array.isArray(data.vskillset) && data.vskillset.length > 0
                    && window.vskillset && typeof window.vskillset.renderVSkillsetToUI === 'function') {
                const highSkills = data.vskillset.filter(i => i && i.category === 'High').map(i => i.skill);
                window.vskillset.renderVSkillsetToUI(anchor, { vskillset: data.vskillset, skillset: highSkills });
                console.log('[Assessment] vskillset rendered from assessment response:', data.vskillset.length, 'skills,', highSkills.length, 'High');
            }
        } catch(e) { console.warn('[Assessment] Failed to render vskillset from assessment response', e); }

        const threshold = 50; 
        const ratingString = `${headerText}: ${data.total_score} (${starCount} â˜…) - ${data.comments || ''}`;

        // Rebate logic
        if (totalScoreVal < threshold) {
            if (typeof openRebateModal === 'function') {
                openRebateModal({
                    title: 'Rebate Eligible (Low Match Score)',
                    headerChip: 'Rebate',
                    body: `
                        <b>${escapeHtml(combinedHeader)}</b><br>
                        ${starsHtml} <span style="font-size:12px;color:#666">(${starCount} Stars)</span><br><br>
                        <b>Assessment Comments:</b><br>
                        <i>${escapeHtml(data.comments || 'No comments')}</i><br><br>
                        Since the match score is below ${threshold}%, this profile is flagged for rebate.
                    `,
                    primaryLabel: 'Confirm Rebate',
                    secondaryLabel: 'Do not Proceed',
                    onPrimary: async () => {
                        await applyTokenDelta(1);
                        rebateTokens += 1;
                        updateRebateTokenDisplay();
                        await deleteBackendRow(anchor);
                        autoDeleteRow(anchor);
                        try { await applyTokenDelta(-1); } catch(e){}
                        setStatus('Rebate confirmed & profile removed.', 'success');
                        refreshAccountTokens();
                        await loadRows(currentPage);
                    },
                    onSecondary: async () => {
                    try {
                        setStatus('Processing transfer (retaining sourcing row)...');
                        const ok = await transferSingleRecordViaMarketNoDelete({
                            name: (tr.querySelector('td[data-field="name"]')?.textContent || '').trim(),
                            company: company,
                            role: jobTitle,
                            country: country,
                            linkedinurl: anchor,
                            experience: '',
                            rating: ratingString 
                        });
                        if(ok) {
                            setStatus('Record transferred. Rebate declined.', 'success');
                            deepResearchBackgroundForAnchor(anchor);
                        }
                    } catch(e) { console.error(e); setStatus('Transfer action failed', 'error'); }
                }
            });
            }
        } else {
            // Level 2 / Success
            if (btn) markAssessmentComplete(btn);
        }

    } catch(e) {
        console.error("Combined Assessment failed", e);
        if(container) container.innerHTML = '<span class="error">Assessment failed.</span>';
        if(detailsContainer) detailsContainer.innerHTML = '<span class="error">Assessment failed.</span>';
        if(btn) {
            clearAssessmentActive(btn);
        }
    } finally {
        window.__sv_assessment_in_flight.delete(anchor);
    }
}

function markDirty(td) {
  if (!td.querySelector('.dirty-flag')) {
    const span = document.createElement('span');
    span.className = 'dirty-flag';
    span.textContent = '*';
    td.appendChild(span);
  }
}
function clearDirty(td) {
  const flag = td.querySelector('.dirty-flag');
  if (flag) flag.remove();
}

function extractFullTimeLine(content) {
  if (!content) return null;
  const linesRaw = content.split(/\r?\n/);
  const trimmed = linesRaw.map(l => (l || '').trim());
  let presentIdx = -1;
  for (let i = 0; i < trimmed.length; i++) {
    const t = trimmed[i];
    if (!t) continue;
    if (/\bPresent\b/i.test(t)) { presentIdx = i; break; }
  }
  if (presentIdx === -1) return null;
  for (let j = presentIdx - 1; j >= 0; j--) {
    const prev = trimmed[j];
    if (prev) return prev;
  }
  return null;
}

function extractJobTitleAboveCompany(content) {
  if (!content) return null;
  const linesRaw = content.split(/\r?\n/);
  const trimmed = linesRaw.map(l => (l || '').trim());
  let presentIdx = -1;
  for (let i = 0; i < trimmed.length; i++) {
    const t = trimmed[i];
    if (!t) continue;
    if (/\bPresent\b/i.test(t)) { presentIdx = i; break; }
  }
  if (presentIdx === -1) return null;
  let companyIdx = -1;
  for (let j = presentIdx - 1; j >= 0; j--) {
    if (trimmed[j]) { companyIdx = j; break; }
  }
  if (companyIdx <= 0) return null;
  for (let k = companyIdx - 1; k >= 0; k--) {
    if (trimmed[k]) return trimmed[k];
  }
  return null;
}

function stripFullTimeSuffix(s) {
  if (!s) return s;
  return s.replace(/\s*[-â€“â€”]\s*(Full[-\s]*time|Part[-\s]*time|Self[-\s]*employed)\b.*$/i, '').trim();
}

function extractJobTitleBeforeFirstFullTimeLine(content) {
  if (!content) return null;
  const linesRaw = content.split(/\r?\n/);
  const trimmed = linesRaw.map(l => l.trim());
  const isFullTime = (l) => /^.+?\s*[-â€“â€”]\s*Full[-\s]*time\b/i.test(l);
  const nonEmptyIdx = [];
  for (let i = 0; i < trimmed.length; i++) {
    if (trimmed[i]) nonEmptyIdx.push(i);
  }
  for (let k = 0; k < nonEmptyIdx.length; k++) {
    const idx = nonEmptyIdx[k];
    if (isFullTime(trimmed[idx])) {
      const prevK = k - 1;
      if (prevK >= 0) {
        const prevIdx = nonEmptyIdx[prevK];
        return trimmed[prevIdx];
      }
      return null;
    }
  }
  return null;
}

function debounceUpdate(linkedinurl, field, value, td) {
  const key = linkedinurl + '|' + field;
  if (pendingUpdate.has(key)) clearTimeout(pendingUpdate.get(key));
  const id = setTimeout(() => {
    sendUpdate(linkedinurl, field, value, td);
    pendingUpdate.delete(key);
  }, 650);
  pendingUpdate.set(key, id);
}
function flushImmediate(linkedinurl, field, value, td) {
  const key = linkedinurl + '|' + field;
  if (pendingUpdate.has(key)) { clearTimeout(pendingUpdate.get(key)); pendingUpdate.delete(key); }
  sendUpdate(linkedinurl, field, value, td);
}
async function sendUpdate(linkedinurl, field, value, td) {
  if (!linkedinurl || field === 'linkedinurl') return;
  const payload = { linkedinurl, field, value };
  if(td) td.style.opacity = .55;
  try {
    const res = await fetch(API_UPDATE, { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(payload) });
    const data = await res.json();
    if (!res.ok) throw new Error(data.error || 'Update failed');
    if(td) clearDirty(td);
    if(td) td.style.opacity = 1;
    try {
      const idx = rowsData.findIndex(r => r.linkedinurl === linkedinurl);
      if (idx !== -1) {
        const mapField = field === 'jobtitle' ? 'jobtitle' : field;
        rowsData[idx][mapField] = value;
      }
    } catch(e){ console.warn('rowsData sync failed', e); }
    setStatus(`Updated ${field}`, 'success');
    updateDisplayCounters();
  } catch(e) {
    if(td) td.style.opacity = 1;
    setStatus(e.message, 'error');
  }
}

async function loadRows(page=1){
  setStatus('Loading rowsâ€¦');
  tableBody.innerHTML = `<tr><td colspan="7" style="text-align:center; padding:30px;"><span class="spinner"></span> Loadingâ€¦</td></tr>`;
  currentPage = Math.max(1, page);
  try {
    const uid = window.__SV_ACTIVE_USERID || '';
    if(!uid){ throw new Error('Missing user session'); }
    const url = `${API_LIST}?userid=${encodeURIComponent(uid)}&page=${currentPage}&page_size=${PAGE_SIZE}`;
    const res = await fetch(url);
    const data = await res.json();
    if (!res.ok) throw new Error(data.error || 'Failed to load');
    rowsData = Array.isArray(data.rows) ? data.rows : [];
    totalRowCount = data.total || rowsData.length;
    if (!rowsData.length) {
      tableBody.innerHTML = `<tr><td colspan="7" style="text-align:center; padding:24px; color:#57606a;">No rows found.</td></tr>`;
      setStatus('No data.');
      updateDisplayCounters();
      renderPager();
      return;
    }
    setStatus(`Loaded page ${currentPage} (${rowsData.length} row(s)).`);
    renderTable();
    renderPager();
  } catch(e) {
    tableBody.innerHTML = `<tr><td colspan="7" style="text-align:center; padding:24px; color:#d1242f;">${escapeHtml(e.message || 'Load failed')}</td></tr>`;
    setStatus(e.message,'error');
    rowsData = [];
    totalRowCount = 0;
    renderPager();
  } finally {
    updateDisplayCounters();
    // Delete button removed per requirements
    // deleteBtn.style.display='none';
    // selectAllCb.checked=false;
  }
}
function renderTable(){
  tableBody.innerHTML='';
  rowsData.forEach(r=> tableBody.appendChild(buildRow(r)));
}

/* --- AFFECTED: Namecard UI injection modified for Tab Layout --- */
(function(){
  const CACHE_KEY = 'sv_namecard_cache_v1';
  const OPEN_STATE_KEY = 'sv_namecard_open_state_v1';

  function readCache() {
    try {
      const raw = localStorage.getItem(CACHE_KEY);
      const obj = raw ? JSON.parse(raw) : {};
      return obj && typeof obj === 'object' ? obj : {};
    } catch(_) { return {}; }
  }
  function writeCache(cache) {
    try { localStorage.setItem(CACHE_KEY, JSON.stringify(cache || {})); } catch(_) {}
  }
  function setCardCache(anchor, data) {
    if (!anchor) return;
    const cache = readCache();
    const prev = cache[anchor] || {};
    cache[anchor] = Object.assign({}, prev, data || {});
    writeCache(cache);
  }
  function getCardCache(anchor) {
    const cache = readCache();
    return cache[anchor] || null;
  }
  
  function formatExperienceHtml(raw) {
    const s = String(raw || '').trim();
    if (!s) return 'â€”';
    const lines = s.replace(/\r/g, '').split(/\n/).map(l => l.trim()).filter(Boolean);
    if (!lines.length) return escapeHtml(s);
    const out = [];
    
    if (!/^experience$/i.test(lines[0])) {
      out.push('<strong>Experience</strong>');
    }

    for (let i = 0; i < lines.length; i++) {
      const ln = lines[i];
      if (/^experience$/i.test(ln)) {
        out.push('<strong>Experience</strong>');
      } else if (/^education$/i.test(ln)) {
        out.push('<br>');
        out.push('<strong>Education</strong>');
      } else if (/^language$/i.test(ln) || /^languages?$/i.test(ln)) {
        out.push('<br>');
        out.push('<strong>Language</strong>');
      } else {
        out.push(escapeHtml(ln));
      }
    }
    return out.join('<br>');
  }

  function displayCompanyValueStatic(rawCompany) {
    return (rawCompany || '').toString().trim();
  }

  function normalizeSkillset(input) {
    if (!input) return [];
    let arr = [];
    if (Array.isArray(input)) {
      arr = input.slice();
    } else {
      arr = String(input).split(/[,;|]/);
    }
    return arr.map(s => s.trim()).filter(Boolean);
  }

  function composeJobFamilyLine(jobFamily, sector) {
    try {
      // Sanitize incoming values to remove embedded geographic fragments and ensure format:
      // Job Family: <jobfamily> | <sector>
      let jf = (jobFamily || '').toString().trim();
      let sc = (sector || '').toString().trim();

      // If values include pipe-separated extra parts, keep only the first meaningful part.
      if (jf.indexOf('|') !== -1) jf = jf.split('|')[0].trim();
      if (sc.indexOf('|') !== -1) sc = sc.split('|')[0].trim();

      const parts = [];
      if (jf) parts.push(jf);
      if (sc && sc.toLowerCase() !== jf.toLowerCase()) parts.push(sc);
      if (!parts.length) return '';
      return '<span class="sv-jobfamily-label">Job Family:</span> ' + escapeHtml(parts.join(' | '));
    } catch (e) {
      return '';
    }
  }

  function formatSeniorityForDisplay(s) {
    try {
      const src = (s || '').toString().trim();
      if (!src) return '';
      const out = /\blevel$/i.test(src) ? src : (src + ' Level');
      return `(${escapeHtml(out)})`;
    } catch (_) {
      return '';
    }
  }

  function ensureSkillsetColumn(cardOrContainer) {
    if (!cardOrContainer) return null;
    let col = cardOrContainer.querySelector('.sv-skillset-col:not(.sv-product-col)');
    if (!col) {
      col = document.createElement('div');
      col.className = 'sv-skillset-col';
      const head = document.createElement('div');
      head.className = 'sv-skillset-head';
      head.textContent = 'Skillsets';
      const list = document.createElement('div');
      list.className = 'sv-skillset-list';
      
      // Add loading spinner initially
      const loadingSpinner = document.createElement('div');
      loadingSpinner.className = 'skillset-loading-spinner';
      loadingSpinner.style.cssText = 'display: flex; align-items: center; gap: 8px; padding: 8px; color: #6b7280;';
      loadingSpinner.innerHTML = '<span class="spinner" style="width: 16px; height: 16px; border-width: 2px;"></span><span style="font-size: 12px;">Loading skillsets...</span>';
      list.appendChild(loadingSpinner);
      
      col.appendChild(head);
      col.appendChild(list);
      
      if (cardOrContainer.classList.contains('sv-right-col')) {
         cardOrContainer.insertBefore(col, cardOrContainer.firstChild || null);
      } else {
        const rightCol = cardOrContainer.querySelector('.sv-right-col');
        if (rightCol) {
          rightCol.insertBefore(col, rightCol.firstChild || null);
        } else {
          cardOrContainer.appendChild(col);
        }
      }
    }
    return col;
  }
  function renderSkillsets(skillset, col, vskillset) {
    if (!col) return;
    const listEl = col.querySelector('.sv-skillset-list');
    if (!listEl) return;
    
    // Remove loading spinner if present
    const loadingSpinner = listEl.querySelector('.skillset-loading-spinner');
    if (loadingSpinner) loadingSpinner.remove();
    
    const norm = normalizeSkillset(skillset);
    
    const existing = [...listEl.querySelectorAll('.rebate-chip')].map(c=>c.textContent.trim());
    
    // Always render from skillset column (plain rendering without vskillset annotations)
    norm.forEach(s => {
      if(!existing.includes(s) && s !== 'â€”') {
        const chip = document.createElement('span');
        chip.className = 'rebate-chip';
        chip.textContent = s;
        listEl.appendChild(chip);
      }
    });
    
    if (listEl.querySelectorAll('.rebate-chip').length > 1) {
      const place = [...listEl.querySelectorAll('.rebate-chip')].find(c=>c.textContent === 'â€”');
      if(place) place.remove();
    }
    
    if (!listEl.children.length) {
      const chip = document.createElement('span');
      chip.className = 'rebate-chip';
      chip.textContent = 'â€”';
      listEl.appendChild(chip);
    }
  }

  function ensureProductColumn(cardOrContainer) {
    if (!cardOrContainer) return null;
    let col = cardOrContainer.querySelector('.sv-product-col');
    if (!col) {
      col = document.createElement('div');
      col.className = 'sv-skillset-col sv-product-col';
      
      const head = document.createElement('div');
      head.className = 'sv-skillset-head';
      head.textContent = 'Product';
      
      const list = document.createElement('div');
      list.className = 'sv-skillset-list';
      
      // Add loading spinner initially
      const loadingSpinner = document.createElement('div');
      loadingSpinner.className = 'product-loading-spinner';
      loadingSpinner.style.cssText = 'display: flex; align-items: center; gap: 8px; padding: 8px; color: #6b7280;';
      loadingSpinner.innerHTML = '<span class="spinner" style="width: 16px; height: 16px; border-width: 2px;"></span><span style="font-size: 12px;">Loading product...</span>';
      list.appendChild(loadingSpinner);
      
      col.appendChild(head);
      col.appendChild(list);

      if (cardOrContainer.classList.contains('sv-right-col')) {
          const exp = cardOrContainer.querySelector('.sv-experience');
          if(exp) {
              cardOrContainer.insertBefore(col, exp);
          } else {
              cardOrContainer.appendChild(col);
          }
      } else {
          const rightCol = cardOrContainer.querySelector('.sv-right-col');
          if (rightCol) {
             const exp = rightCol.querySelector('.sv-experience');
             if(exp) rightCol.insertBefore(col, exp);
             else rightCol.appendChild(col);
          } else {
             cardOrContainer.appendChild(col);
          }
      }
    }
    return col;
  }

  function renderProducts(products, col) {
    if (!col) return;
    const listEl = col.querySelector('.sv-skillset-list');
    if (!listEl) return;
    
    // Always remove loading spinner if present
    const loadingSpinner = listEl.querySelector('.product-loading-spinner');
    if (loadingSpinner) loadingSpinner.remove();
    
    // Normalize products array
    const norm = normalizeSkillset(products);
    
    const existing = [...listEl.querySelectorAll('.rebate-chip')].map(c=>c.textContent.trim());
    
    norm.forEach(s => {
      if(!existing.includes(s) && s !== 'â€”') {
        const chip = document.createElement('span');
        chip.className = 'rebate-chip';
        chip.textContent = s;
        listEl.appendChild(chip);
      }
    });
    
    if (listEl.querySelectorAll('.rebate-chip').length > 1) {
        const place = [...listEl.querySelectorAll('.rebate-chip')].find(c=>c.textContent === 'â€”');
        if(place) place.remove();
    }
    
    // Ensure there's at least a placeholder if no products
    if (listEl.querySelectorAll('.rebate-chip').length === 0) {
      const chip = document.createElement('span');
      chip.className = 'rebate-chip';
      chip.textContent = 'â€”';
      listEl.appendChild(chip);
    }
  }

  function renderVSkillsetTable(vskillset, container) {
    if (!container || !vskillset || !Array.isArray(vskillset) || vskillset.length === 0) return;
    
    const tbody = container.querySelector('.vskillset-tbody');
    if (!tbody) return;
    
    tbody.innerHTML = '';
    vskillset.forEach(item => {
      const tr = document.createElement('tr');
      tr.style.cssText = 'border-bottom: 1px solid #e5e7eb;';
      
      const categoryColor = item.category === 'High' ? '#10b981' : item.category === 'Medium' ? '#f59e0b' : '#6b7280';
      
      tr.innerHTML = `
        <td style="padding: 8px;">${escapeHtml(item.skill || '')}</td>
        <td style="padding: 8px;">${item.probability || 0}%</td>
        <td style="padding: 8px;"><span style="display: inline-block; padding: 2px 8px; border-radius: 4px; background: ${categoryColor}; color: white; font-weight: 600;">${escapeHtml(item.category || '')}</span></td>
        <td style="padding: 8px; font-size: 11px; color: #6b7280;">${escapeHtml(item.reason || 'No reason provided')}</td>
      `;
      tbody.appendChild(tr);
    });
  }

  /* Helper function to create error/warning notices in View Details tab */
  function createViewDetailsNotice(config) {
    const { type, title, message, reasons, instructions } = config;
    const isWarning = type === 'warning';
    
    const errorNotice = document.createElement('div');
    errorNotice.style.cssText = isWarning
      ? 'background: #fef3c7; border: 1px solid #f59e0b; border-radius: 8px; padding: 12px; margin: 16px 0; color: #92400e; font-size: 14px;'
      : 'background: #fee2e2; border: 1px solid #ef4444; border-radius: 8px; padding: 12px; margin: 16px 0; color: #991b1b; font-size: 14px;';
    
    // Create title
    const titleEl = document.createElement('strong');
    titleEl.textContent = title;
    errorNotice.appendChild(titleEl);
    errorNotice.appendChild(document.createElement('br'));
    
    // Add main message
    if (message) {
      errorNotice.appendChild(document.createTextNode(message));
      errorNotice.appendChild(document.createElement('br'));
    }
    
    // Add reasons if provided
    if (reasons && Array.isArray(reasons)) {
      reasons.forEach(reason => {
        errorNotice.appendChild(document.createTextNode('â€¢ ' + reason));
        errorNotice.appendChild(document.createElement('br'));
      });
    }
    
    // Add instructions
    if (instructions) {
      errorNotice.appendChild(document.createTextNode(instructions));
    }
    
    return errorNotice;
  }

  /* REFACTORED: renderNameCardToTab instead of creating a table row */
  function renderNameCardToTab(tr) {
    if(!tr) return null;
    const container = document.getElementById('details-container');
    container.innerHTML = ''; // Clear previous

    const tds = tr.querySelectorAll('td');
    // Index 0: checkbox, Index 1: picture, Index 2: name, Index 3: company, Index 4: jobtitle, Index 5: country, Index 6: credential, Index 7: matching
    const picCell = tds[1];
    const picData = picCell ? (picCell.querySelector('img')?.src || '') : '';
    const name = (tds[2]?.textContent || '').trim() || 'â€”';
    const company = (tds[3]?.textContent || '').trim() || 'â€”';
    const companyCell = tr.querySelector('td[data-field="company"]') || tds[3];
    const sector = (companyCell && companyCell.dataset && companyCell.dataset.sector) ? companyCell.dataset.sector.trim() : (company || 'â€”');
    const jobTitle = (tds[4]?.textContent || '').trim() || 'â€”';
    const rowCountry = (tds[5]?.textContent || '').trim() || '';

    let experience = '';
    try {
      const expCell = tr.querySelector('td[data-field="experience"]') || tds[7];
      if (expCell) {
          if (expCell.dataset.experience) {
              experience = expCell.dataset.experience;
          } else if (expCell.querySelector('.assessment-result-container')) {
              experience = '';
          } else {
              const ta = expCell.querySelector('textarea');
              if (ta && ta.value) experience = ta.value.trim();
              else experience = expCell.textContent.trim();
          }
      }
    } catch (_) { }
    if (!experience || experience === 'â€”') experience = 'â€”';

    const lnBtn = tr.querySelector('td[data-field="linkedinurl"] .view-btn');
    const linkedinurl = lnBtn ? (lnBtn.dataset.profileUrl || '').trim() : (tds[6]?.textContent || '').trim();

    /* No newTr, just the content div */
    const content = document.createElement('div');
    content.className = 'sv-namecard';
    /* Store anchor on container for updates */
    content.dataset.anchor = tr.dataset.linkedinurl || linkedinurl || '';

    // Add profile picture at the very top
    const profilePicContainer = document.createElement('div');
    profilePicContainer.style.cssText = 'text-align: center; margin-bottom: 16px; padding: 16px; background: linear-gradient(180deg, #f9fafb 0%, #ffffff 100%); border-radius: 8px;';
    
    // Use picData from the table cell
    let picSrc = null;
    if (picData && picData.trim()) {
      picSrc = picData; // Already processed in the table cell
    }
    
    if (picSrc) {
      const profileImg = document.createElement('img');
      profileImg.src = picSrc;
      profileImg.alt = name;
      profileImg.style.cssText = 'width:150px; height:150px; border-radius:50%; object-fit:cover; border:3px solid #e5e7eb; box-shadow: 0 4px 6px rgba(0,0,0,0.1);';
      profileImg.onerror = function() {
        this.style.display = 'none';
        const placeholder = document.createElement('div');
        placeholder.style.cssText = 'width:150px; height:150px; border-radius:50%; background:#f3f4f6; display:inline-flex; align-items:center; justify-content:center; color:#9ca3af; font-weight:700; font-size:56px; border:3px solid #e5e7eb; box-shadow: 0 4px 6px rgba(0,0,0,0.1);';
        placeholder.textContent = name.charAt(0).toUpperCase();
        this.parentNode.appendChild(placeholder);
      };
      profilePicContainer.appendChild(profileImg);
    } else {
      const placeholder = document.createElement('div');
      placeholder.style.cssText = 'width:150px; height:150px; border-radius:50%; background:#f3f4f6; display:inline-flex; align-items:center; justify-content:center; color:#9ca3af; font-weight:700; font-size:56px; margin:0 auto; border:3px solid #e5e7eb; box-shadow: 0 4px 6px rgba(0,0,0,0.1);';
      placeholder.textContent = name.charAt(0).toUpperCase();
      profilePicContainer.appendChild(placeholder);
    }
    
    // Add name immediately below picture
    const profileNameEl = document.createElement('div');
    profileNameEl.style.cssText = 'margin-top: 12px; font-size: 20px; font-weight: 700; color: #1f2328;';
    profileNameEl.textContent = name;
    profilePicContainer.appendChild(profileNameEl);
    
    // Add country|geographic below name
    const countryGeographicEl = document.createElement('div');
    countryGeographicEl.style.cssText = 'margin-top: 4px; font-size: 14px; color: #6b7280; font-weight: 400;';
    countryGeographicEl.setAttribute('aria-label', 'Location');
    countryGeographicEl.textContent = ''; // Will be populated asynchronously
    profilePicContainer.appendChild(countryGeographicEl);
    
    content.appendChild(profilePicContainer);

    const left = document.createElement('div');
    left.className = 'sv-left';
    const titleEl = document.createElement('div');
    titleEl.className = 'sv-name';
    titleEl.textContent = name;
    titleEl.style.display = 'none'; // Hide since we show it at top now

    const jobEl = document.createElement('div');
    jobEl.className = 'sv-job';
    jobEl.textContent = jobTitle;

    const seniorityEl = document.createElement('div');
    seniorityEl.className = 'sv-seniority';
    seniorityEl.style.cssText = 'font-size:12px;color:#6b7280;margin-top:0;margin-bottom:6px;';
    seniorityEl.textContent = ''; 

    const expEl = document.createElement('div');
    expEl.className = 'sv-exp-years';
    expEl.style.cssText = 'font-size:12px;color:#6b7280;margin-top:-4px;margin-bottom:6px;font-weight:600;';
    expEl.textContent = ''; 

    const compEl = document.createElement('div');
    compEl.className = 'sv-company';
    compEl.textContent = displayCompanyValueStatic(company) || 'â€”';
    const sectorEl = document.createElement('div');
    sectorEl.className = 'sv-sector';
    // We'll show sector (from database or cached sector) in sector element. Geographic/country will not be appended here.
    sectorEl.textContent = sector || rowCountry || 'â€”';

    // *** NEW: Matching Level Display in Details Tab ***
    const matchingLevelContainer = document.createElement('div');
    matchingLevelContainer.className = 'assessment-result-container'; // Add class for styling
    matchingLevelContainer.style.cssText = 'margin-top: 16px; padding: 12px; background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 8px;';
    
    // *** NEW: Action Buttons for Assessment in Details Tab ***
    const assessmentActionContainer = document.createElement('div');
    assessmentActionContainer.style.cssText = 'margin-top: 8px; display: flex; gap: 8px; justify-content: flex-end;';

    const cachedCard = getCardCache(content.dataset.anchor);
    let currentScore = 0;
    
    if (cachedCard && cachedCard.assessmentHTML) {
        matchingLevelContainer.innerHTML = cachedCard.assessmentHTML;
        
        // Extract score from HTML if possible
        const m = cachedCard.assessmentHTML.match(/(\d+)%/);
        if (m) currentScore = parseInt(m[1], 10);
        
        // Dynamic Button Logic
        if (currentScore > 0) {
            if (currentScore < 50) {
                // Show Rebate Button
                const rebateBtn = document.createElement('button');
                rebateBtn.textContent = 'Rebate';
                rebateBtn.className = 'review-action-btn rebate';
                rebateBtn.style.padding = '6px 12px';
                rebateBtn.onclick = async () => {
                    const anchor = content.dataset.anchor;
                    if (!anchor) return;
                    if (!confirm(`Rebate this profile due to low score (${currentScore}%)? This will delete the entry and credit a token.`)) return;
                    
                    matchingLevelContainer.innerHTML += '<br>Processing rebate...';
                    
                    try {
                        await applyTokenDelta(1);
                        rebateTokens += 1;
                        updateRebateTokenDisplay();
                        await deleteBackendRow(anchor);
                        autoDeleteRow(anchor); // Helper to remove from UI table
                        try { await applyTokenDelta(-1); } catch(e){}
                        
                        alert('Rebate processed successfully.');
                        switchTab('tab-search'); // Go back to search
                        await loadRows(currentPage); // Refresh list
                    } catch(e) {
                        alert('Rebate failed: ' + e.message);
                    }
                };
                assessmentActionContainer.appendChild(rebateBtn);
            } else {
                // Show Appeal Button
                const appealBtn = document.createElement('button');
                appealBtn.textContent = 'Appeal';
                appealBtn.className = 'review-action-btn view'; // Use neutral style
                appealBtn.style.padding = '6px 12px';
                appealBtn.onclick = () => {
                    const anchor = content.dataset.anchor;
                    const justification = prompt("Please enter your justification for appeal:");
                    if (justification) {
                        alert("Appeal submitted for review.");
                        // Here you would typically call an API to save the appeal
                    }
                };
                assessmentActionContainer.appendChild(appealBtn);
            }
        }
    } else {
        matchingLevelContainer.innerHTML = '<span style="color:#999; font-size:12px;">(Assessment pending)</span>';
    }
    
    matchingLevelContainer.appendChild(assessmentActionContainer);

    /* --- AFFECTED: Action Buttons Container (Stacked) --- */
    const actionButtonsContainer = document.createElement('div');
    actionButtonsContainer.style.cssText = 'display: flex; flex-direction: column; gap: 8px; margin-top: 16px; align-items: center; width: 100%;';

    const assessBtn = document.createElement('button');
    assessBtn.className = 'sv-assess-btn';
    assessBtn.type = 'button';
    assessBtn.textContent = 'Open LinkedIn';
    assessBtn.style.width = '100%'; // Full width
    // Ensure button is always enabled (as requested)
    assessBtn.disabled = false;
    if (linkedinurl) {
      assessBtn.dataset.linkedin = linkedinurl;
      assessBtn.addEventListener('click', (e) => {
        try {
          // AFFECTED: Save JSON before opening
          const uid = window.__SV_ACTIVE_USERID || '';
          fetch('/sourcing/save_profile_json', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ linkedinurl: linkedinurl, userid: uid })
          }).catch(err => console.warn('JSON save failed', err));

          const url = assessBtn.dataset.linkedin;
          if (!url) {
            alert('No LinkedIn URL available');
            return;
          }
          
          // Validate LinkedIn URL before rendering to avoid broken links
          let validatedUrl = url;
          if (!url.startsWith('http://') && !url.startsWith('https://')) {
            validatedUrl = 'https://' + url;
          }
          
          window.open(validatedUrl, '_blank', 'noopener');
        } catch (_) {}
      });
    } else {
      // Even without URL, keep button enabled but show alert on click
      assessBtn.addEventListener('click', () => alert('No LinkedIn URL available'));
      assessBtn.title = 'No LinkedIn URL available';
    }

    const browseBtn = document.createElement('button');
    browseBtn.className = 'sv-assess-btn';
    browseBtn.type = 'button';
    browseBtn.textContent = 'Browse File';
    browseBtn.title = 'Upload PDF CV to Process Table';
    browseBtn.style.width = '100%'; // Full width
    browseBtn.style.backgroundColor = '#ffffff'; 
    browseBtn.style.color = '#24292f'; 
    browseBtn.style.border = '1px solid #d0d7de'; 

    // Insert Assess Button Here (respects L1/L2 toggle)
    const assessBtn2 = document.createElement('button');
    assessBtn2.className = 'sv-assess-btn';
    assessBtn2.type = 'button';
    assessBtn2.textContent = 'Assess';
    assessBtn2.title = 'Run Fresh Assessment (respects current toggle mode)';
    assessBtn2.style.width = '100%'; // Full width
    assessBtn2.style.backgroundColor = '#f0fdf4'; 
    assessBtn2.style.color = '#15803d'; 
    assessBtn2.style.border = '1px solid #bbf7d0';

    // Check if assessment was already completed for this profile
    // Also migrate old level2AssessmentState data to new assessmentState
    try {
        let assessState = JSON.parse(localStorage.getItem('assessmentState') || '{}');
        
        // Migrate old level2AssessmentState data if it exists
        try {
            const oldL2State = JSON.parse(localStorage.getItem('level2AssessmentState') || '{}');
            if (Object.keys(oldL2State).length > 0) {
                // Merge old L2 data into new assessState with mode: 'L2'
                Object.keys(oldL2State).forEach(key => {
                    if (!assessState[key]) {
                        assessState[key] = { ...oldL2State[key], mode: 'L2' };
                    }
                });
                localStorage.setItem('assessmentState', JSON.stringify(assessState));
                // Optionally clear old state after migration
                localStorage.removeItem('level2AssessmentState');
            }
        } catch (migrationError) {
            console.warn('Failed to migrate old assessment state:', migrationError);
        }
        
        const profileAnchor = tr.dataset.linkedinurl || linkedinurl || '';
        const currentMode = 'L2';  // Always use L2 (inference mode)
        
        if (assessState[profileAnchor] && assessState[profileAnchor].completed) {
            const storedMode = assessState[profileAnchor].mode || 'L2'; // Default to L2 for old data
            
            // Only show as "Assessed" if mode matches current mode
            if (storedMode === currentMode) {
                assessBtn2.textContent = 'Assessed';
                assessBtn2.disabled = true;
            } else {
                // Different mode - allow re-assessment
                assessBtn2.title = `Run Fresh ${currentMode} Assessment (previously assessed in ${storedMode} mode)`;
            }
        }
    } catch (e) {
        console.warn('Failed to load assessment state:', e);
    }

    assessBtn2.addEventListener('click', async () => {
        const anchor = content.dataset.anchor || tr.dataset.linkedinurl || linkedinurl || '';
        if(!anchor) return;
        
        // All assessments use L2 (inference mode) by default
        const useL2 = true;
        const assessmentMode = 'L2';
        
        assessBtn2.disabled = true;
        assessBtn2.textContent = 'Preparing...';
        // Global setStatus if available
        if(typeof setStatus === 'function') setStatus(`Preparing ${assessmentMode} analysis...`, 'info');

        try {
            const res = await fetch('/process/parse_cv_and_update', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ linkedinurl: anchor })
            });
            const analyzeData = await res.json();

            if (res.ok) {
                if(typeof setStatus === 'function') setStatus(`Running ${assessmentMode} Assessment...`, 'info');
                
                // Trigger assessment based on current toggle state
                await performCombinedAssessment(tr, anchor, analyzeData, useL2);
                
                assessBtn2.textContent = 'Assessed';
                assessBtn2.disabled = true;  // Keep button disabled after successful completion
                
                // Persist disabled state in localStorage
                try {
                    const assessState = JSON.parse(localStorage.getItem('assessmentState') || '{}');
                    assessState[anchor] = { completed: true, timestamp: Date.now(), mode: assessmentMode };
                    localStorage.setItem('assessmentState', JSON.stringify(assessState));
                } catch (e) {
                    console.warn('Failed to persist assessment state:', e);
                }
                
                if(typeof setStatus === 'function') setStatus(`${assessmentMode} Assessment Complete`, 'success');
                
                // Auto-refresh after individual assessment completion
                // Wait 1 second then simulate click on Refresh button
                setTimeout(() => {
                    const reloadBtn = document.getElementById('reloadBtn');
                    if (reloadBtn) {
                        reloadBtn.click();
                    }
                }, 1000);
            } else {
                assessBtn2.textContent = 'Failed';
                assessBtn2.disabled = false;
                if(typeof setStatus === 'function') setStatus('Analysis failed: ' + (analyzeData.error || 'Unknown'), 'error');
            }
        } catch(e) {
            console.error("Assessment click error", e);
            assessBtn2.textContent = 'Error';
            assessBtn2.disabled = false;
            if(typeof setStatus === 'function') setStatus('Assessment Error', 'error');
        }
    });

    const downloadBtn = document.createElement('button');
    downloadBtn.className = 'sv-assess-btn sv-download-btn';
    downloadBtn.type = 'button';
    downloadBtn.textContent = 'Download CV';
    downloadBtn.title = 'Download stored PDF CV';
    downloadBtn.style.width = '100%'; // Full width
    downloadBtn.style.display = 'none'; 
    downloadBtn.style.backgroundColor = '#f6f8fa';
    downloadBtn.style.color = '#0969da';
    downloadBtn.style.border = '1px solid #d0d7de';

    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = 'application/pdf,application/msword,application/vnd.openxmlformats-officedocument.wordprocessingml.document';
    fileInput.style.display = 'none';

    browseBtn.addEventListener('click', (e) => {
      fileInput.click();
    });

    fileInput.addEventListener('change', async () => {
      if (!fileInput.files || !fileInput.files.length) return;
      const file = fileInput.files[0];
      // AFFECTED: Allow doc/docx too
      if (file.type !== 'application/pdf' && !file.name.match(/\.(doc|docx)$/i)) {
        alert('Please upload a PDF or DOC file.');
        fileInput.value = ''; 
        return;
      }
      
      const anchor = content.dataset.anchor || tr.dataset.linkedinurl || linkedinurl || '';
      if (!anchor) {
        alert('Error: No linked profile URL found.');
        return;
      }

      const origText = browseBtn.textContent;
      browseBtn.disabled = true;
      browseBtn.textContent = 'Uploading...';

      const fd = new FormData();
      fd.append('cv', file); 
      fd.append('linkedinurl', anchor);
      const uid = window.__SV_ACTIVE_USERID || '';
      if (uid) fd.append('userid', uid);
      
      // AFFECTED: Pass name explicitly for process table insertion
      if (name && name !== 'â€”') {
        // Clean unwanted characters before uploading
        const cleanedName = cleanNameForUpload(name);
        fd.append('name', cleanedName);
      }

      try {
        const res = await fetch(API_UPLOAD_CV, {
          method: 'POST',
          body: fd,
          credentials: 'same-origin'
        });
        
        if (res.ok) {
          browseBtn.textContent = 'CV Saved. Analyzing...';
          browseBtn.style.color = '#1a7f37';
          browseBtn.style.borderColor = '#1a7f37';
          
          try {
            const analyzeRes = await fetch(API_PARSE_CV_AND_UPDATE, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ linkedinurl: anchor })
            });
            const analyzeData = await analyzeRes.json();
            
            if (analyzeRes.ok) {
                // AFFECTED: Update main row cells from analysis result (Job, Company, Country)
                // We'll try to extract country from location if present
                const newCompany = analyzeData.company || analyzeData.organisation || '';
                const newJob = analyzeData.job_title || analyzeData.jobtitle || '';
                const newCountry = analyzeData.country || analyzeData.location || ''; // assuming API returns country/location

                // NEW: Consistency with Snipper workflow - save text, show progress, run assessment
                if (analyzeData.experience_text) {
                    try { /* saveSnipperCheck removed */ } catch(e) { console.warn("Failed to save snippercheck", e); }
                }

                // Locate the assessment button for this row to show progress
                let btn = null;
                try { btn = tr.querySelector('.view-btn'); } catch(e) {}
                
                if (btn) {
                    try {
                        setAssessmentActive(btn);
                    } catch(e) { console.warn("Failed to set progress UI", e); }
                }

                // Update Row Cells
                if (newCompany) {
                    const cCell = tr.querySelector('td[data-field="company"]');
                    if(cCell) { cCell.textContent = newCompany; markDirty(cCell); flushImmediate(anchor, 'company', newCompany, cCell); }
                }
                if (newJob) {
                    const jCell = tr.querySelector('td[data-field="jobtitle"]');
                    if(jCell) { jCell.textContent = newJob; markDirty(jCell); flushImmediate(anchor, 'jobtitle', newJob, jCell); }
                }
                if (newCountry) {
                    const cntCell = tr.querySelector('td[data-field="country"]');
                    if(cntCell) { cntCell.textContent = newCountry; markDirty(cntCell); flushImmediate(anchor, 'country', newCountry, cntCell); }
                }

                // Update namecard as before
                updateNameCard(tr, {
                    skillset: analyzeData.skillset,
                    experience: analyzeData.experience_text || analyzeData.experience,
                    exp: analyzeData.total_years || analyzeData.exp,
                    education: analyzeData.education_text || analyzeData.education,
                    company: newCompany, // Pass these to updateNameCard too so card reflects it
                    jobtitle: newJob,
                    country: newCountry,
                    tenure: analyzeData.tenure // preferred if backend provided it
                });

                const expTd = tr.querySelector('td[data-field="experience"]');
                if(expTd && analyzeData.experience_text) {
                    expTd.dataset.experience = analyzeData.experience_text;
                    markDirty(expTd);
                    flushImmediate(anchor, 'experience', analyzeData.experience_text, expTd);
                }

                // All assessments use L2 (inference mode) by default
                const useL2 = true;

                // Trigger Assessment immediately after parsing with toggle state
                try {
                    await performCombinedAssessment(tr, anchor, analyzeData, useL2);
                    
                    // Auto-refresh after individual assessment completion
                    // Wait 1 second then simulate click on Refresh button
                    setTimeout(() => {
                        const reloadBtn = document.getElementById('reloadBtn');
                        if (reloadBtn) {
                            reloadBtn.click();
                        }
                    }, 1000);
                } catch(e) {
                    console.error("Assessment failed after upload", e);
                    if (btn) {
                        clearAssessmentActive(btn);
                    }
                }

                browseBtn.textContent = 'Analyzed';
            } else {
                console.warn('Analysis failed', analyzeData.error);
                browseBtn.textContent = 'Saved (Analysis Failed)';
            }
          } catch(err) {
            console.error('Analysis trigger error', err);
             browseBtn.textContent = 'Saved';
          }
          
          browseBtn.title = 'File uploaded successfully';
          
          downloadBtn.style.display = 'inline-block';
          setCardCache(anchor, { cv: true }); 
          
           setTimeout(() => {
              browseBtn.textContent = origText;
              browseBtn.disabled = false;
              browseBtn.style.color = '#24292f';
              browseBtn.style.borderColor = '#d0d7de';
            }, 3000);

        } else {
          const d = await res.json().catch(()=>({}));
          throw new Error(d.error || 'Upload failed');
        }
      } catch (err) {
        console.error('CV upload failed', err);
        browseBtn.textContent = 'Failed';
        browseBtn.style.color = '#cf222e';
        browseBtn.style.borderColor = '#cf222e';
        setTimeout(() => {
          browseBtn.textContent = origText;
          browseBtn.disabled = false;
          browseBtn.style.color = '#24292f';
          browseBtn.style.borderColor = '#d0d7de';
        }, 2500);
      }
      fileInput.value = ''; 
    });

    if (linkedinurl) {
      downloadBtn.addEventListener('click', () => {
        const anchor = content.dataset.anchor || tr.dataset.linkedinurl || linkedinurl || '';
        if(anchor){
           window.open(API_DOWNLOAD_CV + '?linkedin=' + encodeURIComponent(anchor), '_blank');
        }
      });
    }

    /* Append elements to Action Container */
    // Add matching level (Assessment) card FIRST, above the buttons
    actionButtonsContainer.appendChild(matchingLevelContainer);
    actionButtonsContainer.appendChild(assessBtn);
    actionButtonsContainer.appendChild(browseBtn);
    actionButtonsContainer.appendChild(assessBtn2); // Renamed from level2Btn
    actionButtonsContainer.appendChild(downloadBtn);
    actionButtonsContainer.appendChild(fileInput);

    // Move buttons directly below profile name
    profilePicContainer.appendChild(actionButtonsContainer);

    // LEFT COLUMN: Job Title, Seniority, Average Tenure, Company Name
    left.appendChild(titleEl);
    left.appendChild(jobEl);  // Job Title
    left.appendChild(seniorityEl);  // Seniority
    left.appendChild(expEl);  // Average Tenure
    left.appendChild(compEl);  // Company Name
    
    const skillCol = ensureSkillsetColumn(left);  // Skillsets - moved to left
    const prodCol = ensureProductColumn(left);  // Product - moved to left

    const mid = document.createElement('div');
    mid.className = 'sv-experience';
    try {
      mid.innerHTML = formatExperienceHtml(experience);
    } catch (e) {
      mid.textContent = experience;
    }
    
    left.appendChild(mid);  // Experience - moved to left
    
    // Add collapsible vskillset table after experience/education section
    const vskillsetSection = document.createElement('div');
    vskillsetSection.className = 'vskillset-section';
    vskillsetSection.style.cssText = 'margin-top: 16px; border-top: 1px solid #e5e7eb; padding-top: 12px;';
    
    const vskillsetHeader = document.createElement('div');
    vskillsetHeader.className = 'vskillset-header';
    vskillsetHeader.style.cssText = 'display: flex; justify-content: space-between; align-items: center; cursor: pointer; padding: 8px; background: #f9fafb; border-radius: 6px; margin-bottom: 8px;';
    vskillsetHeader.onclick = function() {
      const content = this.nextElementSibling;
      const arrow = this.querySelector('.vskillset-arrow');
      if (content.style.display === 'none' || !content.style.display) {
        content.style.display = 'block';
        arrow.textContent = 'â–¼';
      } else {
        content.style.display = 'none';
        arrow.textContent = 'â–¶';
      }
    };
    
    const vskillsetTitle = document.createElement('span');
    vskillsetTitle.textContent = 'Verified Skillset Details';
    vskillsetTitle.style.cssText = 'font-weight: 600; font-size: 13px; color: #374151;';
    
    const vskillsetArrow = document.createElement('span');
    vskillsetArrow.className = 'vskillset-arrow';
    vskillsetArrow.textContent = 'â–¶';
    vskillsetArrow.style.cssText = 'color: #6b7280; font-size: 12px;';
    
    vskillsetHeader.appendChild(vskillsetTitle);
    vskillsetHeader.appendChild(vskillsetArrow);
    
    const vskillsetContent = document.createElement('div');
    vskillsetContent.className = 'vskillset-content';
    vskillsetContent.style.cssText = 'display: none;';
    
    const vskillsetTable = document.createElement('table');
    vskillsetTable.className = 'vskillset-table';
    vskillsetTable.style.cssText = 'width: 100%; border-collapse: collapse; font-size: 12px; margin-top: 8px;';
    
    const vskillsetThead = document.createElement('thead');
    vskillsetThead.innerHTML = '<tr><th style="text-align: left; padding: 8px; border-bottom: 2px solid #e5e7eb; background: #f9fafb; font-weight: 600;">Skill</th><th style="text-align: left; padding: 8px; border-bottom: 2px solid #e5e7eb; background: #f9fafb; font-weight: 600;">Probability</th><th style="text-align: left; padding: 8px; border-bottom: 2px solid #e5e7eb; background: #f9fafb; font-weight: 600;">Category</th><th style="text-align: left; padding: 8px; border-bottom: 2px solid #e5e7eb; background: #f9fafb; font-weight: 600;">Reason</th></tr>';
    
    const vskillsetTbody = document.createElement('tbody');
    vskillsetTbody.className = 'vskillset-tbody';
    
    vskillsetTable.appendChild(vskillsetThead);
    vskillsetTable.appendChild(vskillsetTbody);
    vskillsetContent.appendChild(vskillsetTable);
    
    vskillsetSection.appendChild(vskillsetHeader);
    vskillsetSection.appendChild(vskillsetContent);
    
    left.appendChild(vskillsetSection);  // Add vskillset section
    
    // Assessment card already added to actionButtonsContainer above, no need to append here

    content.appendChild(left);
    // Right column removed since all content is now in left column below assessment
    // content.appendChild(rightCol);

    container.appendChild(content);
    
    try {
      const anchorLookup = content.dataset.anchor;
      const cached = anchorLookup ? getCardCache(anchorLookup) : null;
      if (cached) {
        if (cached.name) titleEl.textContent = cached.name;
        if (cached.jobtitle) jobEl.textContent = cached.jobtitle;
        if (cached.company) compEl.textContent = cached.company;
        if (typeof cached.sector !== 'undefined' && cached.sector) sectorEl.textContent = cached.sector;
        if (cached.seniority || cached.job_family) {
          const composed = composeJobFamilyLine(cached.job_family, cached.sector);
          const tmpMeta = document.createElement('div');
          tmpMeta.className = 'sv-meta';
          tmpMeta.style.cssText = 'font-size:12px;color:#6b7280;margin-bottom:6px;';
          tmpMeta.innerHTML = composed || '';
          if (skillCol) {
             skillCol.insertBefore(tmpMeta, skillCol.firstChild || null);
          }
        }
        if (cached.seniority) {
          const sText = formatSeniorityForDisplay(cached.seniority);
          seniorityEl.textContent = sText;
        }
        if (cached.exp) {
          expEl.textContent = cached.exp + " Years Exp";
        }
        if (cached.skillset && cached.skillset.length) {
          renderSkillsets(cached.skillset, skillCol, cached.vskillset);
        }
        
        // Populate vskillset table if available
        if (cached.vskillset && Array.isArray(cached.vskillset) && cached.vskillset.length > 0) {
          renderVSkillsetTable(cached.vskillset, left);
        }
        
        // Always render products, even if empty, to remove loading spinner
        if (prodCol) {
            renderProducts(cached.product || [], prodCol);
        }

        if (cached.experience) {
          try {
             let fullText = cached.experience;
             if (cached.education) {
               if (!fullText.includes(cached.education.trim()) && !fullText.includes('Education')) {
                   fullText += "\n\nEducation\n" + cached.education;
               }
             }
             mid.innerHTML = formatExperienceHtml(fullText);
          } catch (e) { mid.textContent = cached.experience; }
        }
        if (cached.cv) {
          downloadBtn.style.display = 'inline-block';
        }
        // Restore assessment HTML if present in cache (and wasn't already in row)
        // if (cached.assessmentHTML && (!rowMatchingContainer || !rowMatchingContainer.innerHTML.trim())) {
        //      matchingLevelContainer.innerHTML = cached.assessmentHTML;
        // }
      }
    } catch(_) {}

    (async () => {
      try {
        const anchorLookup = content.dataset.anchor || '';
        if (!anchorLookup) {
          sectorEl.textContent = rowCountry || sector || 'â€”';
          return;
        }
        try { 
          // Prefer to display a strict 'sector' label (not geographic region)
          sectorEl.textContent = sector || rowCountry || 'â€”';
        } catch(_){}
        const geo = await getProcessGeography(anchorLookup);
        if (geo) {
          // *** FIX: Sync Company Name and Job Title from Postgres (process table) ***
          // Update company and job_title elements with latest data from database
          const dbCompany = (geo.company || '').trim();
          const dbJobTitle = (geo.jobtitle || geo.job_title || '').trim();
          
          if (dbCompany) {
            compEl.textContent = displayCompanyValueStatic(dbCompany) || dbCompany;
            console.log('[View Details] Synced company from Postgres');
          }
          if (dbJobTitle) {
            jobEl.textContent = dbJobTitle;
            console.log('[View Details] Synced job_title from Postgres');
          }
          
          // Update country|geographic display below profile name
          const geoCountry = (geo.country || '').trim();
          const geoGeographic = (geo.geographic || '').trim();
          if (geoCountry || geoGeographic) {
            const parts = [];
            if (geoCountry) parts.push(geoCountry);
            if (geoGeographic) parts.push(geoGeographic);
            countryGeographicEl.textContent = parts.join(' | ');
          } else if (rowCountry) {
            countryGeographicEl.textContent = rowCountry;
          }
          
          // IMPORTANT: Display only sector (explicit) and job family using the Job Family meta.
          // Avoid using geographic or country fragments in the Job Family meta.
          // sector is taken from geo.sector (DB-supplied) if present; otherwise fall back to rowCountry.
          const dbSector = (geo.sector || '').trim();
          const jobFamilyVal = (geo.job_family || geo.family || '').trim();
          if (dbSector) {
            sectorEl.textContent = dbSector;
          } else {
            sectorEl.textContent = rowCountry || 'â€”';
          }

          // show total experience and average tenure inline
          try {
              // expVal: prefer geo.exp, then geo.total_years, then empty
              const expVal = (geo.exp || geo.total_years || '').toString().trim();
              // Determine tenure: prefer geo.tenure if provided; otherwise compute
              let tenureNum = null;
              if (typeof geo.tenure !== 'undefined' && geo.tenure !== null && !Number.isNaN(Number(geo.tenure))) {
                  tenureNum = Number(geo.tenure);
              } else {
                  // Prepare experience data for tenure calculation
                  let expData = null;
                  if (Array.isArray(geo.experience) && geo.experience.length) {
                      expData = geo.experience;
                  } else if (typeof geo.experience === 'string' && geo.experience.trim()) {
                      expData = geo.experience;
                  } else {
                      // try computing from experience dataset in the displayed card (full text)
                      const cardExp = (getCardCache(anchorLookup) && getCardCache(anchorLookup).experience) || '';
                      expData = cardExp || '';
                  }
                  
                  // Priority: Use exp from Process table if available, otherwise compute from experience text
                  if (expVal && expData) {
                      // Use computeTenureFromTotalExperience: exp from Process (Postgres) / number of unique employers
                      const computed = computeTenureFromTotalExperience(expVal, expData);
                      if (computed !== null) tenureNum = computed;
                  } else if (expData) {
                      // Fallback: compute from experience text when exp is not available
                      const computed = computeTenureFromExperienceText(expData);
                      if (computed !== null) tenureNum = computed;
                  }
              }

              // Round tenure to 1 decimal place if computed
              if (tenureNum !== null) {
                  tenureNum = Math.round(tenureNum * 10) / 10;
              }

              // Build display text
              let expDisplay = '';
              if (expVal) expDisplay = `${escapeHtml(expVal)} Years Exp`;
              if (tenureNum !== null && !Number.isNaN(Number(tenureNum))) {
                  expDisplay += (expDisplay ? ' | ' : '') + `AVG Tenure: ${tenureNum.toFixed(1)} years`;
              }
              if (expEl) expEl.textContent = expDisplay || expEl.textContent;
          } catch(_) {}

          // store into cache as before, now including tenure and sanitized sector/job_family
          try {
              const prevCache = getCardCache(anchorLookup) || {};
              const hasCV = !!(geo.cv || prevCache.cv);
              const cacheData = {
                  sector: sectorEl.textContent, // sanitized sector
                  seniority: (geo.seniority || '').trim(),
                  job_family: (geo.job_family || '').trim(),
                  skillset: Array.isArray(geo.skillset) ? normalizeSkillset(geo.skillset).slice(0, 50) : [],
                  product: Array.isArray(geo.product) ? normalizeSkillset(geo.product) : [],
                  cv: hasCV,
                  exp: (geo.exp || '').toString(),
                  tenure: (typeof geo.tenure !== 'undefined' && geo.tenure !== null && !Number.isNaN(Number(geo.tenure))) ? Number(geo.tenure) : (typeof geo.tenure !== 'undefined' ? geo.tenure : ''),
                  education: (geo.education || '').toString(),
                  experience: (geo.experience || '').toString(),
                  vskillset: Array.isArray(geo.vskillset) ? geo.vskillset : []
              };
              if (anchorLookup) setCardCache(anchorLookup, cacheData);

              // Insert Job Family meta using sanitized composeJobFamilyLine to ensure the correct tag format
              try {
                  const jf = cacheData.job_family || '';
                  const sc = cacheData.sector || sectorEl.textContent || '';
                  const metaHtml = composeJobFamilyLine(jf, sc);
                  if (skillCol) {
                    const oldMeta = skillCol.querySelector('.sv-meta');
                    if(oldMeta) oldMeta.remove();
                    const metaLine = document.createElement('div');
                    metaLine.className = 'sv-meta';
                    metaLine.style.cssText = 'font-size:12px;color:#6b7280;margin-bottom:6px;';
                    metaLine.innerHTML = metaHtml;
                    skillCol.insertBefore(metaLine, skillCol.firstChild || null);
                  }
              } catch(_) {}

              // If we computed a numeric average tenure (client-side) and backend supports updating process table,
              // attempt to persist it to the process table. Use a conservative endpoint '/process/update' expecting JSON { linkedinurl, tenure }.
              // This is best-effort and failures are ignored (non-blocking).
              (async () => {
                  try {
                      // prefer cached tenure numeric value if present
                      let tenureToSend = null;
                      if (typeof geo.tenure !== 'undefined' && geo.tenure !== null && !Number.isNaN(Number(geo.tenure))) {
                          tenureToSend = Number(geo.tenure);
                      } else {
                          // try to parse expEl to extract AVG Tenure value
                          const m = (expEl && expEl.textContent) ? expEl.textContent.match(/AVG Tenure:\s*([\d.]+)/i) : null;
                          if (m && m[1]) {
                              tenureToSend = Number(m[1]);
                          }
                      }
                      if (anchorLookup && tenureToSend !== null && !Number.isNaN(tenureToSend)) {
                          // Post to backend to update process.tenure (best-effort)
                          await fetch('/process/update', {
                              method: 'POST',
                              credentials: 'same-origin',
                              headers: {'Content-Type': 'application/json'},
                              body: JSON.stringify({ linkedinurl: anchorLookup, tenure: tenureToSend })
                          }).catch(()=>{});
                      }
                  } catch(e) {
                      // ignore
                  }
              })();

          } catch(_){}
        } else {
          // No data returned from database - show empty state message
          sectorEl.textContent = rowCountry || sector || 'â€”';
          
          // Display user-friendly warning message
          const errorNotice = createViewDetailsNotice({
            type: 'warning',
            title: 'âš ï¸ No additional data available',
            message: 'The profile data could not be retrieved from the database. This may be due to:',
            reasons: [
              'The profile has not been fully processed yet',
              'Network connectivity issues'
            ],
            instructions: 'Please try refreshing the profile using the ðŸ”„ Refresh button above.'
          });
          
          // Insert notice after the profile picture container
          const firstContainer = content.querySelector('div[style*="text-align: center"]');
          if (firstContainer && firstContainer.nextSibling) {
            firstContainer.parentNode.insertBefore(errorNotice, firstContainer.nextSibling);
          } else {
            content.insertBefore(errorNotice, content.firstChild);
          }
        }
      } catch (e) {
        console.error('[View Details] Failed to populate process geography for namecard:', e);
        
        // Display user-friendly error message
        const errorNotice = createViewDetailsNotice({
          type: 'error',
          title: 'âŒ Unable to load details',
          message: 'An error occurred while retrieving profile data from the database.',
          instructions: 'Please try again later or contact support if the problem persists.'
        });
        
        // Insert notice after the profile picture container
        const firstContainer = content.querySelector('div[style*="text-align: center"]');
        if (firstContainer && firstContainer.nextSibling) {
          firstContainer.parentNode.insertBefore(errorNotice, firstContainer.nextSibling);
        } else {
          content.insertBefore(errorNotice, content.firstChild);
        }
        
        // Keep fallback values displayed
        sectorEl.textContent = rowCountry || sector || 'â€”';
      }
    })();
    
    return content;
  }

  function toggleNameCard(tr) {
    if(!tr) return;
    __currentProfileRow = tr; // Track current profile for refresh functionality
    switchTab('tab-details');
    renderNameCardToTab(tr);
    // Auto-refresh Search Result tab in background when viewing details
    if (typeof refreshSearchResultsInBackground === 'function') {
      refreshSearchResultsInBackground();
    }
  }

  function updateNameCard(tr, data) {
    if (!tr) return null;
    /* First ensure we render/get the card in the tab */
    renderNameCardToTab(tr);
    const card = document.querySelector('#details-container .sv-namecard');
    if (!card) return null;
    const anchorKey = card.dataset.anchor || tr.dataset.linkedinurl || '';

    let latestSnapshot = {};
    try {
      if (typeof data.name !== 'undefined') {
        const nm = card.querySelector('.sv-name');
        if (nm) nm.textContent = data.name || nm.textContent;
        latestSnapshot.name = data.name || (card.querySelector('.sv-name')?.textContent || '');
      }
      if (typeof data.jobtitle !== 'undefined') {
        const job = card.querySelector('.sv-job');
        if (job) job.textContent = data.jobtitle || job.textContent;
        latestSnapshot.jobtitle = data.jobtitle || (card.querySelector('.sv-job')?.textContent || '');
      }
      if (typeof data.company !== 'undefined') {
        const comp = card.querySelector('.sv-company');
        const sec  = card.querySelector('.sv-sector');
        if (comp) {
          const newCompany = (data.company || '').toString().trim();
          comp.textContent = newCompany || comp.textContent;
          latestSnapshot.company = newCompany || comp.textContent;

          (async () => {
            try {
              let rowCountry = '';
              try { rowCountry = (tr.querySelector('td[data-field="country"]')?.textContent || '').trim(); } catch(_) { rowCountry = ''; }
              const anchorLookup = anchorKey;
              if (!anchorLookup) {
                if (typeof data.sector !== 'undefined') {
                  if (sec) sec.textContent = data.sector || sec.textContent;
                  latestSnapshot.sector = data.sector || sec.textContent;
                } else {
                  if (rowCountry && sec) sec.textContent = rowCountry;
                  latestSnapshot.sector = rowCountry || (sec?.textContent || '');
                }
                return;
              }
              // Prefer sector value (DB-provided in process geodata) over geographic region
              if (typeof data.sector !== 'undefined' && data.sector) {
                if (sec) sec.textContent = data.sector;
                latestSnapshot.sector = data.sector;
              } else {
                // fallback to process geography
                if (sec) sec.textContent = rowCountry || sec.textContent;
                latestSnapshot.sector = rowCountry || (sec?.textContent || '');
              }

              const geo = await getProcessGeography(anchorLookup);
              if (geo) {
                // Use geo.sector if available (DB-provided)
                if (geo.sector) {
                  if (sec) sec.textContent = geo.sector;
                  latestSnapshot.sector = geo.sector;
                }
                try {
                  const seniorityText = (geo.seniority || '').trim();
                  const familyText = (geo.job_family || '').trim();
                  if (seniorityText || familyText) {
                    const metaHtml = composeJobFamilyLine(familyText, geo.sector || '');
                    if (skillCol) {
                       const oldMeta = skillCol.querySelector('.sv-meta');
                       if(oldMeta) oldMeta.remove();
                       
                       const metaLine = document.createElement('div');
                       metaLine.className = 'sv-meta';
                       metaLine.style.cssText = 'font-size:12px;color:#6b7280;margin-bottom:6px;';
                       metaLine.innerHTML = metaHtml;
                       skillCol.insertBefore(metaLine, skillCol.firstChild || null);
                    }
                    try {
                      if (seniorityEl) seniorityEl.textContent = seniorityText ? formatSeniorityForDisplay(seniorityText) : '';
                    } catch(_) {}
                  }
                  if (geo.exp) {
                      expEl.textContent = geo.exp + " Years Exp";
                  }
                  if (skillCol && geo.skillset && geo.skillset.length) {
                    renderSkillsets(geo.skillset, skillCol, geo.vskillset);
                  }
                  
                  // Populate vskillset table if available
                  if (geo.vskillset && Array.isArray(geo.vskillset) && geo.vskillset.length > 0) {
                    renderVSkillsetTable(geo.vskillset, left);
                    
                    // Also update cache with vskillset
                    const prevCache = getCardCache(anchorLookup) || {};
                    setCardCache(anchorLookup, { ...prevCache, vskillset: geo.vskillset });
                  }
                  
                  // Always render products, even if empty array, to remove loading spinner
                  if (prodCol) {
                      renderProducts(geo.product || [], prodCol);
                  }
                  
                  const prevCache = getCardCache(anchorLookup) || {};
                  const hasCV = !!(geo.cv || prevCache.cv);

                  if (hasCV) {
                    downloadBtn.style.display = 'inline-block';
                  }
                  
                  if(geo.experience || geo.education) {
                      let displayExp = geo.experience || '';
                      if (geo.education) {
                        if (!displayExp.includes(geo.education.trim()) && !displayExp.includes('Education')) {
                            if (displayExp) displayExp += "\n\n";
                            displayExp += "Education\n" + geo.education;
                        }
                      }
                      if(mid) mid.innerHTML = formatExperienceHtml(displayExp);
                  }

                   const cacheData = {
                    sector: (geo.sector || sec.textContent) || '',
                    seniority: (geo.seniority || '').trim(),
                    job_family: (geo.job_family || '').trim(),
                    skillset: Array.isArray(geo.skillset) ? normalizeSkillset(geo.skillset).slice(0, 50) : [],
                    product: Array.isArray(geo.product) ? normalizeSkillset(geo.product) : [],
                    cv: hasCV, 
                    exp: (geo.exp || '').toString(),
                    education: (geo.education || '').toString(),
                    experience: (geo.experience || '').toString(),
                    tenure: (typeof geo.tenure !== 'undefined' && geo.tenure !== null && !Number.isNaN(Number(geo.tenure))) ? Number(geo.tenure) : ''
                  };
                  if (anchorLookup) setCardCache(anchorLookup, cacheData);
                } catch(_){}
              }
            } catch (e) {
              console.warn('Failed to update namecard company from process table', e);
              try {
                const rowCountry = (tr.querySelector('td[data-field="country"]')?.textContent || '').trim();
                const sec = card.querySelector('.sv-sector');
                if (typeof data.sector !== 'undefined') {
                  if (sec) sec.textContent = data.sector || sec.textContent;
                  latestSnapshot.sector = data.sector || sec.textContent;
                } else {
                  if (rowCountry && sec) sec.textContent = rowCountry;
                  latestSnapshot.sector = rowCountry || (sec?.textContent || '');
                }
              } catch(_) {}
            }
          })();
        }
      }
      if (typeof data.sector !== 'undefined') {
        const sec = card.querySelector('.sv-sector');
        if (sec) sec.textContent = data.sector || sec.textContent;
        latestSnapshot.sector = data.sector || (sec?.textContent || '');
      }
      if (typeof data.experience !== 'undefined') {
        const mid = card.querySelector('.sv-experience');
        if (mid) {
          try {
            let displayText = data.experience || '';
            if (data.education) {
                if (!displayText.includes(data.education.trim()) && !displayText.includes('Education')) {
                    if (displayText) displayText += "\n\n";
                    displayText += "Education\n" + data.education;
                }
            }
            mid.innerHTML = formatExperienceHtml(displayText);
          } catch (e) {
            mid.textContent = data.experience || '';
          }
        }
        latestSnapshot.experience = data.experience || (card.querySelector('.sv-experience')?.textContent || '');
        if(data.education) latestSnapshot.education = data.education;
      }
      if (typeof data.skillset !== 'undefined') {
        const skillCol = ensureSkillsetColumn(card.querySelector('.sv-right-col'));
        renderSkillsets(data.skillset, skillCol, data.vskillset);
        latestSnapshot.skillset = normalizeSkillset(data.skillset).slice(0, 50);
        if (data.vskillset) {
          latestSnapshot.vskillset = data.vskillset;
        }
      }
      if (typeof data.product !== 'undefined') {
        const pCol = ensureProductColumn(card.querySelector('.sv-right-col'));
        renderProducts(data.product, pCol);
        latestSnapshot.product = normalizeSkillset(data.product);
      }

      if (typeof data.seniority !== 'undefined') {
        try {
          const seniorEl = card.querySelector('.sv-seniority');
          if (seniorEl) seniorEl.textContent = data.seniority ? formatSeniorityForDisplay(data.seniority) : '';
          latestSnapshot.seniority = (data.seniority || '').toString().trim();
        } catch(_) {}
      }
      
      if (typeof data.exp !== 'undefined') {
          const expElLocal = card.querySelector('.sv-exp-years');
          if(expElLocal) expElLocal.textContent = data.exp + " Years Exp";
          latestSnapshot.exp = data.exp;
      }

      if (anchorKey) {
        setCardCache(anchorKey, latestSnapshot);
      }

      try {
        const anchor = anchorKey;
        if (anchor) {
          if (typeof data.company !== 'undefined') {
            const companyTd = tr.querySelector('td[data-field="company"]') || tr.querySelectorAll('td')[2];
            if (companyTd) markDirty(companyTd);
            flushImmediate(anchor, 'company', (latestSnapshot.company || '').toString().trim(), companyTd || card.querySelector('.sv-company'));
          }
          if (typeof data.jobtitle !== 'undefined') {
            const jobTd = tr.querySelector('td[data-field="jobtitle"]') || tr.querySelectorAll('td')[3];
            if (jobTd) markDirty(jobTd);
            flushImmediate(anchor, 'jobtitle', (latestSnapshot.jobtitle || '').toString().trim(), jobTd || card.querySelector('.sv-job'));
          }
          if (typeof data.experience !== 'undefined') {
            const expTd = tr.querySelector('td[data-field="experience"]') || tr.querySelectorAll('td')[6];
            if (expTd) {
                let persistText = (latestSnapshot.experience || '').toString().trim();
                if (latestSnapshot.education) {
                  if (!persistText.includes(latestSnapshot.education.trim()) && !persistText.includes('Education')) {
                      if (persistText) persistText += "\n\n";
                      persistText += "Education\n" + (latestSnapshot.education || '');
                  }
                }
                expTd.dataset.experience = persistText;
                markDirty(expTd);
                flushImmediate(anchor, 'experience', expTd.dataset.experience, expTd || card.querySelector('.sv-experience'));
            }
          }
          if (typeof data.name !== 'undefined') {
            const nameTd = tr.querySelector('td[data-field="name"]') || tr.querySelectorAll('td')[1];
            if (nameTd) markDirty(nameTd);
            flushImmediate(anchor, 'name', (latestSnapshot.name || '').toString().trim(), nameTd || card.querySelector('.sv-name'));
          }
          if (typeof latestSnapshot.seniority !== 'undefined') {
            flushImmediate(anchor, 'seniority', (latestSnapshot.seniority || '').toString().trim(), card.querySelector('.sv-meta') || card);
          }
          if (typeof latestSnapshot.job_family !== 'undefined') {
            flushImmediate(anchor, 'job_family', (latestSnapshot.job_family || '').toString().trim(), card.querySelector('.sv-meta') || card);
          }
          if (Array.isArray(latestSnapshot.skillset)) {
            flushImmediate(anchor, 'skillset', latestSnapshot.skillset.join(', '), card.querySelector('.sv-skillset-col') || card);
          }
          if (Array.isArray(latestSnapshot.product)) {
             flushImmediate(anchor, 'product', latestSnapshot.product.join(', '), card.querySelector('.sv-product-col') || card);
          }
        }
      } catch (e) {
        console.warn('Namecard persist to server failed', e);
      }
    } catch (e) {
      console.warn('updateNameCard failed', e);
    }
  }

  document.addEventListener('click', function(e){
    const btn = e.target.closest('.view-btn');
    if(!btn) return;
    const label = (btn.textContent || '').trim();
    /* Also handle the new 'LinkedIn' label if toggle is in upload mode */
    if (label !== 'View' && label !== 'Assessment' && label !== 'LinkedIn') return;
    const tr = btn.closest('tr');
    if (!tr) return;
    refreshAccountTokens();
    toggleNameCard(tr);
  });

  window.__sv_namecard = {
    renderNameCardToTab, // exposed to replace old createNameCardRow
    updateNameCard,
    toggleNameCard,
    ensureSkillsetColumn,
    renderSkillsets,
    ensureProductColumn,
    renderProducts,
    setCardCache,
    getCardCache
  };
})();

/* View Details Tab Enhancement Functions */
let __currentProfileRow = null; // Track current profile being viewed
let __refreshDebounceTimer = null; // Debounce timer for hover-triggered refresh
let __isRefreshing = false; // Track if refresh is in progress

function refreshCurrentProfile() {
    if (!__currentProfileRow) {
        console.warn('No profile currently displayed.');
        return;
    }
    
    const anchor = __currentProfileRow.dataset.linkedinurl;
    if (!anchor) {
        console.warn('Cannot refresh - no LinkedIn URL found.');
        return;
    }
    
    // Prevent multiple simultaneous refreshes
    if (__isRefreshing) {
        console.log('Refresh already in progress...');
        return;
    }
    
    __isRefreshing = true;
    
    // Show refresh status with loading indicator using dedicated aria-live region
    const refreshBtn = document.getElementById('viewDetailsRefreshBtn');
    const refreshStatus = document.getElementById('refreshStatus');
    
    if (refreshBtn) {
        refreshBtn.textContent = 'Refreshing...';
        refreshBtn.style.pointerEvents = 'none';
        refreshBtn.disabled = true;
    }
    
    if (refreshStatus) {
        refreshStatus.textContent = 'Refreshing profile...';
        refreshStatus.style.display = 'inline';
    }
    
    if (typeof setStatus === 'function') setStatus('Refreshing profile...', 'info');
    
    // Re-render the namecard which will fetch latest data
    if (window.__sv_namecard && window.__sv_namecard.renderNameCardToTab) {
        window.__sv_namecard.renderNameCardToTab(__currentProfileRow);
        if (typeof setStatus === 'function') setStatus('Profile refreshed', 'success');
        
        // Reset button state after refresh completes
        setTimeout(() => {
            __isRefreshing = false;
            if (refreshBtn) {
                refreshBtn.textContent = 'ðŸ”„ Refresh';
                refreshBtn.style.pointerEvents = 'auto';
                refreshBtn.disabled = false;
            }
            if (refreshStatus) {
                refreshStatus.textContent = '';
                refreshStatus.style.display = 'none';
            }
        }, 500);
    } else {
        // If namecard not available, reset immediately
        __isRefreshing = false;
        if (refreshBtn) {
            refreshBtn.textContent = 'ðŸ”„ Refresh';
            refreshBtn.style.pointerEvents = 'auto';
            refreshBtn.disabled = false;
        }
        if (refreshStatus) {
            refreshStatus.textContent = '';
            refreshStatus.style.display = 'none';
        }
    }
}

/* New functionality: Listen to toggle change to start/stop snipper API removed */

document.addEventListener('DOMContentLoaded', () => {
    // Add Match Level header click listener for sorting with toggle states
    const matchLevelHeader = document.getElementById('matchLevelHeader');
    let __sortState = 'none'; // Track current sort state: 'none', 'descending', 'ascending'
    
    if (matchLevelHeader) {
        matchLevelHeader.addEventListener('click', () => {
            if(!rowsData || rowsData.length === 0) return;
            
            // Cycle through sort states: none â†’ descending â†’ ascending â†’ none
            if (__sortState === 'none') {
                __sortState = 'descending';
            } else if (__sortState === 'descending') {
                __sortState = 'ascending';
            } else {
                __sortState = 'none';
                // Reload original order when returning to 'none'
                loadRows(currentPage);
                matchLevelHeader.setAttribute('aria-sort', 'none');
                matchLevelHeader.querySelector('span').textContent = '';
                setStatus('Sort order reset.', 'success');
                return;
            }
            
            // Sort rowsData based on cached score or experience text
            rowsData.sort((a, b) => {
                const getScore = (r) => {
                    let score = -1;
                    
                    // Try rating field first (most reliable source)
                    if (r.rating) {
                        try {
                            const ratingObj = typeof r.rating === 'string' ? JSON.parse(r.rating) : r.rating;
                            if (ratingObj && ratingObj.total_score) {
                                const scoreStr = String(ratingObj.total_score).replace('%', '');
                                score = parseInt(scoreStr, 10);
                                if (!isNaN(score)) return score;
                            }
                        } catch(e) {}
                    }
                    
                    // Try cache second
                    if(score === -1 && window.__sv_namecard) {
                        const cache = window.__sv_namecard.getCardCache(r.linkedinurl);
                        if(cache && cache.totalScore !== undefined) {
                            const cachedScore = parseInt(cache.totalScore, 10);
                            if (!isNaN(cachedScore)) {
                                score = cachedScore;
                            }
                        } else if(cache && cache.assessmentHTML) {
                            const m = cache.assessmentHTML.match(/(\d+)%/);
                            if(m) score = parseInt(m[1], 10);
                        }
                    }
                    
                    // Try experience field text if cache miss
                    if(score === -1 && r.experience) {
                         const m = String(r.experience).match(/(\d+)%/);
                         if(m) score = parseInt(m[1], 10);
                    }
                    return score;
                };
                
                // Sort descending or ascending based on state
                if (__sortState === 'descending') {
                    return getScore(b) - getScore(a); // Descending (highest to lowest)
                } else {
                    return getScore(a) - getScore(b); // Ascending (lowest to highest)
                }
            });
            
            renderTable();
            
            // Update aria-sort attribute and visual indicator
            matchLevelHeader.setAttribute('aria-sort', __sortState);
            const arrow = matchLevelHeader.querySelector('span');
            if (__sortState === 'descending') {
                arrow.textContent = 'â–¼';
                setStatus('Table sorted by Match Level (highest to lowest).', 'success');
            } else {
                arrow.textContent = 'â–²';
                setStatus('Table sorted by Match Level (lowest to highest).', 'success');
            }
        });
    }
    
    // Add hover-triggered refresh for View Details tab
    const viewDetailsRefreshBtn = document.getElementById('viewDetailsRefreshBtn');
    if (viewDetailsRefreshBtn) {
        viewDetailsRefreshBtn.addEventListener('mouseenter', () => {
            // Clear any existing timer
            if (__refreshDebounceTimer) {
                clearTimeout(__refreshDebounceTimer);
            }
            
            // Set a debounce timer to prevent rapid triggers
            __refreshDebounceTimer = setTimeout(() => {
                refreshCurrentProfile();
            }, 300); // 300ms debounce delay
        });
        
        // Also support click for explicit refresh
        viewDetailsRefreshBtn.addEventListener('click', (e) => {
            e.preventDefault();
            if (__refreshDebounceTimer) {
                clearTimeout(__refreshDebounceTimer);
            }
            refreshCurrentProfile();
        });
    }
});

function renderPager(){
  const tp = Math.max(1, Math.ceil((totalRowCount||0) / PAGE_SIZE));
  const pagerEl = document.getElementById('pager');
  const prevBtn = document.getElementById('prevPageBtn');
  const nextBtn = document.getElementById('nextPageBtn');
  const pageInfo = document.getElementById('pageInfo');
  pageInfo.textContent = `Page ${currentPage} of ${tp}`;
  prevBtn.disabled = currentPage <= 1;
  nextBtn.disabled = currentPage >= tp;
  pagerEl.style.display = tp > 1 ? 'flex' : 'none';
  showDeleteIfNeeded();
}

async function deleteSelected() {
  const selected = [...document.querySelectorAll('.row-select:checked')]
    .map(cb => cb.closest('tr').dataset.linkedinurl)
    .filter(Boolean);
  if (!selected.length) return;
  if (!confirm(`Delete ${selected.length} selected row(s)? This cannot be undone.`)) return;
  setStatus('Deletingâ€¦');
  deleteBtn.disabled = true;

  const baselineResults = document.getElementById('totalResults').textContent;
  const baselineTokensLeft = document.getElementById('tokensLeft').textContent;

  try {
    const res = await fetch(API_DELETE, {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body:JSON.stringify({ linkedinurls:selected })
    });
    const data = await res.json();
    if (!res.ok) throw new Error(data.error || 'Delete failed');
    setStatus(`Deleted ${data.deleted} row(s).`,'success');

    const removed = new Set(selected);
    rowsData = rowsData.filter(r => !removed.has(r.linkedinurl));

    renderTable();
    renderPager();

    document.getElementById('totalResults').textContent = baselineResults;
    document.getElementById('tokensLeft').textContent = baselineTokensLeft;

    // Delete button removed per requirements
    // deleteBtn.style.display='none';
    // selectAllCb.checked=false;
  } catch(e) {
    setStatus(e.message,'error');
  } finally {
    // Delete button removed per requirements
    // deleteBtn.disabled=false;
  }
}

// Add a helper for auto-deletion from UI without full reload
async function autoDeleteRow(anchor) {
    if (!anchor) return;
    const removed = new Set([anchor]);
    rowsData = rowsData.filter(r => !removed.has(r.linkedinurl));
    renderTable();
    // Also remove from review tab if present
    const reviewTr = document.querySelector(`.review-table tr[data-linkedinurl="${anchor}"]`);
    if(reviewTr) reviewTr.remove();
}

// Ensure global functions are available
window.deleteBackendRow = async function(url) {
    if(!url) return;
    try {
        await fetch(API_DELETE, {
            method:'POST', headers:{'Content-Type':'application/json'},
            body:JSON.stringify({ linkedinurls:[url] })
        });
    } catch(e) { console.error("Backend delete failed", e); throw e; }
};

window.applyTokenDelta = async function(delta) {
    const uid = window.__SV_ACTIVE_USERID;
    if(!uid) return;
    try {
        await fetch(TOKEN_UPDATE_API, {
            method:'POST', headers:{'Content-Type':'application/json'},
            body:JSON.stringify({ userid: uid, delta: delta })
        });
    } catch(e) { console.error("Token update failed", e); }
};

// Select All checkbox functionality removed per requirements
// selectAllCb.addEventListener('change', () => {
//   const checked = selectAllCb.checked;
//   document.querySelectorAll('.row-select').forEach(cb => cb.checked = checked);
//   showDeleteIfNeeded();
// });
reloadBtn.addEventListener('click', async () => { await loadRows(currentPage); refreshAccountTokens(); });
// Delete button functionality removed per requirements
// deleteBtn.addEventListener('click', deleteSelected);

function collectDisplayedRows() {
  const out = [];
  const trs = [...tableBody.querySelectorAll('tr')].filter(tr => tr.dataset && tr.dataset.linkedinurl);
  trs.forEach(tr => {
    const tds = tr.querySelectorAll('td');
    // Column indices: checkbox=0, pic=1, name=2, company=3, jobtitle=4, country=5, linkedinurl=6, experience=7
    const name = (tds[2]?.textContent || '').replace(/\s*\*\s*$/,'').trim();
    const company = (tds[3]?.textContent || '').replace(/\s*\*\s*$/,'').trim();
    const jobtitle = (tds[4]?.textContent || '').replace(/\s*\*\s*$/,'').trim();
    const country = (tds[5]?.textContent || '').replace(/\s*\*\s*$/,'').trim();
    const linkedinurl = (tds[6]?.querySelector('.view-btn')?.dataset.profileUrl || tds[6]?.textContent || '').trim();
    
    const expCell = tr.querySelector('td[data-field="experience"]');
    const experience = (expCell && expCell.dataset.experience) 
        ? expCell.dataset.experience 
        : (tds[7]?.textContent || '').replace(/\s*\*\s*$/,'').trim();
        
    out.push({ name, company, jobtitle, country, experience, linkedinurl });
  });
  return out;
}

// AFFECTED: Replaced iframe logic with direct content execution
async function deepResearch() {
  const btn = document.getElementById('exportCsvBtn');
  const embeddedRoot = document.getElementById('ds-embedded-root');

  try {
    btn.disabled = true;
    setStatus('Deep Research: preparing process-table payloadâ€¦');
    const displayed = collectDisplayedRows();
    if (!displayed.length) {
      setStatus('No displayed rows to process.', 'error');
      btn.disabled = false;
      return;
    }
    const uploaded_columns = ['name','company','jobtitle','country'];
    const rowsArray = displayed.map(r => [ r.name || '', r.company || '', r.jobtitle || '', r.country || '' ]);
    
    // Prepare the payload for client-side inference
    const payloadForDataSorter = {
      uploaded_columns: uploaded_columns.slice(),
      rows: rowsArray.slice(),
      infer_result: null, // Will be generated by clientInferFallback
      meta: {
        source: 'SourcingVerify.deepResearch',
        processed_at_ms: Date.now()
      }
    };
    
    // Removed switchTab('tab-research') to avoid recursion (was causing stack overflow)
    setStatus(`Deep Research: analyzing ${displayed.length} row(s)...`, 'info');

    // Trigger analysis using embedded logic from data_sorter
    if (typeof clientInferFallback === 'function') {
        const result = clientInferFallback(payloadForDataSorter, performance.now());
        if (result) {
            setStatus('Deep Research analysis complete.', 'success');
        } else {
            setStatus('Deep Research analysis returned no results.', 'error');
        }
    } else {
        setStatus('Analysis engine not ready.', 'error');
        console.error('clientInferFallback function missing');
    }

  } catch (e) {
    console.error('Deep Research error', e);
    setStatus('Deep Research error: ' + (e.message || e), 'error');
  } finally {
    btn.disabled = false;
  }
}

async function deepResearchBackgroundForAnchor(anchor) {
  try {
    if (!anchor) return false;
    
    // Direct API call to infer_job_families backend
    const tr = [...document.querySelectorAll('#tableBody tr')].find(t => (t.dataset && t.dataset.linkedinurl) === anchor);
    let name = '', company = '', role = '', country = '';
    if (tr) {
      const tds = tr.querySelectorAll('td');
      name = (tds[1]?.textContent || '').replace(/\s*\*\s*$/,'').trim();
      company = (tds[2]?.textContent || '').replace(/\s*\*\s*$/,'').trim();
      role = (tds[3]?.textContent || '').replace(/\s*\*\s*$/,'').trim();
      country = (tds[4]?.textContent || '').replace(/\s*\*\s*$/,'').trim();
    } else {
      const found = rowsData.find(r => (r.linkedinurl || '') === anchor);
      if (found) {
        name = (found.name || '').trim();
        company = (found.company || '').trim();
        role = (found.jobtitle || found.role || '').trim();
        country = (found.country || '').trim();
      }
    }
    
    const payload = {
        uploaded_columns: ['name','company','jobtitle','country'],
        rows: [[ name || '', company || '', role || '', country || '' ]],
        infer_location: true,
        infer_gemini: true,
        userid: window.__SV_ACTIVE_USERID,
        username: window.__SV_ACTIVE_USERNAME
    };

    fetch('/infer_job_families', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(payload)
    }).then(r => r.json()).then(data => {
        console.log("Background inference complete for " + anchor, data);
    }).catch(e => console.warn("Background inference failed", e));

    return true;
  } catch (e) {
    console.warn('deepResearchBackgroundForAnchor failed', e);
    return false;
  }
}

async function exportCSV() {
  const uid = window.__SV_ACTIVE_USERID || '';
  if (!uid) { setStatus('Missing user session.','error'); return; }

  let allRows = []; 
  try {
    const res = await fetch(`${API_LIST}?userid=${encodeURIComponent(uid)}&all=1`);
    const data = await res.json().catch(()=> ({}));
    if (!res.ok) throw new Error(data.error || `HTTP ${res.status}`);
    allRows = Array.isArray(data.rows) ? data.rows : [];
  } catch(e) {
    setStatus(`Failed to fetch all data: ${e.message}`, 'error');
    return;
  }

  if (!allRows.length) {
    setStatus('No data to export.','error');
    return;
  }

  const rows = allRows.map(r => ({
    name: (r.name || '').toString(),
    company: (r.company || '').toString(),
    jobtitle: (r.jobtitle || '').toString(),
    country: (r.country || '').toString(),
    experience: (r.experience || '').toString(),
    linkedinurl: (r.linkedinurl || '').toString()
  }));
  const header = ['Name','Company','Job Title','Country','Experience','LinkedIn URL'];
  const esc = v => {
    const s = (v ?? '').toString();
    return /[",\n]/.test(s) ? `"${s.replace(/"/g,'""')}"` : s;
  };
  const lines = [header.join(',')];
  rows.forEach(r => lines.push([esc(r.name),esc(r.company),esc(r.jobtitle),esc(r.country),esc(r.experience),esc(r.linkedinurl)].join(',')));
  const blob = new Blob([lines.join('\n')], { type:'text/csv' });
  const a = document.createElement('a');
  excelBlobUrl = URL.createObjectURL(blob);
  a.href = excelBlobUrl;
  a.download = 'sourcing_export.csv';
  document.body.appendChild(a); a.click(); a.remove();

  const baselineResults = document.getElementById('totalResults').textContent;
  const baselineTokensLeft = document.getElementById('tokensLeft').textContent;

  setStatus('CSV downloaded. Purging sourcing tableâ€¦');
  try {
    const allUrls = allRows.map(r => r.linkedinurl).filter(Boolean);
    if (allUrls.length) {
      const res = await fetch(API_DELETE, {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body:JSON.stringify({ linkedinurls: allUrls })
      });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error || 'Purge failed');
    }
    rowsData = [];
    totalRowCount = 0;
    renderTable();
    renderPager();

    document.getElementById('totalResults').textContent = baselineResults;
    document.getElementById('tokensLeft').textContent = baselineTokensLeft;

    setStatus('All sourcing rows deleted after CSV export.','success');
    deleteClientExcelBlob();
    disableActionButton(document.getElementById('exportCsvBtn'));
  } catch(e) {
    setStatus(`CSV exported, purge failed: ${e.message}`,'error');
    deleteClientExcelBlob();
    disableActionButton(document.getElementById('exportCsvBtn'));
  }
}

async function exportExcelXlsxAndPurge() {
  const uid = window.__SV_ACTIVE_USERID || '';
  if (!uid) { setStatus('Missing user session.','error'); return; }

  let allRows = [];
  try {
    const res = await fetch(`${API_LIST}?userid=${encodeURIComponent(uid)}&all=1`);
    const data = await res.json().catch(()=> ({}));
    if (!res.ok) throw new Error(data.error || `HTTP ${res.status}`);
    allRows = Array.isArray(data.rows) ? data.rows : [];
  } catch(e) {
    setStatus(`Failed to fetch all data: ${e.message}`, 'error');
    return;
  }

  if (!allRows.length) {
    setStatus('No data to export.','error');
    return;
  }

  const escXml = s => (s ?? '').toString().replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  const dataRows = allRows.map(r => {
    const cell = v => `<Cell><Data ss:Type="String">${escXml(v)}</Data></Cell>`;
    return `<Row>${cell(r.name)}${cell(r.company)}${cell(r.jobtitle)}${cell(r.country)}${cell(r.experience||'')}${cell(r.linkedinurl)}</Row>`;
  }).join('');
  const xml =
`<?xml version="1.0"?>
<?mso-application progid="Excel.Sheet"?>
<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet"
 xmlns:o="urn:schemas-microsoft-com:office:office"
 xmlns:x="urn:schemas-microsoft-com:office:excel"
 xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet"
 xmlns:html="http://www.w3.org/TR/REC-html40">
 <Worksheet ss:Name="Sourcing">
  <Table ss:ExpandedColumnCount="6" ss:DefaultColumnWidth="140">
   <Row>
    <Cell><Data ss:Type="String">Name</Data></Cell>
    <Cell><Data ss:Type="String">Company</Data></Cell>
    <Cell><Data ss:Type="String">Job Title</Data></Cell>
    <Cell><Data ss:Type="String">Country</Data></Cell>
    <Cell><Data ss:Type="String">Experience</Data></Cell>
    <Cell><Data ss:Type="String">LinkedIn URL</Data></Cell>
   </Row>
   ${dataRows}
  </Table>
 </Worksheet>
</Workbook>`;
  const blob = new Blob([xml], { type:'application/vnd.ms-excel' });
  const a = document.createElement('a');
  excelBlobUrl = URL.createObjectURL(blob);
  a.href = excelBlobUrl;
  a.download = 'sourcing_export.xlsx';
  document.body.appendChild(a); a.click(); a.remove();

  const baselineResults = document.getElementById('totalResults').textContent;
  const baselineTokensLeft = document.getElementById('tokensLeft').textContent;

  setStatus('Excel downloaded. Purging sourcing tableâ€¦');
  try {
    const allUrls = allRows.map(r => r.linkedinurl).filter(Boolean);
    if (allUrls.length) {
      const res = await fetch(API_DELETE, {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body:JSON.stringify({ linkedinurls: allUrls })
      });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error || 'Purge failed');
    }
    rowsData = [];
    totalRowCount = 0;
    renderTable();
    renderPager();

    document.getElementById('totalResults').textContent = baselineResults;
    document.getElementById('tokensLeft').textContent = baselineTokensLeft;

    setStatus('All sourcing rows deleted after Excel export.','success');
  } catch(e) {
    setStatus(`Export ok, purge failed: ${e.message}`,'error');
  } finally {
    deleteClientExcelBlob();
    disableActionButton(document.getElementById('exportExcelBtn'));
  }
}

document.getElementById('exportCsvBtn').addEventListener('click', deepResearch);
document.getElementById('exportExcelBtn').addEventListener('click', exportCSV);

/* REFACTORED: Bulk Upload via Browser-Side Folder Selection */

/* Helper: Verify all required fields are populated for bulk uploaded profiles */
async function verifyBulkUploadedProfiles(linkedinurls) {
    if (!linkedinurls || linkedinurls.length === 0) return;
    
    const requiredFields = ['jobtitle', 'company', 'sector', 'seniority', 'skillset', 'country', 'tenure', 'product'];
    const maxAttempts = 10; // Poll up to 10 times
    const pollInterval = 2000; // Poll every 2 seconds
    
    console.log(`[Bulk Upload Verify] Starting verification for ${linkedinurls.length} profiles`);
    
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
        try {
            // Fetch data for all uploaded profiles from Postgres
            const verifications = await Promise.all(linkedinurls.map(async (linkedinurl) => {
                try {
                    const res = await fetch(`/process/geography?linkedin=${encodeURIComponent(linkedinurl)}`, {
                        credentials: 'same-origin'
                    });
                    if (!res.ok) return { linkedinurl, verified: false, missingFields: requiredFields };
                    
                    const data = await res.json();
                    const missingFields = [];
                    
                    // Check each required field
                    if (!data.jobtitle && !data.job_title) missingFields.push('jobtitle');
                    if (!data.company) missingFields.push('company');
                    if (!data.sector) missingFields.push('sector');
                    if (!data.seniority) missingFields.push('seniority');
                    if (!data.skillset || (Array.isArray(data.skillset) && data.skillset.length === 0)) missingFields.push('skillset');
                    if (!data.country) missingFields.push('country');
                    // Check tenure - allow 0 as valid value
                    if (data.tenure !== 0 && !data.tenure) missingFields.push('tenure');
                    if (!data.product || (Array.isArray(data.product) && data.product.length === 0)) missingFields.push('product');
                    
                    return {
                        linkedinurl,
                        verified: missingFields.length === 0,
                        missingFields
                    };
                } catch (e) {
                    console.warn(`[Bulk Upload Verify] Error checking ${linkedinurl}:`, e);
                    return { linkedinurl, verified: false, missingFields: requiredFields };
                }
            }));
            
            // Check if all profiles are verified
            const allVerified = verifications.every(v => v.verified);
            const verifiedCount = verifications.filter(v => v.verified).length;
            
            console.log(`[Bulk Upload Verify] Attempt ${attempt + 1}: ${verifiedCount}/${linkedinurls.length} profiles verified`);
            
            if (allVerified) {
                setStatus(`All ${linkedinurls.length} profiles verified! Ready for assessment.`, "success");
                console.log('[Bulk Upload Verify] All profiles verified successfully');
                return true;
            }
            
            // Log profiles with missing fields
            const incomplete = verifications.filter(v => !v.verified);
            console.log(`[Bulk Upload Verify] ${incomplete.length} profiles incomplete:`, 
                incomplete.map(v => ({ url: (v.linkedinurl || '').substring(0, 30) + '...', missing: v.missingFields })));
            
            // Update status with progress
            setStatus(`Verifying profiles: ${verifiedCount}/${linkedinurls.length} complete. Waiting for data processing...`, "info");
            
            // Wait before next poll
            if (attempt < maxAttempts - 1) {
                await new Promise(resolve => setTimeout(resolve, pollInterval));
            }
            
        } catch (e) {
            console.error('[Bulk Upload Verify] Verification error:', e);
        }
    }
    
    // Verification incomplete after max attempts
    setStatus(`Verification incomplete. Some profiles may be missing data. You can still proceed with assessment.`, "warning");
    console.warn('[Bulk Upload Verify] Verification timed out - some profiles may be incomplete');
    return false;
}

if (bulkAssessmentBtn && bulkDirInput) {
    // 1. Click button -> Trigger hidden file input
    bulkAssessmentBtn.addEventListener('click', () => {
        bulkDirInput.value = ''; // Reset selection
        bulkDirInput.click();
    });

    // 2. Handle file selection - Combined Bulk Upload + Assessment workflow
    bulkDirInput.addEventListener('change', async () => {
        const files = Array.from(bulkDirInput.files);
        
        // Filter PDF/DOCX only
        const validFiles = files.filter(f => f.name.match(/\.(pdf|docx?)$/i));
        
        if (validFiles.length === 0) {
            alert('No valid PDF or DOC/DOCX files selected.');
            return;
        }

        const confirmUpload = confirm(`Found ${validFiles.length} valid CV files.\n\nThis will upload files and automatically run AI assessment on all candidates. Continue?`);
        if (!confirmUpload) return;

        // Timing constant for table rendering
        const TABLE_RENDER_DELAY_MS = 1000; // Delay to allow table rendering to complete before starting assessment

        const bulkUploadProgressContainer = document.getElementById('bulkUploadProgressContainer');
        const bulkUploadProgressBar = document.getElementById('bulkUploadProgressBar');
        const bulkUploadProgressPercent = document.getElementById('bulkUploadProgressPercent');
        const bulkUploadProgressText = document.getElementById('bulkUploadProgressText');
        
        bulkUploadProgressContainer.style.display = 'block';
        bulkUploadProgressBar.style.width = '0%';
        bulkUploadProgressPercent.textContent = '0%';
        bulkUploadProgressText.textContent = 'Starting upload...';

        setStatus(`Uploading ${validFiles.length} files...`, "info");
        
        // Disable all buttons during bulk upload and assessment
        setSearchResultButtonsEnabled(false);
        bulkAssessmentBtn.disabled = true;
        
        console.log(`[Bulk Assessment] Uploading ${validFiles.length} CV files`);
        validFiles.forEach((file, idx) => {
            console.log(`[Bulk Assessment] File ${idx + 1}: ${file.name}, size: ${file.size}, type: ${file.type}`);
        });

        // Prepare FormData
        const formData = new FormData();
        validFiles.forEach(file => {
            formData.append('files', file); // 'files' is the key expected by backend
        });

        // Add user info if needed
        const uid = window.__SV_ACTIVE_USERID || '';
        if (uid) formData.append('userid', uid);

        try {
            bulkUploadProgressBar.style.width = '20%';
            bulkUploadProgressPercent.textContent = '20%';
            bulkUploadProgressText.textContent = 'Uploading files...';
            
            // PHASE 1: Bulk Upload
            console.log(`[Bulk Assessment] Phase 1: Sending to ${API_UPLOAD_MULTIPLE}`);
            const res = await fetch(API_UPLOAD_MULTIPLE, {
                method: 'POST',
                body: formData,
                credentials: 'same-origin'
            });
            const data = await res.json();
            console.log('[Bulk Assessment] Upload Response:', data);

            bulkUploadProgressBar.style.width = '40%';
            bulkUploadProgressPercent.textContent = '40%';
            bulkUploadProgressText.textContent = 'Processing files...';

            if (res.ok) {
                setStatus(`Bulk Upload Complete: Matched ${data.uploaded_count} CVs. Verifying data...`, "info");
                
                let msg = `Successfully matched and uploaded ${data.uploaded_count} CVs.`;
                if (data.errors && data.errors.length > 0) {
                    msg += `\n\nErrors encountered: ${data.errors.length} files had issues. Check browser console for details.`;
                    console.warn("Bulk upload errors:", data.errors);
                }
                
                // Verify all required fields are populated in Postgres before proceeding
                if (data.uploaded_profiles && Array.isArray(data.uploaded_profiles)) {
                    setStatus(`Verifying ${data.uploaded_profiles.length} profiles in database...`, "info");
                    
                    bulkUploadProgressBar.style.width = '60%';
                    bulkUploadProgressPercent.textContent = '60%';
                    bulkUploadProgressText.textContent = 'Verifying data...';
                    
                    // Poll to verify all fields are populated
                    await verifyBulkUploadedProfiles(data.uploaded_profiles);
                }
                
                bulkUploadProgressBar.style.width = '80%';
                bulkUploadProgressPercent.textContent = '80%';
                bulkUploadProgressText.textContent = 'Upload complete! Starting assessment...';
                
                // Redirect to Search Result tab and refresh
                switchTab('tab-search');
                renderTable();
                
                // Wait a moment for the table to render
                await new Promise(resolve => setTimeout(resolve, TABLE_RENDER_DELAY_MS));
                
                // Hide upload progress bar
                bulkUploadProgressContainer.style.display = 'none';
                
                // PHASE 2: Run Bulk Assessment
                console.log('[Bulk Assessment] Phase 2: Starting bulk assessment');
                await runBulkAssessmentFromSearch();
                
            } else {
                bulkUploadProgressContainer.style.display = 'none';
                setStatus(`Upload failed: ${data.error || 'Unknown error'}`, "error");
                alert(`Error: ${data.error}`);
                // Re-enable buttons on upload failure (assessment not triggered)
                setSearchResultButtonsEnabled(true);
                bulkAssessmentBtn.disabled = false;
            }
        } catch (e) {
            bulkUploadProgressContainer.style.display = 'none';
            setStatus(`Upload request failed: ${e.message}`, "error");
            console.error(e);
            // Re-enable buttons on error (assessment not triggered)
            setSearchResultButtonsEnabled(true);
            bulkAssessmentBtn.disabled = false;
        }
    });
}

/* Affected: ensure the manual Snipper launch also sends a tiny JSON body removed */

const pagerEl = document.getElementById('pager');
const prevBtn = document.getElementById('prevPageBtn');
const nextBtn = document.getElementById('nextPageBtn');
prevBtn.addEventListener('click', async () => {
  if(currentPage > 1){
    await loadRows(currentPage - 1);
    refreshAccountTokens();
  }
});
nextBtn.addEventListener('click', async () => {
  const tp = Math.max(1, Math.ceil((totalRowCount||0)/PAGE_SIZE));
  if(currentPage < tp){
    await loadRows(currentPage + 1);
    refreshAccountTokens();
  }
});

(async () => { await loadRows(1); refreshAccountTokens(); })();

function escapeHtml(str){
  return String(str||'').replace(/[&<>"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[s]));
}

async function formatExperienceText(raw){
  const text = (raw||'').toString().trim();
  if(!text) return '';
  
  if(!window.__GEMINI_EXPERIENCE_FORMAT_API) window.__GEMINI_EXPERIENCE_FORMAT_API = '/gemini/experience_format';
  
  try {
    const res = await fetch(window.__GEMINI_EXPERIENCE_FORMAT_API, {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ text })
    });
    if(!res.ok) throw new Error('Experience format API failed');
    const data = await res.json();
    
    // Construct simplified string that includes the full experience and education arrays
    let out = '';
    if(data.experience && data.experience.length) {
      out += 'Experience\n' + data.experience.join('\n') + '\n\n';
    }
    if(data.education && data.education.length) {
      out += 'Education\n' + data.education.join('\n') + '\n\n';
    }
    if(data.language && data.language.length) {
      out += 'Language\n' + data.language.join('\n');
    }
    // Return the combined formatted content (not truncated to one record)
    return out.trim() || text; // fallback to raw
  } catch(e) {
    console.warn('Experience format error', e);
    return text;
  }
}

/* ========================================================= */
/* DATA SORTER LOGIC EMBEDDED - MERGED FROM DATA_SORTER.JS */
/* ========================================================= */

/* Globals for Data Sorter */
let inferenceResult = null;
let jobFamilyChart = null;
let seniorityChart = null;
let companyChart = null;
let activeFilters = {
    'auto-job-family-group': {},
    'auto-seniority-group': {},
    'auto-company-group': {},
    'suggested-country-group': {}
};
/* Map rendering reintroduced using Leaflet */

/* Drag and Drop Setup */
function makeDraggable(element, type, value) {
  element.setAttribute('draggable', 'true');
  element.dataset.dragType = type;
  element.dataset.dragValue = value;
  element.addEventListener('dragstart', handleDragStart);
  element.addEventListener('dragend', handleDragEnd);
}

function handleDragStart(e) {
  e.dataTransfer.effectAllowed = 'copy';
  const dragData = JSON.stringify({
      type: e.target.dataset.dragType,
      value: e.target.dataset.dragValue,
      sourceId: e.target.parentElement.id
  });
  e.dataTransfer.setData('application/json', dragData);
  e.target.classList.add('dragging');
  const sourceId = e.target.parentElement.id;
  document.querySelectorAll('.ds-checkbox-group').forEach(group => {
    if (group.id && group.id !== sourceId) {
        group.classList.add('drop-target-active');
    }
  });
}

function handleDragEnd(e) {
  e.target.classList.remove('dragging');
  document.querySelectorAll('.ds-checkbox-group').forEach(group => {
    group.classList.remove('drop-target-active');
    group.classList.remove('drop-hover');
  });
}

function setupDropZones() {
  const containers = ['auto-job-family-group', 'auto-seniority-group', 'auto-company-group', 'suggested-country-group'];
  containers.forEach(id => {
    const container = document.getElementById(id);
    if (!container) return;
    container.addEventListener('dragover', e => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; container.classList.add('drop-hover'); });
    container.addEventListener('dragleave', e => { container.classList.remove('drop-hover'); });
    container.addEventListener('drop', e => {
      e.preventDefault(); container.classList.remove('drop-hover');
      try {
          const rawData = e.dataTransfer.getData('application/json');
          if (!rawData) return;
          const data = JSON.parse(rawData);
          if (container.id === data.sourceId) return;
          applyFilter(container.id, data.type, data.value);
      } catch (err) { console.warn('Drop error', err); }
    });
  });
}

function applyFilter(targetContainerId, filterType, filterValue) {
    if (!activeFilters[targetContainerId]) activeFilters[targetContainerId] = {};
    if (!activeFilters[targetContainerId][filterType]) activeFilters[targetContainerId][filterType] = [];
    if (!activeFilters[targetContainerId][filterType].includes(filterValue)) {
        activeFilters[targetContainerId][filterType].push(filterValue);
        updateFilterUI(targetContainerId);
        recalculateContainer(targetContainerId);
    }
}

function removeFilter(targetContainerId, filterType, filterValue) {
    if (activeFilters[targetContainerId] && activeFilters[targetContainerId][filterType]) {
        activeFilters[targetContainerId][filterType] = activeFilters[targetContainerId][filterType].filter(v => v !== filterValue);
        if (activeFilters[targetContainerId][filterType].length === 0) {
            delete activeFilters[targetContainerId][filterType];
        }
        updateFilterUI(targetContainerId);
        recalculateContainer(targetContainerId);
    }
}

function updateFilterUI(containerId) {
    let filterDivId = '';
    if (containerId === 'auto-job-family-group') filterDivId = 'job-family-filters';
    else if (containerId === 'auto-seniority-group') filterDivId = 'seniority-filters';
    else if (containerId === 'auto-company-group') filterDivId = 'company-filters';
    else if (containerId === 'suggested-country-group') filterDivId = 'country-filters';
    
    const filterContainer = document.getElementById(filterDivId);
    if (!filterContainer) return;
    
    filterContainer.innerHTML = '';
    const containerFilters = activeFilters[containerId] || {};
    Object.keys(containerFilters).forEach(type => {
        containerFilters[type].forEach(val => {
            const badge = document.createElement('div');
            badge.className = 'ds-filter-badge';
            badge.innerHTML = `<span>${type}: ${val}</span><span class="remove-filter">Ã—</span>`;
            badge.querySelector('.remove-filter').addEventListener('click', () => { removeFilter(containerId, type, val); });
            filterContainer.appendChild(badge);
        });
    });
}

function recalculateContainer(containerId) {
    if (!inferenceResult || !inferenceResult.per_title_mapping) return;
    const mapping = inferenceResult.per_title_mapping;
    const filters = activeFilters[containerId] || {};
    
    const filteredRows = mapping.filter(row => {
        for (const [type, values] of Object.entries(filters)) {
            let rowValue = '';
            if (type === 'family') rowValue = row.family;
            else if (type === 'seniority') rowValue = row.seniority;
            else if (type === 'company') rowValue = row.company;
            else if (type === 'country') rowValue = row.country;
            if (!values.includes(rowValue)) return false;
        }
        return true;
    });
    
    const counts = {};
    filteredRows.forEach(row => {
        let key = '';
        if (containerId === 'auto-job-family-group') key = row.family;
        else if (containerId === 'auto-seniority-group') key = row.seniority;
        else if (containerId === 'auto-company-group') key = row.company;
        else if (containerId === 'suggested-country-group') key = row.country;
        if (key) counts[key] = (counts[key] || 0) + 1;
    });
    
    if (containerId === 'auto-job-family-group') {
        const fakeRes = { suggestions: Object.entries(counts).map(([k,v]) => ({family: k, count: v})) };
        renderFamilies(fakeRes, true); 
    } else if (containerId === 'auto-seniority-group') {
        rebuildCheckboxGroup(containerId, counts, 'suggested-seniority');
        renderSeniorityViz(null, true);
    } else if (containerId === 'auto-company-group') {
        rebuildCheckboxGroup(containerId, counts, 'suggested-company');
        renderCompanyViz(null, true);
    } else if (containerId === 'suggested-country-group') {
        rebuildCheckboxGroup(containerId, counts, 'suggested-country');
        renderLocations(null, true); 
    }
}

function rebuildCheckboxGroup(containerId, counts, inputName) {
    const c = document.getElementById(containerId);
    c.innerHTML = '';
    const sorted = Object.entries(counts).sort((a,b)=>b[1]-a[1]);
    if (sorted.length === 0) { c.innerHTML = '<em class="subtle">No matching data.</em>'; return; }
    const limit = (containerId === 'auto-company_group' || containerId === 'suggested-country-group') ? 120 : 1000;
    sorted.slice(0, limit).forEach(([label, count]) => {
         c.innerHTML+=`<label><input type="checkbox" name="${inputName}" value="${label}" checked>
      <span>${label}</span><span class="count-bubble">${count}</span></label>`;
    });
    decorateCheckboxGroups();
}

function decorateCheckboxGroups(){
    document.querySelectorAll('.ds-checkbox-group').forEach(group=>{
      let dragType = null;
      if (group.id === 'auto-job-family-group') dragType = 'family';
      else if (group.id === 'auto-seniority-group') dragType = 'seniority';
      else if (group.id === 'auto-company-group') dragType = 'company';
      else if (group.id === 'suggested-country-group') dragType = 'country';

      group.querySelectorAll('label').forEach((label, index)=>{
        if (label.dataset.decorated === '1') return;
        const input = label.querySelector('input[type="checkbox"]');
        let val = input ? input.value : label.textContent.trim();
        if (!label.id) label.id = `bubble-${Math.random().toString(36).substr(2, 9)}-${index}`;
        if (!label.hasAttribute('tabindex')) label.setAttribute('tabindex','0');
        if (input) {
            if (input.checked) label.classList.add('selected');
            else label.classList.remove('selected');
            input.addEventListener('change', () => {
                if (input.checked) label.classList.add('selected');
                else label.classList.remove('selected');
            });
        }
        if (dragType) {
             makeDraggable(label, dragType, val);
             let isDragging = false;
             label.addEventListener('dragstart', ()=>{ isDragging = true; });
             label.addEventListener('dragend', ()=>{ setTimeout(()=>{ isDragging = false; }, 50); });
             label.addEventListener('click', (ev)=>{
                if (isDragging || ev.target === input) return;
                ev.preventDefault();
                input.checked = !input.checked;
                input.dispatchEvent(new Event('change'));
             });
        }
        label.dataset.decorated = '1';
      });
    });
}

/* Visualization Helpers with Fixed Chart Types */
function createChartInstance(canvasEl, type, labels, values, palette, optionsOverride){
    if(!canvasEl) return null;
    const ctx = canvasEl.getContext('2d');
    
    // Adjust data structure for Scatter if needed
    let datasets = [{ label: 'Count', data: values, backgroundColor: palette, borderWidth: 1 }];
    if (type === 'scatter') {
        datasets = [{
            label: 'Distribution',
            data: labels.map((l, i) => ({ x: i, y: values[i], label: l })),
            backgroundColor: palette[0]
        }];
    }

    return new Chart(ctx, {
      type: type,
      data: { labels: labels, datasets: datasets },
      options: { 
          maintainAspectRatio: false, 
          plugins: { legend: { display: type==='pie'||type==='doughnut' } },
          scales: (type === 'scatter') ? {
              x: { type: 'linear', position: 'bottom', ticks: { callback: function(val, index) { return this.getLabelForValue(val) || ''; } } }
          } : undefined,
          ...optionsOverride 
      }
    });
}

/* Render Table Helper */
function renderTableViz(containerId, labels, values) {
    const container = document.getElementById(containerId);
    if (!container) return;
    let html = '<table class="ds-table" style="margin-top:0;"><thead><tr><th class="ds-th">Category</th><th class="ds-th">Count</th></tr></thead><tbody>';
    labels.forEach((l, i) => {
        html += `<tr><td class="ds-td">${l}</td><td class="ds-td">${values[i]}</td></tr>`;
    });
    html += '</tbody></table>';
    container.innerHTML = html;
}

function renderFamilies(res, useDOM=false){
    const container = document.getElementById('auto-job-family-group');
    if(!container) return;
    if(!useDOM && res && res.suggestions){
        container.innerHTML = '';
        res.suggestions.forEach(s => {
            container.innerHTML += `<label><input type="checkbox" name="suggested-family" value="${s.family}" checked><span>${s.family}</span><span class="count-bubble">${s.count}</span></label>`;
        });
        decorateCheckboxGroups();
    }
    renderFamilyViz(res, useDOM);
}

function renderFamilyViz(res, useDOM=false){
    const sel = document.getElementById('viz-select-jobfamily');
    const mode = sel ? sel.value : 'None';
    const canvas = document.getElementById('jobfamily-chart');
    const tableDiv = document.getElementById('jobfamily-table');
    
    if(jobFamilyChart) { jobFamilyChart.destroy(); jobFamilyChart=null; }
    if(tableDiv) tableDiv.innerHTML = '';
    
    let suggestions = [];
    if (useDOM) { 
        // Scrape current checkboxes for data
        const container = document.getElementById('auto-job-family-group');
        suggestions = Array.from(container.querySelectorAll('label')).map(l=>{
            const txt = l.querySelector('span:first-of-type').textContent;
            const cnt = parseInt(l.querySelector('.count-bubble').textContent);
            return {family:txt, count:cnt};
        });
    } else {
        suggestions = (res && res.suggestions) ? res.suggestions : [];
    }
    
    if(!suggestions.length || mode === 'None') { if(canvas) canvas.style.display='none'; return; }
    
    const sorted = suggestions.slice().sort((a,b)=>b.count-a.count).slice(0,50);
    const labels = sorted.map(s=>s.family);
    const values = sorted.map(s=>s.count);
    const palette = labels.map((_,i) => ['rgba(76,130,184,0.88)','rgba(109,234,249,0.88)','rgba(4,120,87,0.88)','rgba(7,54,121,0.88)'][i % 4]);
    
    if (mode === 'Table') {
        if(canvas) canvas.style.display='none';
        renderTableViz('jobfamily-table', labels, values);
        return;
    }

    if(canvas) canvas.style.display='block';
    let type = 'bar', options = {};
    if(mode==='Bar') { type='bar'; options={indexAxis:'y'}; }
    else if(mode==='Column') type='bar';
    else if(mode==='Pie') type='pie';
    else if(mode==='Donut') type='doughnut';
    else if(mode==='Line') type='line';
    else if(mode==='Area') { type='line'; options={fill:true}; }
    else if(mode==='Scatter') type='scatter';
    
    jobFamilyChart = createChartInstance(canvas, type, labels, values, palette, options);
}

function renderSeniorities(res){ /* Populates #auto-seniority-group */
    if(!res || !res.per_title_mapping) return;
    const counts = {};
    res.per_title_mapping.forEach(r => { if(r.seniority) counts[r.seniority] = (counts[r.seniority]||0)+1; });
    rebuildCheckboxGroup('auto-seniority-group', counts, 'suggested-seniority');
    renderSeniorityViz();
}
function renderSeniorityViz(res, useDOM=true){
    const sel = document.getElementById('viz-select-seniority');
    const mode = sel ? sel.value : 'None';
    const canvas = document.getElementById('seniority-chart');
    const tableDiv = document.getElementById('seniority-table');

    if(seniorityChart) { seniorityChart.destroy(); seniorityChart=null; }
    if(tableDiv) tableDiv.innerHTML = '';

    if(mode === 'None') { if(canvas) canvas.style.display='none'; return; }
    
    const container = document.getElementById('auto-seniority-group');
    const items = Array.from(container.querySelectorAll('label')).map(l=>{
        const txt = l.querySelector('span:first-of-type').textContent;
        const cnt = parseInt(l.querySelector('.count-bubble').textContent);
        return {label:txt, count:cnt};
    });
    
    const labels = items.map(i=>i.label);
    const values = items.map(i=>i.count);
    const palette = labels.map((_,i) => ['rgba(76,130,184,0.88)','rgba(109,234,249,0.88)'][i%2]);
    
    if (mode === 'Table') {
        if(canvas) canvas.style.display='none';
        renderTableViz('seniority-table', labels, values);
        return;
    }

    if(canvas) canvas.style.display='block';
    let type='bar', options={};
    if(mode==='Bar') { type='bar'; options={indexAxis:'y'}; }
    else if(mode==='Column') type='bar';
    else if(mode==='Pie') type='pie';
    else if(mode==='Donut') type='doughnut';
    else if(mode==='Line') type='line';
    else if(mode==='Area') { type='line'; options={fill:true}; }
    else if(mode==='Scatter') type='scatter';
    
    seniorityChart = createChartInstance(canvas, type, labels, values, palette, options);
}

function renderCompanies(res){
    if(!res || !res.company_suggestions) return;
    const counts = {};
    res.company_suggestions.forEach(c => counts[c.company] = c.count);
    rebuildCheckboxGroup('auto-company-group', counts, 'suggested-company');
    renderCompanyViz();
}
function renderCompanyViz(res, useDOM=true){
    const sel = document.getElementById('viz-select-company');
    const mode = sel ? sel.value : 'None';
    const canvas = document.getElementById('company-chart');
    const tableDiv = document.getElementById('company-table');

    if(companyChart) { companyChart.destroy(); companyChart=null; }
    if(tableDiv) tableDiv.innerHTML = '';

    if(mode === 'None') { if(canvas) canvas.style.display='none'; return; }
    
    const container = document.getElementById('auto-company-group');
    const items = Array.from(container.querySelectorAll('label')).map(l=>{
        const txt = l.querySelector('span:first-of-type').textContent;
        const cnt = parseInt(l.querySelector('.count-bubble').textContent);
        return {label:txt, count:cnt};
    }).slice(0,50);
    
    const labels = items.map(i=>i.label);
    const values = items.map(i=>i.count);
    const palette = labels.map((_,i) => ['rgba(7,54,121,0.88)','rgba(109,234,249,0.88)'][i%2]);
    
    if (mode === 'Table') {
        if(canvas) canvas.style.display='none';
        renderTableViz('company-table', labels, values);
        return;
    }

    if(canvas) canvas.style.display='block';
    let type='bar', options={};
    if(mode==='Bar') { type='bar'; options={indexAxis:'y'}; }
    else if(mode==='Column') type='bar';
    else if(mode==='Pie') type='pie';
    else if(mode==='Donut') type='doughnut';
    else if(mode==='Line') type='line';
    else if(mode==='Area') { type='line'; options={fill:true}; }
    else if(mode==='Scatter') type='scatter';
    
    companyChart = createChartInstance(canvas, type, labels, values, palette, options);
}

// Updated Render Locations to provide Map option using Leaflet (fallback geocoding via Nominatim)
function renderLocations(res, useDOM=true) {
    // 1. Determine mode
    const sel = document.getElementById('viz-select-country');
    const mode = sel ? sel.value : 'Table';
    const mapDiv = document.getElementById('country-map');
    const canvas = document.getElementById('country-chart-canvas');
    const tableDiv = document.getElementById('country-table');
    
    // Clear previous
    if(mapDiv) mapDiv.innerHTML = '';
    if(tableDiv) tableDiv.innerHTML = '';
    
    // Hide mapDiv by default (we'll show as needed)
    if(mapDiv) mapDiv.style.display = 'none';
    if(canvas) canvas.parentNode.style.display = 'none';

    // 2. Gather Data (Country counts)
    let countryCounts = [];
    if(useDOM) {
        // Scrape from checkbox group
        const container = document.getElementById('suggested-country-group');
        countryCounts = Array.from(container.querySelectorAll('label')).map(l=>{
            const txt = l.querySelector('span:first-of-type').textContent;
            const cnt = parseInt(l.querySelector('.count-bubble').textContent);
            return {label: txt, count: cnt};
        });
    } else if(res && res.country_suggestions) {
        countryCounts = res.country_suggestions.map(c => ({label: c.country, count: c.count}));
    }
    
    const labels = countryCounts.map(i=>i.label);
    const values = countryCounts.map(i=>i.count);
    
    // 3. Render based on mode
    if (mode === 'Table') {
        if(canvas) canvas.parentNode.style.display='none';
        renderTableViz('country-table', labels, values);
        return;
    }

    if (mode === 'Column' || mode === 'Bar') {
        if(canvas) {
            canvas.parentNode.style.display='block';
            // reuse existing render path
            let type = (mode === 'Bar') ? 'bar' : 'bar';
            let options = (mode === 'Bar') ? { indexAxis: 'y' } : {};
            if(window._countryChartInstance) {
                try { window._countryChartInstance.destroy(); } catch(e){}
                window._countryChartInstance = null;
            }
            const palette = labels.map((_,i) => ['#0284c7','#0ea5e9'][i%2]);
            window._countryChartInstance = createChartInstance(canvas, type, labels, values, palette, options);
        }
        return;
    }

    if (mode === 'Map') {
        if (!mapDiv) return;
        mapDiv.style.display = 'block';
        // Initialize map (singleton)
        if (!window._countryMapInstance) {
            try {
                window._countryMapInstance = L.map('country-map', { zoomControl: true, attributionControl: false }).setView([20, 0], 2);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    maxZoom: 18
                }).addTo(window._countryMapInstance);
                window._countryMapMarkers = [];
            } catch (e) {
                console.warn('Leaflet init failed', e);
                return;
            }
        } else {
            // clear existing markers
            try {
                if (window._countryMapMarkers && window._countryMapMarkers.length) {
                    window._countryMapMarkers.forEach(m => {
                        try { window._countryMapInstance.removeLayer(m); } catch(e){}
                    });
                    window._countryMapMarkers = [];
                }
            } catch(e){ console.warn('Failed clearing markers', e); }
        }

        // Geocode cache key
        const GEO_CACHE_KEY = 'sv_geo_cache_v1';
        let geoCache = {};
        try { geoCache = JSON.parse(localStorage.getItem(GEO_CACHE_KEY) || '{}'); } catch(e){ geoCache = {}; }

        async function geocodeCountry(countryName) {
            if (!countryName) return null;
            if (geoCache[countryName]) return geoCache[countryName];
            try {
                // Use Nominatim to geocode country name (one-off)
                const url = 'https://nominatim.openstreetmap.org/search?format=json&limit=1&country=' + encodeURIComponent(countryName);
                const r = await fetch(url, { headers: { 'Accept-Language': 'en' } });
                if (!r.ok) return null;
                const arr = await r.json();
                if (!Array.isArray(arr) || !arr.length) return null;
                const lat = parseFloat(arr[0].lat);
                const lon = parseFloat(arr[0].lon);
                if (isNaN(lat) || isNaN(lon)) return null;
                geoCache[countryName] = [lat, lon];
                try { localStorage.setItem(GEO_CACHE_KEY, JSON.stringify(geoCache)); } catch(e){}
                return [lat, lon];
            } catch (e) {
                console.warn('Geocode failed for', countryName, e);
                return null;
            }
        }

        // Add markers for each country â€” do them sequentially to avoid rate limits
        (async () => {
            for (let i = 0; i < countryCounts.length; i++) {
                const row = countryCounts[i];
                const cname = row.label;
                const cnt = row.count || 1;
                try {
                    const coords = await geocodeCountry(cname);
                    if (!coords) continue;
                    const lat = coords[0], lon = coords[1];
                    const radius = Math.max(6, Math.min(40, 4 + Math.sqrt(cnt) * 3));
                    const marker = L.circleMarker([lat, lon], {
                        radius: radius,
                        fillColor: '#1976d2',
                        color: '#0b5fa8',
                        weight: 1,
                        opacity: 1,
                        fillOpacity: 0.7
                    }).addTo(window._countryMapInstance);
                    marker.bindPopup(`<strong>${escapeHtml(cname)}</strong><br/>Count: ${cnt}`);
                    window._countryMapMarkers.push(marker);
                } catch (e) {
                    console.warn('Marker add failed for', row, e);
                }
            }
            // Fit map bounds if markers present
            try {
                if (window._countryMapMarkers && window._countryMapMarkers.length) {
                    const group = L.featureGroup(window._countryMapMarkers);
                    window._countryMapInstance.fitBounds(group.getBounds().pad(0.35));
                } else {
                    window._countryMapInstance.setView([20, 0], 2);
                }
            } catch (e) { console.warn('Map fit bounds failed', e); }
        })();

        return;
    }
}

/* Fallback Inference Logic (Client Side) */
function clientInferFallback(body, t0) {
  try {
    const uploaded_columns = body.uploaded_columns || [];
    const rows = body.rows || [];
    const lowerCols = uploaded_columns.map(h => String(h || '').toLowerCase());
    const titleIdx = lowerCols.findIndex(h => h.includes('title') || h.includes('job') || h.includes('role'));
    const companyIdx = lowerCols.findIndex(h => h.includes('company'));
    const countryIdx = lowerCols.findIndex(h => h.includes('country'));

    const per_title_mapping = [];
    const familyCounts = {};
    const seniorityCounts = {};
    const companyCounts = {};
    const countryCounts = {};

    const familyMap = [
      { k: /clinical|research|cra|ccrp|crs/i, family: 'Clinical Research' },
      { k: /engineer|developer|software|sde|programmer/i, family: 'Engineering' },
      { k: /data|analyst|scientist|machine learning|ml/i, family: 'Data' },
      { k: /design|ui|ux|artist|art director/i, family: 'Design' },
      { k: /product|pm |product manager/i, family: 'Product' },
      { k: /marketing|growth|brand/i, family: 'Marketing' },
      { k: /sales|account/i, family: 'Sales' },
      { k: /hr|people|recruit/i, family: 'People Operations' },
      { k: /finance|accountant|fp&a|controller/i, family: 'Finance' }
    ];

    function guessFamily(title) {
      if (!title) return 'Other';
      for (const m of familyMap) {
        if (m.k.test(title)) return m.family;
      }
      return 'Other';
    }
    function guessSeniority(title) {
      if (!title) return '';
      const t = title.toLowerCase();
      if (/\b(senior|sr\.?|lead|principal)\b/.test(t)) return 'Senior';
      if (/\b(manager|mgr|head)\b/.test(t)) return 'Manager';
      if (/\b(associate|assistant|junior|grad|intern)\b/.test(t)) return 'Junior';
      return 'Mid';
    }

    for (let r of rows) {
      const title = (titleIdx >= 0 && r[titleIdx]) ? String(r[titleIdx]).trim() : '';
      const company = (companyIdx >= 0 && r[companyIdx]) ? String(r[companyIdx]).trim() : '';
      const country = (countryIdx >= 0 && r[countryIdx]) ? String(r[countryIdx]).trim() : '';
      const family = guessFamily(title);
      const seniority = guessSeniority(title);
      per_title_mapping.push({
        title, company, country, family, seniority, geographic: ''
      });
      familyCounts[family] = (familyCounts[family] || 0) + 1;
      if (seniority) seniorityCounts[seniority] = (seniorityCounts[seniority] || 0) + 1;
      if (company) companyCounts[company] = (companyCounts[company] || 0) + 1;
      if (country) countryCounts[country] = (countryCounts[country] || 0) + 1;
    }

    const suggestions = Object.entries(familyCounts).sort((a,b)=>b[1]-a[1]).map(([family,count])=>({ family, count }));
    const company_suggestions = Object.entries(companyCounts).sort((a,b)=>b[1]-a[1]).map(([company,count])=>({ company, count }));
    const country_suggestions = Object.entries(countryCounts).sort((a,b)=>b[1]-a[1]).map(([country,count])=>({ country, count }));
    
    // Pass country counts to UI manually since we don't have a dedicated return key in original function for it
    rebuildCheckboxGroup('suggested-country-group', countryCounts, 'suggested-country');

    inferenceResult = {
      suggestions,
      per_title_mapping,
      company_suggestions,
      country_suggestions, // Ensure this exists for renderLocations
      processing_seconds: (performance.now() - t0)/1000
    };

    renderFamilies(inferenceResult);
    renderSeniorities(inferenceResult);
    renderCompanies(inferenceResult);
    renderLocations(inferenceResult); // Call Table Render instead of Map
    setupDropZones(); 
    
    // Wire up Viz Selectors
    ['viz-select-jobfamily', 'viz-select-seniority', 'viz-select-company', 'viz-select-country'].forEach(id => {
        const el = document.getElementById(id);
        if(el) el.addEventListener('change', () => {
            if(id.includes('jobfamily')) renderFamilyViz(inferenceResult, true);
            if(id.includes('seniority')) renderSeniorityViz(inferenceResult, true);
            if(id.includes('company')) renderCompanyViz(inferenceResult, true);
            if(id.includes('country')) renderLocations(inferenceResult, true);
        });
    });

    return inferenceResult;
  } catch (e) {
    console.warn('clientInferFallback failed', e);
    return null;
  }
}

// Wire Export Button
document.getElementById('ds-export-excel-btn').addEventListener('click', () => {
    // Basic export logic reusing SourcingVerify existing export function or similar
    exportExcelXlsxAndPurge(); // Reusing the main one for now as it does similar job
});

</script>
</body>
</html>